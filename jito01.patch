From b5d97f3c387486949aa913bfdbb2431ec5dd748e Mon Sep 17 00:00:00 2001
From: Lucas B <lucas@jito.wtf>
Date: Thu, 25 Aug 2022 17:18:46 -0500
Subject: [PATCH 1/5] jito patch only reroute if relayer connected (#123) feat:
 add client tls config (#121) remove extra val (#129) fix clippy (#130) copy
 all binaries to docker-output (#131) Ledger tool halts at slot passed to
 create-snapshot (#118) update program submodule (#133) quick fix for tips and
 clearing old bundles (#135) update submodule to new program (#136) Improve
 stake-meta-generator usability (#134) pinning submodule head (#140) Use
 BundleAccountLocker when handling tip txs (#147) Add metrics for relayer +
 block engine proxy (#149) Build claim-mev in docker (#141) Rework bundle
 receiving and add metrics (#152) (#154) update submodule + dev files (#158)
 Deterministically find tip amounts, add meta to stake info, and cleanup
 pubkey/strings in MEV tips (#159) update jito-programs submodule (#160)
 Separate MEV tip related workflow (#161) Add block builder fee protos (#162)
 fix jito programs (#163) update submodule so autosnapshot exits out of ledger
 tool early (#164) Pipe through block builder fee (#167) pull in new snapshot
 code (#171) block builder bug (#172)

Pull in new slack autosnapshot submodule (#174)

sort stake meta json and use int math (#176)

add accountsdb conn submod (#169)

Update tip distribution parameters (#177)

new submodules (#180)

Add buildkite link for jito CI (#183)

Fixed broken links to repositories (#184)

Changed from ssh to https transfer for clone

Seg/update submods (#187)

fix tests (#190)

rm geyser submod (#192)

rm dangling geyser references (#193)

fix syntax err (#195)

use deterministic req ids in batch calls (#199)

update jito-programs

revert cargo

update Cargo lock

update with path fix

fix cargo

update autosnapshot with block lookback (#201)

[JIT-460] When claiming mev tips, skip accounts that won't have min rent exempt amount after claiming (#203)

Add logging for sol balance desired (#205)

* add logging

* add logging

* update msg

* tweak vars

update submodule (#204)

use efficient data structures when calling batch_simulate_bundles (#206)

[JIT-504] Add low balance check in uploading merkle roots (#209)

add config to simulate on top of working bank (#211)

rm frozen bank check

simulate_bundle rpc bugfixes (#214)

rm frozen bank check in simulate_bundle rpc method

[JIT-519] Store ClaimStatus address in merkle-root-json (#210)

* add files

* switch to include bump

update submodule (#217)

add amount filter (#218)

update autosnapshot (#222)

Print TX error in Bundles (#223)

add new args to support single relayer and block-engine endpoints (#224)

point to new jito-programs submod and invoke updated init tda instruction (#228)

fix clippy errors (#230)

fix validator start scripts (#232)

Point README to gitbook (#237)

use packaged cargo bin to build (#239)

Add validator identity pubkey to StakeMeta (#226)

The vote account associated with a validator is not a permanent link, so log the validator identity as well.

bugfix: conditionally compile with debug flags (#240)

Seg/tip distributor master (#242)

* validate tree nodes

* fix unit tests

* pr feedback

* bump jito-programs submod

Simplify bootstrapping (#241)

* startup without precompile

* update spacing

* use release mode

* spacing

fix validation

rm validation skip

Account for block builder fee when generating excess tip balance (#247)

Improve docker caching

delay constructing claim mev txs (#253)

fix stake meta tests from bb fee (#254)

fix tests

Buffer bundles that exceed cost model (#225)

* buffer bundles that exceed cost model

clear qos failed bundles buffer if not leader soon (#260)

update Cargo.lock to correct solana versions in jito-programs submodule (#265)

fix simulate_bundle client and better error handling (#267)

update submod (#272)

Preallocate Bundle Cost (#238)

fix Dockerfile (#278)

Fix Tests (#279)

Fix Tests (#281)

* fix tests

update jito-programs submod (#282)

add reclaim rent workflow (#283)

update jito-programs submod

fix clippy errs

rm wrong assertion and swap out file write fn call (#292)

Remove security.md (#293)

demote frequent relayer_stage-stream_error to warn (#275)

account for case where TDA exists but not allocated (#295)

implement better retries for tip-distributor workflows (#297)

limit number of concurrent rpc calls (#298)

Discard Empty Packet Batches (#299)

Identity Hotswap (#290)

small fixes (#305)

Set backend config from admin rpc (#304)

Admin Shred Receiver Change (#306)

Seg/rm bundle UUID (#309)

Fix github workflow to recursively clone (#327)

Add recursive checkout for downstream-project-spl.yaml (#341)

Use cluster info functions for tpu (#345)

Use git rev-parse for git sha

Remove blacklisted tx from message_hash_to_transaction (#374)

Updates bootstrap and start scripts needed for local dev. (#384)

Remove Deprecated Cli Args (#387)

Master Rebase

improve simulate_bundle errors and response (#404)

derive Clone on accountoverrides (#416)

Add upsert to AccountOverrides (#419)

update jito-programs (#430)

[JIT-1661] Faster Autosnapshot (#436)

Reverts simulate_transaction result calls to upstream (#446)

Don't unlock accounts in TransactionBatches used during simulation (#449)

first pass at wiring up jito-plugin (#428)

[JIT-1713] Fix bundle's blockspace preallocation (#489)

[JIT-1708] Fix TOC TOU condition for relayer and block engine config (#491)

[JIT-1710] - Optimize Bundle Consumer Checks (#490)

Add Blockhash Metrics to Bundle Committer (#500)

add priority fee ix to mev-claim (#520)

Update Autosnapshot (#548)

Run MEV claims + reclaiming rent-exempt amounts in parallel. (#582)

Update CI (#584)
- Add recursive submodule checkouts.
- Re-add solana-secondary step

Add more release fixes (#585)

Fix more release urls (#588)

[JIT-1812] Fix blocking mutexs (#495)

 [JIT-1711] Compare the unprocessed transaction storage BundleStorage against a constant instead of VecDeque::capacity() (#587)

Automatically rebase Jito-Solana on a periodic basis. Send message on slack during any failures or success.

Fix periodic rebase #594

Fixes the following bugs in the periodic rebase:
Sends multiple messages on failure instead of one
Cancels entire job if one branch fails

Ignore buildkite curl errors for rebasing and try to keep curling until job times out (#597)

Sleep longer waiting for buildkite to start (#598)

correctly initialize account overrides (#595)

Fix: Ensure set contact info to UDP port instead of QUIC (#603)

Add fast replay branch to daily rebase (#607)

take a snapshot of all bundle accounts before sim (#13) (#615)

update jito-programs submodule
---
 .dockerignore                                 |    9 +
 .github/workflows/cargo.yml                   |    2 +
 .github/workflows/changelog-label.yml         |    1 +
 .github/workflows/client-targets.yml          |    4 +
 .github/workflows/crate-check.yml             |    1 +
 .github/workflows/docs.yml                    |    3 +
 .../workflows/downstream-project-anchor.yml   |    4 +-
 .github/workflows/downstream-project-spl.yml  |   42 +-
 .github/workflows/rebase.yaml                 |  181 ++
 .github/workflows/release-artifacts.yml       |    1 +
 .gitignore                                    |    5 +
 .gitmodules                                   |    9 +
 Cargo.lock                                    |  781 ++++++--
 Cargo.toml                                    |   18 +-
 README.md                                     |   33 +-
 RELEASE.md                                    |   85 +-
 accounts-db/src/accounts.rs                   |  108 +-
 anchor                                        |    1 +
 banking-bench/src/main.rs                     |   14 +-
 banks-server/Cargo.toml                       |    1 +
 banks-server/src/banks_server.rs              |    5 +-
 bootstrap                                     |   26 +
 bundle/Cargo.toml                             |   37 +
 bundle/src/bundle_execution.rs                | 1216 +++++++++++++
 bundle/src/lib.rs                             |   60 +
 ci/buildkite-pipeline-in-disk.sh              |    4 +-
 ci/buildkite-pipeline.sh                      |    4 +-
 ci/buildkite-secondary.yml                    |   62 +-
 ci/buildkite-solana-private.sh                |    4 +-
 ci/channel-info.sh                            |    2 +-
 ci/check-crates.sh                            |    3 +
 ci/publish-installer.sh                       |   11 +-
 ci/publish-tarball.sh                         |    4 +-
 ci/test-coverage.sh                           |    2 +-
 ci/upload-github-release-asset.sh             |    2 +-
 core/Cargo.toml                               |   13 +
 core/benches/banking_stage.rs                 |   24 +-
 core/benches/consumer.rs                      |   28 +-
 core/benches/proto_to_packet.rs               |   56 +
 core/src/admin_rpc_post_init.rs               |    8 +-
 core/src/banking_stage.rs                     |   85 +-
 core/src/banking_stage/committer.rs           |   17 +-
 core/src/banking_stage/consume_worker.rs      |   23 +-
 core/src/banking_stage/consumer.rs            |  195 +-
 .../banking_stage/latest_unprocessed_votes.rs |    2 +-
 core/src/banking_stage/qos_service.rs         |   48 +-
 .../unprocessed_transaction_storage.rs        |  452 ++++-
 core/src/banking_trace.rs                     |    1 +
 core/src/bundle_stage.rs                      |  434 +++++
 .../src/bundle_stage/bundle_account_locker.rs |  326 ++++
 core/src/bundle_stage/bundle_consumer.rs      | 1584 +++++++++++++++++
 .../bundle_packet_deserializer.rs             |  271 +++
 .../bundle_stage/bundle_packet_receiver.rs    |  825 +++++++++
 .../bundle_reserved_space_manager.rs          |  237 +++
 .../bundle_stage_leader_metrics.rs            |  506 ++++++
 core/src/bundle_stage/committer.rs            |  227 +++
 core/src/bundle_stage/result.rs               |   41 +
 core/src/consensus_cache_updater.rs           |   52 +
 core/src/immutable_deserialized_bundle.rs     |  488 +++++
 core/src/lib.rs                               |   44 +
 core/src/packet_bundle.rs                     |    7 +
 core/src/proxy/auth.rs                        |  185 ++
 core/src/proxy/block_engine_stage.rs          |  571 ++++++
 core/src/proxy/fetch_stage_manager.rs         |  170 ++
 core/src/proxy/mod.rs                         |  100 ++
 core/src/proxy/relayer_stage.rs               |  515 ++++++
 core/src/tip_manager.rs                       |  588 ++++++
 core/src/tpu.rs                               |  115 +-
 core/src/tpu_entry_notifier.rs                |   66 +-
 core/src/tvu.rs                               |    3 +
 core/src/validator.rs                         |  103 +-
 core/tests/epoch_accounts_hash.rs             |    2 +
 core/tests/snapshots.rs                       |    2 +
 cost-model/src/cost_tracker.rs                |    8 +
 deploy_programs                               |   17 +
 dev/Dockerfile                                |   48 +
 docs/src/cli/install.md                       |   37 +-
 docs/src/clusters/benchmark.md                |    2 +-
 docs/src/implemented-proposals/installer.md   |   35 +-
 entry/src/entry.rs                            |    2 +-
 entry/src/poh.rs                              |   29 +-
 f                                             |   30 +
 fetch-spl.sh                                  |   41 +-
 gossip/src/cluster_info.rs                    |    4 +
 install/agave-install-init.sh                 |    4 +-
 install/src/command.rs                        |    8 +-
 jito-programs                                 |    1 +
 jito-protos/Cargo.toml                        |   19 +
 jito-protos/build.rs                          |   38 +
 jito-protos/protos                            |    1 +
 jito-protos/src/lib.rs                        |   25 +
 ledger-tool/src/bigtable.rs                   |    1 +
 ledger-tool/src/ledger_utils.rs               |   18 +-
 ledger-tool/src/main.rs                       |    8 +-
 ledger-tool/src/program.rs                    |    1 +
 ledger/src/bank_forks_utils.rs                |   22 +-
 ledger/src/blockstore_processor.rs            |    5 +-
 ledger/src/token_balances.rs                  |   55 +-
 local-cluster/src/local_cluster.rs            |    3 +
 .../src/local_cluster_snapshot_utils.rs       |    6 +-
 local-cluster/src/validator_configs.rs        |    5 +
 local-cluster/tests/local_cluster.rs          |   17 +-
 merkle-tree/src/merkle_tree.rs                |   46 +-
 multinode-demo/bootstrap-validator.sh         |   34 +
 multinode-demo/validator.sh                   |   40 +
 perf/src/sigverify.rs                         |    2 +-
 poh/src/poh_recorder.rs                       |  136 +-
 poh/src/poh_service.rs                        |   34 +-
 program-runtime/src/timings.rs                |   23 +-
 program-test/src/programs.rs                  |   18 +
 .../programs/jito_tip_distribution-0.1.4.so   |  Bin 0 -> 423080 bytes
 .../src/programs/jito_tip_payment-0.1.4.so    |  Bin 0 -> 430592 bytes
 programs/sbf/Cargo.lock                       |  616 +++++--
 programs/sbf/tests/programs.rs                |    4 +-
 rpc-client-api/Cargo.toml                     |    2 +
 rpc-client-api/src/bundles.rs                 |  166 ++
 rpc-client-api/src/lib.rs                     |    1 +
 rpc-client-api/src/request.rs                 |    2 +
 rpc-client/src/nonblocking/rpc_client.rs      |   56 +-
 rpc-client/src/rpc_client.rs                  |   14 +
 rpc-test/Cargo.toml                           |    1 +
 rpc-test/tests/rpc.rs                         |    2 +
 rpc/Cargo.toml                                |    2 +
 rpc/src/rpc.rs                                |  489 ++++-
 rpc/src/rpc_service.rs                        |    9 +-
 runtime-plugin/Cargo.toml                     |   22 +
 runtime-plugin/src/lib.rs                     |    4 +
 runtime-plugin/src/runtime_plugin.rs          |   41 +
 .../src/runtime_plugin_admin_rpc_service.rs   |  326 ++++
 runtime-plugin/src/runtime_plugin_manager.rs  |  275 +++
 runtime-plugin/src/runtime_plugin_service.rs  |  123 ++
 runtime/src/bank.rs                           |   97 +-
 runtime/src/snapshot_bank_utils.rs            |   16 +-
 runtime/src/snapshot_utils.rs                 |   24 +-
 runtime/src/stake_account.rs                  |    4 +-
 runtime/src/stakes.rs                         |   12 +-
 runtime/src/transaction_batch.rs              |   24 +-
 rustfmt.toml                                  |    5 +
 s                                             |   15 +
 scripts/agave-install-deploy.sh               |    4 +-
 scripts/increment-cargo-version.sh            |    2 +
 scripts/run.sh                                |    4 +
 sdk/Cargo.toml                                |   17 +-
 sdk/src/bundle/mod.rs                         |   33 +
 sdk/src/lib.rs                                |    1 +
 send-transaction-service/Cargo.toml           |    2 +
 .../src/send_transaction_service.rs           |   47 +-
 start                                         |    9 +
 start_multi                                   |   30 +
 svm/src/account_loader.rs                     |    5 +
 svm/src/account_overrides.rs                  |    6 +-
 svm/src/transaction_processor.rs              |    2 +-
 test-validator/src/lib.rs                     |    1 +
 tip-distributor/Cargo.toml                    |   61 +
 tip-distributor/README.md                     |   52 +
 tip-distributor/src/bin/claim-mev-tips.rs     |  190 ++
 .../src/bin/merkle-root-generator.rs          |   34 +
 .../src/bin/merkle-root-uploader.rs           |   54 +
 .../src/bin/stake-meta-generator.rs           |   67 +
 tip-distributor/src/claim_mev_workflow.rs     |  398 +++++
 tip-distributor/src/lib.rs                    | 1062 +++++++++++
 .../src/merkle_root_generator_workflow.rs     |   54 +
 .../src/merkle_root_upload_workflow.rs        |  138 ++
 tip-distributor/src/reclaim_rent_workflow.rs  |  310 ++++
 .../src/stake_meta_generator_workflow.rs      |  973 ++++++++++
 transaction-status/src/lib.rs                 |    9 +-
 turbine/benches/cluster_info.rs               |    1 +
 turbine/benches/retransmit_stage.rs           |    3 +-
 turbine/src/broadcast_stage.rs                |   51 +-
 .../broadcast_duplicates_run.rs               |    1 +
 .../broadcast_fake_shreds_run.rs              |    1 +
 .../src/broadcast_stage/broadcast_utils.rs    |   55 +-
 .../fail_entry_verification_broadcast_run.rs  |    4 +-
 .../broadcast_stage/standard_broadcast_run.rs |   24 +-
 turbine/src/retransmit_stage.rs               |   15 +-
 validator/Cargo.toml                          |    2 +
 validator/src/admin_rpc_service.rs            |  110 +-
 validator/src/bootstrap.rs                    |    3 +-
 validator/src/cli.rs                          |  205 +++
 validator/src/main.rs                         |  268 ++-
 version/src/lib.rs                            |    2 +-
 wen-restart/src/wen_restart.rs                |    4 +-
 182 files changed, 17778 insertions(+), 870 deletions(-)
 create mode 100644 .dockerignore
 create mode 100644 .github/workflows/rebase.yaml
 create mode 100644 .gitmodules
 create mode 160000 anchor
 create mode 100755 bootstrap
 create mode 100644 bundle/Cargo.toml
 create mode 100644 bundle/src/bundle_execution.rs
 create mode 100644 bundle/src/lib.rs
 create mode 100644 core/benches/proto_to_packet.rs
 create mode 100644 core/src/bundle_stage.rs
 create mode 100644 core/src/bundle_stage/bundle_account_locker.rs
 create mode 100644 core/src/bundle_stage/bundle_consumer.rs
 create mode 100644 core/src/bundle_stage/bundle_packet_deserializer.rs
 create mode 100644 core/src/bundle_stage/bundle_packet_receiver.rs
 create mode 100644 core/src/bundle_stage/bundle_reserved_space_manager.rs
 create mode 100644 core/src/bundle_stage/bundle_stage_leader_metrics.rs
 create mode 100644 core/src/bundle_stage/committer.rs
 create mode 100644 core/src/bundle_stage/result.rs
 create mode 100644 core/src/consensus_cache_updater.rs
 create mode 100644 core/src/immutable_deserialized_bundle.rs
 create mode 100644 core/src/packet_bundle.rs
 create mode 100644 core/src/proxy/auth.rs
 create mode 100644 core/src/proxy/block_engine_stage.rs
 create mode 100644 core/src/proxy/fetch_stage_manager.rs
 create mode 100644 core/src/proxy/mod.rs
 create mode 100644 core/src/proxy/relayer_stage.rs
 create mode 100644 core/src/tip_manager.rs
 create mode 100755 deploy_programs
 create mode 100644 dev/Dockerfile
 create mode 100755 f
 create mode 160000 jito-programs
 create mode 100644 jito-protos/Cargo.toml
 create mode 100644 jito-protos/build.rs
 create mode 160000 jito-protos/protos
 create mode 100644 jito-protos/src/lib.rs
 create mode 100644 program-test/src/programs/jito_tip_distribution-0.1.4.so
 create mode 100644 program-test/src/programs/jito_tip_payment-0.1.4.so
 create mode 100644 rpc-client-api/src/bundles.rs
 create mode 100644 runtime-plugin/Cargo.toml
 create mode 100644 runtime-plugin/src/lib.rs
 create mode 100644 runtime-plugin/src/runtime_plugin.rs
 create mode 100644 runtime-plugin/src/runtime_plugin_admin_rpc_service.rs
 create mode 100644 runtime-plugin/src/runtime_plugin_manager.rs
 create mode 100644 runtime-plugin/src/runtime_plugin_service.rs
 create mode 100755 s
 create mode 100644 sdk/src/bundle/mod.rs
 create mode 100755 start
 create mode 100755 start_multi
 create mode 100644 tip-distributor/Cargo.toml
 create mode 100644 tip-distributor/README.md
 create mode 100644 tip-distributor/src/bin/claim-mev-tips.rs
 create mode 100644 tip-distributor/src/bin/merkle-root-generator.rs
 create mode 100644 tip-distributor/src/bin/merkle-root-uploader.rs
 create mode 100644 tip-distributor/src/bin/stake-meta-generator.rs
 create mode 100644 tip-distributor/src/claim_mev_workflow.rs
 create mode 100644 tip-distributor/src/lib.rs
 create mode 100644 tip-distributor/src/merkle_root_generator_workflow.rs
 create mode 100644 tip-distributor/src/merkle_root_upload_workflow.rs
 create mode 100644 tip-distributor/src/reclaim_rent_workflow.rs
 create mode 100644 tip-distributor/src/stake_meta_generator_workflow.rs

diff --git a/.dockerignore b/.dockerignore
new file mode 100644
index 000000000000..99262ca8942e
--- /dev/null
+++ b/.dockerignore
@@ -0,0 +1,9 @@
+.dockerignore
+.git/
+.github/
+.gitignore
+.idea/
+README.md
+Dockerfile
+f
+target/
diff --git a/.github/workflows/cargo.yml b/.github/workflows/cargo.yml
index e64852e42835..a9ba8d26a93b 100644
--- a/.github/workflows/cargo.yml
+++ b/.github/workflows/cargo.yml
@@ -35,6 +35,8 @@ jobs:
     runs-on: ${{ matrix.os }}
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - uses: mozilla-actions/sccache-action@v0.0.4
         with:
diff --git a/.github/workflows/changelog-label.yml b/.github/workflows/changelog-label.yml
index ffd8ec21033e..3da79c6e9103 100644
--- a/.github/workflows/changelog-label.yml
+++ b/.github/workflows/changelog-label.yml
@@ -13,6 +13,7 @@ jobs:
     - uses: actions/checkout@v4
       with:
         fetch-depth: 0
+        submodules: 'recursive'
     - name: Check if changes to CHANGELOG.md
       shell: bash
       env:
diff --git a/.github/workflows/client-targets.yml b/.github/workflows/client-targets.yml
index 1a33d2ae5949..4d3255595416 100644
--- a/.github/workflows/client-targets.yml
+++ b/.github/workflows/client-targets.yml
@@ -32,6 +32,8 @@ jobs:
     runs-on: ${{ matrix.os }}
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - run: cargo install cargo-ndk@2.12.2
 
@@ -56,6 +58,8 @@ jobs:
     runs-on: ${{ matrix.os }}
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - name: Setup Rust
         run: |
diff --git a/.github/workflows/crate-check.yml b/.github/workflows/crate-check.yml
index 6f130853ac14..b92b182baa7c 100644
--- a/.github/workflows/crate-check.yml
+++ b/.github/workflows/crate-check.yml
@@ -19,6 +19,7 @@ jobs:
       - uses: actions/checkout@v4
         with:
           fetch-depth: 0
+          submodules: 'recursive'
 
       - name: Get commit range (push)
         if: ${{ github.event_name == 'push' }}
diff --git a/.github/workflows/docs.yml b/.github/workflows/docs.yml
index c348d69acbe4..bb402372c6d2 100644
--- a/.github/workflows/docs.yml
+++ b/.github/workflows/docs.yml
@@ -22,6 +22,7 @@ jobs:
         uses: actions/checkout@v4
         with:
           fetch-depth: 0
+          submodules: 'recursive'
 
       - name: Get commit range (push)
         if: ${{ github.event_name == 'push' }}
@@ -77,6 +78,8 @@ jobs:
     steps:
       - name: Checkout
         uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - name: Setup Node
         uses: actions/setup-node@v4
diff --git a/.github/workflows/downstream-project-anchor.yml b/.github/workflows/downstream-project-anchor.yml
index 1ac129a3f6e9..ea0ff6046d52 100644
--- a/.github/workflows/downstream-project-anchor.yml
+++ b/.github/workflows/downstream-project-anchor.yml
@@ -43,10 +43,12 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        version: ["v0.29.0", "v0.30.0"]
+        version: [ "v0.29.0", "v0.30.0" ]
     if: false # Re-enable once new major versions for spl-token-2022 and spl-pod are out
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - shell: bash
         run: |
diff --git a/.github/workflows/downstream-project-spl.yml b/.github/workflows/downstream-project-spl.yml
index 8d3baf25949e..be3bc9986e38 100644
--- a/.github/workflows/downstream-project-spl.yml
+++ b/.github/workflows/downstream-project-spl.yml
@@ -42,6 +42,8 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - shell: bash
         run: |
@@ -68,7 +70,7 @@ jobs:
         arrays:
           [
             {
-              test_paths: ["token/cli"],
+              test_paths: [ "token/cli" ],
               required_programs:
                 [
                   "token/program",
@@ -78,14 +80,14 @@ jobs:
                 ],
             },
             {
-              test_paths: ["single-pool/cli"],
+              test_paths: [ "single-pool/cli" ],
               required_programs:
                 [
                   "single-pool/program",
                 ],
             },
             {
-              test_paths: ["token-upgrade/cli"],
+              test_paths: [ "token-upgrade/cli" ],
               required_programs:
                 [
                   "token-upgrade/program",
@@ -94,6 +96,8 @@ jobs:
           ]
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - shell: bash
         run: |
@@ -128,26 +132,28 @@ jobs:
     strategy:
       matrix:
         programs:
-          - [token/program]
+          - [ token/program ]
           - [
-              instruction-padding/program,
-              token/program-2022,
-              token/program-2022-test,
-            ]
+            instruction-padding/program,
+            token/program-2022,
+            token/program-2022-test,
+          ]
           - [
-              associated-token-account/program,
-              associated-token-account/program-test,
-            ]
-          - [token-upgrade/program]
-          - [feature-proposal/program]
-          - [governance/addin-mock/program, governance/program]
-          - [memo/program]
-          - [name-service/program]
-          - [stake-pool/program]
-          - [single-pool/program]
+            associated-token-account/program,
+            associated-token-account/program-test,
+          ]
+          - [ token-upgrade/program ]
+          - [ feature-proposal/program ]
+          - [ governance/addin-mock/program, governance/program ]
+          - [ memo/program ]
+          - [ name-service/program ]
+          - [ stake-pool/program ]
+          - [ single-pool/program ]
 
     steps:
       - uses: actions/checkout@v4
+        with:
+          submodules: 'recursive'
 
       - shell: bash
         run: |
diff --git a/.github/workflows/rebase.yaml b/.github/workflows/rebase.yaml
new file mode 100644
index 000000000000..5fcc61fff4dc
--- /dev/null
+++ b/.github/workflows/rebase.yaml
@@ -0,0 +1,181 @@
+# This workflow runs a periodic rebase process, pulling in updates from an upstream repository
+# The workflow for rebasing a jito-solana branch to a solana labs branch locally is typically:
+# $ git checkout v1.17
+# $ git pull --rebase # --rebase needed locally
+# $ git branch -D lb/v1.17_rebase # deletes branch from last v1.17 rebase
+# $ git checkout -b lb/v1.17_rebase
+# $ git fetch upstream
+# $ git rebase upstream/v1.17 # rebase + fix merge conflicts
+# $ git rebase --continue
+# $ git push origin +lb/v1.17_rebase # force needed to overwrite remote. wait for CI, fix if any issues
+# $ git checkout v1.17
+# $ git reset --hard lb/v1.17_rebase
+# $ git push origin +v1.17
+#
+# This workflow automates this process, with periodic status updates over slack.
+# It will also run CI and wait for it to pass before performing the force push to v1.17.
+# In the event there's a failure in the process, it's reported to slack and the job stops.
+
+name: "Rebase jito-solana from upstream anza-xyz/agave"
+
+on:
+  #  push:
+  schedule:
+    - cron: "30 18 * * 1-5"
+
+jobs:
+  rebase:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        include:
+          - branch: master
+            rebase: upstream/master
+          - branch: v1.18
+            rebase: upstream/v1.18
+          - branch: v1.17
+            rebase: upstream/v1.17
+            # note: this will always be a day behind because we're rebasing from the previous day's rebase
+            # and NOT upstream
+          - branch: v1.17-fast-replay
+            rebase: origin/v1.17
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          ref: ${{ matrix.branch }}
+          submodules: recursive
+          fetch-depth: 0
+          token: ${{ secrets.JITO_SOLANA_RELEASE_TOKEN }}
+      - name: Add upstream
+        run: git remote add upstream https://github.com/anza-xyz/agave.git
+      - name: Fetch upstream
+        run: git fetch upstream
+      - name: Fetch origin
+        run: git fetch origin
+      - name: Set REBASE_BRANCH
+        run: echo "REBASE_BRANCH=ci/nightly/${{ matrix.branch }}/$(date +'%Y-%m-%d-%H-%M')" >> $GITHUB_ENV
+      - name: echo $REBASE_BRANCH
+        run: echo $REBASE_BRANCH
+      - name: Create rebase branch
+        run: git checkout -b $REBASE_BRANCH
+      - name: Setup email
+        run: |
+          git config --global user.email "infra@jito.wtf"
+          git config --global user.name "Jito Infrastructure"
+      - name: Rebase
+        id: rebase
+        run: git rebase ${{ matrix.rebase }}
+      - name: Send warning for rebase error
+        if: failure() && steps.rebase.outcome == 'failure'
+        uses: slackapi/slack-github-action@v1.25.0
+        with:
+          payload: |
+            {
+              "text": "Nightly rebase on branch ${{ matrix.branch }}\nStatus: Rebase failed to apply cleanly"
+            }
+        env:
+          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
+      - name: Check if rebase applied
+        id: check_rebase_applied
+        run: |
+          PRE_REBASE_SHA=$(git rev-parse ${{ matrix.branch }})
+          POST_REBASE_SHA=$(git rev-parse HEAD)
+          if [ "$PRE_REBASE_SHA" = "$POST_REBASE_SHA" ]; then
+            echo "No rebase was applied, exiting..."
+            exit 1
+          else
+            echo "Rebase applied successfully."
+          fi
+      - name: Send warning for rebase error
+        if: failure() && steps.check_rebase_applied.outcome == 'failure'
+        uses: slackapi/slack-github-action@v1.25.0
+        with:
+          payload: |
+            {
+              "text": "Nightly rebase on branch ${{ matrix.branch }}\nStatus: Rebase not needed"
+            }
+        env:
+          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
+      - name: Set REBASE_SHA
+        run: echo "REBASE_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
+      - name: Push changes
+        uses: ad-m/github-push-action@master
+        with:
+          github_token: ${{ secrets.GITHUB_TOKEN }}
+          branch: ${{ env.REBASE_BRANCH }}
+      - name: Wait for buildkite to start build
+        run: sleep 300
+      - name: Wait for buildkite to finish
+        id: wait_for_buildkite
+        timeout-minutes: 300
+        run: |
+          while true; do
+            response=$(curl -s -f -H "Authorization: Bearer ${{ secrets.BUILDKITE_TOKEN }}" "https://api.buildkite.com/v2/organizations/jito/pipelines/jito-solana/builds?commit=${{ env.REBASE_SHA }}")
+            if [ $? -ne 0 ]; then
+              echo "Curl request failed."
+              exit 1
+            fi
+
+            state=$(echo $response | jq --exit-status -r '.[0].state')
+            echo "Current build state: $state"
+
+            # Check if the state is one of the finished states
+            case $state in
+              "passed"|"finished")
+                echo "Build finished successfully."
+                exit 0
+              ;;
+              "canceled"|"canceling"|"not_run")
+                # ignoring "failing"|"failed" because flaky CI, can restart and hope it finishes or times out
+                echo "Build failed or was cancelled."
+                exit 2
+              ;;
+            esac
+
+          sleep 30
+          done
+      - name: Send failure update
+        uses: slackapi/slack-github-action@v1.25.0
+        if: failure() && steps.wait_for_buildkite.outcome == 'failure'
+        with:
+          payload: |
+            {
+              "text": "Nightly rebase on branch ${{ matrix.branch }}\nStatus: CI failed\nBranch: ${{ env.REBASE_BRANCH}}\nBuild: https://buildkite.com/jito/jito-solana/builds?commit=${{ env.REBASE_SHA }}"
+            }
+        env:
+          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
+      # check to see if different branch since CI build can take awhile and these steps are not atomic
+      - name: Fetch the latest remote changes
+        run: git fetch origin ${{ matrix.branch }}
+      - name: Check if origin HEAD has changed from the beginning of the workflow
+        run: |
+          LOCAL_SHA=$(git rev-parse ${{ matrix.branch }})
+          ORIGIN_SHA=$(git rev-parse origin/${{ matrix.branch }})
+          if [ "$ORIGIN_SHA" != "$LOCAL_SHA" ]; then
+            echo "The remote HEAD of ${{ matrix.branch }} does not match the local HEAD of ${{ matrix.branch }} at the beginning of CI."
+            echo "origin sha: $ORIGIN_SHA"
+            echo "local sha: $LOCAL_SHA"
+            exit 1
+          else
+            echo "The remote HEAD matches the local REBASE_SHA at the beginning of CI. Proceeding."
+          fi
+      - name: Reset ${{ matrix.branch }} to ${{ env.REBASE_BRANCH }}
+        run: |
+          git checkout ${{ matrix.branch }}
+          git reset --hard ${{ env.REBASE_BRANCH }}
+      - name: Push rebased %{{ matrix.branch }}
+        uses: ad-m/github-push-action@master
+        with:
+          github_token: ${{ secrets.JITO_SOLANA_RELEASE_TOKEN }}
+          branch: ${{ matrix.branch }}
+          force: true
+      - name: Send success update
+        uses: slackapi/slack-github-action@v1.25.0
+        with:
+          payload: |
+            {
+              "text": "Nightly rebase on branch ${{ matrix.branch }}\nStatus: CI success, rebased, and pushed\nBranch: ${{ env.REBASE_BRANCH}}\nBuild: https://buildkite.com/jito/jito-solana/builds?commit=${{ env.REBASE_SHA }}"
+            }
+        env:
+          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
\ No newline at end of file
diff --git a/.github/workflows/release-artifacts.yml b/.github/workflows/release-artifacts.yml
index de32cee71dfc..0543c964ded0 100644
--- a/.github/workflows/release-artifacts.yml
+++ b/.github/workflows/release-artifacts.yml
@@ -22,6 +22,7 @@ jobs:
         with:
           ref: master
           fetch-depth: 0
+          submodules: 'recursive'
 
       - name: Setup Rust
         shell: bash
diff --git a/.gitignore b/.gitignore
index 995129e50d16..92dd63fbc96a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,6 +4,7 @@ target/
 /solana-release.tar.bz2
 /solana-metrics/
 /solana-metrics.tar.bz2
+**/target/
 /test-ledger/
 
 **/*.rs.bk
@@ -27,7 +28,11 @@ log-*/
 # fetch-spl.sh artifacts
 /spl-genesis-args.sh
 /spl_*.so
+/jito_*.so
 
 .DS_Store
 # scripts that may be generated by cargo *-bpf commands
 **/cargo-*-bpf-child-script-*.sh
+
+.env
+docker-output/
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 000000000000..e31fc7fccd92
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,9 @@
+[submodule "anchor"]
+	path = anchor
+	url = https://github.com/jito-foundation/anchor.git
+[submodule "jito-programs"]
+	path = jito-programs
+	url = https://github.com/jito-foundation/jito-programs.git
+[submodule "jito-protos/protos"]
+	path = jito-protos/protos
+	url = https://github.com/jito-labs/mev-protos.git
diff --git a/Cargo.lock b/Cargo.lock
index bcd4ec8002dd..561c177d4ac7 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -154,7 +154,7 @@ name = "agave-ledger-tool"
 version = "2.0.10"
 dependencies = [
  "assert_cmd",
- "bs58",
+ "bs58 0.5.1",
  "bytecount",
  "chrono",
  "clap 2.33.3",
@@ -266,6 +266,7 @@ dependencies = [
  "solana-rpc-client",
  "solana-rpc-client-api",
  "solana-runtime",
+ "solana-runtime-plugin",
  "solana-sdk",
  "solana-send-transaction-service",
  "solana-storage-bigtable",
@@ -280,6 +281,7 @@ dependencies = [
  "thiserror",
  "tikv-jemallocator",
  "tokio",
+ "tonic",
 ]
 
 [[package]]
@@ -364,6 +366,145 @@ version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"
 
+[[package]]
+name = "anchor-attribute-access-control"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "regex",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-account"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "bs58 0.4.0",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "rustversion",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-constant"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "proc-macro2 1.0.85",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-error"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-event"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-interface"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "heck 0.3.3",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-program"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-state"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-derive-accounts"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-lang"
+version = "0.24.2"
+dependencies = [
+ "anchor-attribute-access-control",
+ "anchor-attribute-account",
+ "anchor-attribute-constant",
+ "anchor-attribute-error",
+ "anchor-attribute-event",
+ "anchor-attribute-interface",
+ "anchor-attribute-program",
+ "anchor-attribute-state",
+ "anchor-derive-accounts",
+ "arrayref",
+ "base64 0.13.1",
+ "bincode",
+ "borsh 0.10.3",
+ "bytemuck",
+ "solana-program",
+ "thiserror",
+]
+
+[[package]]
+name = "anchor-syn"
+version = "0.24.2"
+dependencies = [
+ "anyhow",
+ "bs58 0.3.1",
+ "heck 0.3.3",
+ "proc-macro2 1.0.85",
+ "proc-macro2-diagnostics",
+ "quote 1.0.36",
+ "serde",
+ "serde_json",
+ "sha2 0.9.9",
+ "syn 1.0.109",
+ "thiserror",
+]
+
 [[package]]
 name = "android-tzdata"
 version = "0.1.1"
@@ -394,12 +535,55 @@ dependencies = [
  "winapi 0.3.9",
 ]
 
+[[package]]
+name = "anstream"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ca84f3628370c59db74ee214b3263d58f9aadd9b4fe7e711fd87dc452b7f163"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is-terminal",
+ "utf8parse",
+]
+
 [[package]]
 name = "anstyle"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3a30da5c5f2d5e72842e00bcb57657162cdabef0931f40e2deb9b4140440cecd"
 
+[[package]]
+name = "anstyle-parse"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c03a11a9034d92058ceb6ee011ce58af4a9bf61491aa7e1e59ecd24bd40d22d4"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ad186efb764318d35165f1758e7dcef3b10628e26d41a44bc5550652e6804391"
+dependencies = [
+ "windows-sys 0.52.0",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c677ab05e09154296dd37acecd46420c17b9713e8366facafa8fc0885167cf4c"
+dependencies = [
+ "anstyle",
+ "windows-sys 0.48.0",
+]
+
 [[package]]
 name = "anyhow"
 version = "1.0.86"
@@ -415,8 +599,8 @@ dependencies = [
  "include_dir",
  "itertools 0.10.5",
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -489,7 +673,7 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3ed4aa4fe255d0bc6d79373f7e31d2ea147bcf486cba1be5ba7ea85abdb92348"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -501,8 +685,8 @@ checksum = "7abe79b0e4288889c4574159ab790824d0033b9fdcb2a112a3182fac2e514565"
 dependencies = [
  "num-bigint 0.4.5",
  "num-traits",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -537,8 +721,8 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ae3281bc6d0fd7e549af32b52511e1302185bd688fd3359fa36423346ff682ea"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -598,8 +782,8 @@ version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "726535892e8eae7e70657b4c8ea93d26b8553afb1ce617caee529ef96d7dee6c"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
  "synstructure",
 ]
@@ -610,8 +794,8 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2777730b2039ac0f95f093556e61b6d26cebed5393ca6f152717777cec3a42ed"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -691,8 +875,8 @@ version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "648ed8c8d2ce5409ccd57453d9d1b214b342a0d69376a6feda1fd6cae3299308"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -702,8 +886,8 @@ version = "0.1.80"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c6fa2087f2753a7da8cc1c0dbfcf89579dd57458e36769de5ac750b4671737ca"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -852,8 +1036,8 @@ dependencies = [
  "itertools 0.12.1",
  "lazy_static",
  "lazycell",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "regex",
  "rustc-hash",
  "shlex",
@@ -1000,7 +1184,7 @@ dependencies = [
  "borsh-derive-internal",
  "borsh-schema-derive-internal",
  "proc-macro-crate 0.1.5",
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "syn 1.0.109",
 ]
 
@@ -1012,8 +1196,8 @@ checksum = "c3ef8005764f53cd4dca619f5bf64cafd4664dada50ece25e4d81de54c80cc0b"
 dependencies = [
  "once_cell",
  "proc-macro-crate 3.1.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
  "syn_derive",
 ]
@@ -1024,8 +1208,8 @@ version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "afb438156919598d2c7bad7e1c0adf3d26ed3840dbc010db1a882a65583ca2fb"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1035,8 +1219,8 @@ version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "634205cc43f74a1b9046ef87c4540ebda95696ec0f315024860cad7c5b0f5ccd"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1061,6 +1245,18 @@ dependencies = [
  "alloc-stdlib",
 ]
 
+[[package]]
+name = "bs58"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "476e9cd489f9e121e02ffa6014a8ef220ecb15c05ed23fc34cca13925dc283fb"
+
+[[package]]
+name = "bs58"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "771fe0050b883fcc3ea2359b1a96bcfbc090b7116eae7c3c512c7a083fdf23d3"
+
 [[package]]
 name = "bs58"
 version = "0.5.1"
@@ -1144,8 +1340,8 @@ version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1ee891b04274a59bd38b412188e24b849617b2e45a0fd8d057deb63e7403761b"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -1383,7 +1579,7 @@ checksum = "71655c45cb9845d3270c9d6df84ebe72b4dad3c2ba3f7023ad47c144e4e473a5"
 dependencies = [
  "atty",
  "bitflags 1.3.2",
- "clap_derive",
+ "clap_derive 3.2.18",
  "clap_lex 0.2.4",
  "indexmap 1.9.3",
  "once_cell",
@@ -1399,6 +1595,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c27cdf28c0f604ba3f512b0c9a409f8de8513e4816705deb0498b627e7c3a3fd"
 dependencies = [
  "clap_builder",
+ "clap_derive 4.3.12",
+ "once_cell",
 ]
 
 [[package]]
@@ -1407,8 +1605,10 @@ version = "4.3.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "08a9f1ab5e9f01a9b81f202e8562eb9a10de70abf9eaeac1be465c28b75aa4aa"
 dependencies = [
+ "anstream",
  "anstyle",
  "clap_lex 0.5.0",
+ "strsim 0.10.0",
 ]
 
 [[package]]
@@ -1417,13 +1617,25 @@ version = "3.2.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ea0c8bce528c4be4da13ea6fead8965e95b6073585a2f05204bd8f4119f82a65"
 dependencies = [
- "heck",
+ "heck 0.4.0",
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
+[[package]]
+name = "clap_derive"
+version = "4.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "54a9bb5758fc5dfe728d1019941681eccaf0cf8a4189b692a0ee2f2ecf90a050"
+dependencies = [
+ "heck 0.4.0",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 2.0.66",
+]
+
 [[package]]
 name = "clap_lex"
 version = "0.2.4"
@@ -1439,6 +1651,12 @@ version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2da6da31387c7e4ef160ffab6d5e7f00c42626fe39aea70a7b0f1773f7dd6c1b"
 
+[[package]]
+name = "colorchoice"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b6a852b24ab71dffc585bcb46eaf7959d175cb865a7152e35b348d1b2960422"
+
 [[package]]
 name = "combine"
 version = "3.8.1"
@@ -1509,9 +1727,9 @@ version = "0.2.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c7f6ff08fd20f4f299298a28e2dfa8a8ba1036e6cd2460ac1de7b425d76f2500"
 dependencies = [
- "proc-macro2",
- "quote",
- "unicode-xid",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "unicode-xid 0.2.2",
 ]
 
 [[package]]
@@ -1760,8 +1978,8 @@ checksum = "ab8bfa2e259f8ee1ce5e97824a3c55ec4404a0d772ca7fa96bf19f0752a046eb"
 dependencies = [
  "fnv",
  "ident_case",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "strsim 0.10.0",
  "syn 2.0.66",
 ]
@@ -1773,7 +1991,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "29a358ff9f12ec09c3e61fef9b5a9902623a695a46a917b07f269bff1445611a"
 dependencies = [
  "darling_core",
- "quote",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -1797,6 +2015,17 @@ version = "2.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3ee2393c4a91429dffb4bedf19f4d6abf27d8a732c8ce4980305d782e5426d57"
 
+[[package]]
+name = "default-env"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f753eb82d29277e79efc625e84aecacfd4851ee50e05a8573a4740239a77bfd3"
+dependencies = [
+ "proc-macro2 0.4.30",
+ "quote 0.6.13",
+ "syn 0.15.44",
+]
+
 [[package]]
 name = "der-parser"
 version = "8.1.0"
@@ -1823,8 +2052,8 @@ version = "2.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1834,8 +2063,8 @@ version = "1.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "67e77553c4162a157adbf834ebae5b415acbecbeafc7a74b0e886657506a7611"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -1846,8 +2075,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "40eebddd2156ce1bb37b20bbe5151340a31828b1f2d22ba4141f3531710e38df"
 dependencies = [
  "convert_case",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustc_version 0.3.3",
  "syn 1.0.109",
 ]
@@ -1935,8 +2164,8 @@ version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1958,8 +2187,8 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a6cbae11b3de8fce2a456e8ea3dada226b35fe791f0dc1d360c0941f0bb681f3"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -2023,8 +2252,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f86b50932a01e7ec5c06160492ab660fb19b6bb2a7878030dd6cd68d21df9d4d"
 dependencies = [
  "enum-ordinalize",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -2064,8 +2293,8 @@ version = "1.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "03cdc46ec28bd728e67540c528013c6a10eb69a02eb31078a1bda695438cbfb8"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -2077,8 +2306,8 @@ checksum = "0b166c9e378360dd5a6666a9604bb4f54ae0cac39023ffbac425e917a2a04fef"
 dependencies = [
  "num-bigint 0.4.5",
  "num-traits",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -2334,8 +2563,8 @@ version = "0.3.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -2621,6 +2850,15 @@ dependencies = [
  "http",
 ]
 
+[[package]]
+name = "heck"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
+dependencies = [
+ "unicode-segmentation",
+]
+
 [[package]]
 name = "heck"
 version = "0.4.0"
@@ -2895,8 +3133,8 @@ version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b139284b5cf57ecfa712bcc66950bb635b31aff41c188e8a4cfc758eca374a3f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
 ]
 
 [[package]]
@@ -2998,6 +3236,49 @@ version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
 
+[[package]]
+name = "jito-programs-vote-state"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "bincode",
+ "serde",
+ "serde_derive",
+ "solana-program",
+]
+
+[[package]]
+name = "jito-protos"
+version = "2.0.10"
+dependencies = [
+ "bytes",
+ "prost",
+ "prost-types",
+ "protobuf-src",
+ "tonic",
+ "tonic-build",
+]
+
+[[package]]
+name = "jito-tip-distribution"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "default-env",
+ "jito-programs-vote-state",
+ "solana-program",
+ "solana-security-txt",
+]
+
+[[package]]
+name = "jito-tip-payment"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "default-env",
+ "solana-security-txt",
+]
+
 [[package]]
 name = "jobserver"
 version = "0.1.24"
@@ -3078,8 +3359,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5b939a78fa820cdfcb7ee7484466746a7377760970f6f9c6fe19f9edcc8a38d2"
 dependencies = [
  "proc-macro-crate 0.1.5",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3491,8 +3772,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "22ce75669015c4f47b289fd4d4f56e894e4c96003ffdf3ac51313126f94c6cbb"
 dependencies = [
  "cfg-if 1.0.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3512,8 +3793,8 @@ version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a7d5f7076603ebc68de2dc6a650ec331a062a13abaa346975be747bbfa4b789"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3633,8 +3914,8 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -3706,8 +3987,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "681030a937600a36906c185595136d26abfebb4aa9c65701cefcaf8578bb982b"
 dependencies = [
  "proc-macro-crate 3.1.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -3789,8 +4070,8 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b501e44f11665960c7e7fcf062c7d96a14ade4aa98116c004b2e37b5be7d736c"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3996,8 +4277,8 @@ checksum = "99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55"
 dependencies = [
  "pest",
  "pest_meta",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -4047,8 +4328,8 @@ version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "069bdb1e05adc7a8990dce9cc75370895fbe4e3d58b9b73bf1aee56359344a55"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -4170,7 +4451,7 @@ version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3b83ec2d0af5c5c556257ff52c9f98934e243b9fd39604bfb2a9b75ec2e97f18"
 dependencies = [
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "syn 1.0.109",
 ]
 
@@ -4205,8 +4486,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
 dependencies = [
  "proc-macro-error-attr",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
  "version_check",
 ]
@@ -4217,11 +4498,20 @@ version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "version_check",
 ]
 
+[[package]]
+name = "proc-macro2"
+version = "0.4.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759"
+dependencies = [
+ "unicode-xid 0.1.0",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.85"
@@ -4231,6 +4521,19 @@ dependencies = [
  "unicode-ident",
 ]
 
+[[package]]
+name = "proc-macro2-diagnostics"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bf29726d67464d49fa6224a1d07936a8c08bb3fba727c7493f6cf1616fdaada"
+dependencies = [
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+ "version_check",
+ "yansi",
+]
+
 [[package]]
 name = "proptest"
 version = "1.4.0"
@@ -4268,7 +4571,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "119533552c9a7ffacc21e099c24a0ac8bb19c2a2a3f363de84cd9b844feab270"
 dependencies = [
  "bytes",
- "heck",
+ "heck 0.4.0",
  "itertools 0.10.5",
  "lazy_static",
  "log",
@@ -4291,8 +4594,8 @@ checksum = "e5d2d8d10f3c6ded6da8b05b5fb3b8a5082514344d56c9f871412d29b4e075b4"
 dependencies = [
  "anyhow",
  "itertools 0.10.5",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -4337,8 +4640,8 @@ version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9e2e25ee72f5b24d773cae88422baddefff7714f97aab68d96fe2b6fc4a28fb2"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -4396,13 +4699,22 @@ dependencies = [
  "windows-sys 0.48.0",
 ]
 
+[[package]]
+name = "quote"
+version = "0.6.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ce23b6b870e8f94f81fb0a363d65d86675884b34a09043c81e5562f11c1f8e1"
+dependencies = [
+ "proc-macro2 0.4.30",
+]
+
 [[package]]
 name = "quote"
 version = "1.0.36"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
 dependencies = [
- "proc-macro2",
+ "proc-macro2 1.0.85",
 ]
 
 [[package]]
@@ -4839,7 +5151,7 @@ checksum = "3f56a14d1f48b391359b22f731fd4bd7e43c97f3c50eee276f3aa09c94784d3e"
 dependencies = [
  "log",
  "ring 0.17.3",
- "rustls-webpki",
+ "rustls-webpki 0.101.7",
  "sct",
 ]
 
@@ -4873,6 +5185,16 @@ dependencies = [
  "base64 0.13.1",
 ]
 
+[[package]]
+name = "rustls-webpki"
+version = "0.100.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f6a5fc258f1c1276dfe3016516945546e2d5383911efc0fc4f1cdc5df3a4ae3"
+dependencies = [
+ "ring 0.16.20",
+ "untrusted 0.7.1",
+]
+
 [[package]]
 name = "rustls-webpki"
 version = "0.101.7"
@@ -4953,8 +5275,8 @@ version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bdbda6ac5cd1321e724fa9cee216f3a61885889b896f073b8f82322789c5250e"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -5051,8 +5373,8 @@ version = "1.0.203"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "500cbc0ebeb6f46627f50f3f5811ccf6bf00643be300b4c3eabc0ef55dc5b5ba"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -5105,8 +5427,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "881b6f881b17d13214e5d494c939ebab463d01264ce1811e9d4ac3a882e7695f"
 dependencies = [
  "darling",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -5155,8 +5477,8 @@ version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "91d129178576168c589c9ec973feedf7d3126c01ac2bf08795109aa35b69fb8f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -5411,7 +5733,7 @@ dependencies = [
  "assert_matches",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "bv",
  "lazy_static",
  "serde",
@@ -5621,6 +5943,7 @@ dependencies = [
  "futures 0.3.30",
  "solana-banks-interface",
  "solana-client",
+ "solana-gossip",
  "solana-runtime",
  "solana-sdk",
  "solana-send-transaction-service",
@@ -5760,6 +6083,28 @@ dependencies = [
  "tempfile",
 ]
 
+[[package]]
+name = "solana-bundle"
+version = "2.0.10"
+dependencies = [
+ "anchor-lang",
+ "assert_matches",
+ "itertools 0.12.1",
+ "log",
+ "serde",
+ "solana-accounts-db",
+ "solana-ledger",
+ "solana-logger",
+ "solana-measure",
+ "solana-poh",
+ "solana-program-runtime",
+ "solana-runtime",
+ "solana-sdk",
+ "solana-svm",
+ "solana-transaction-status",
+ "thiserror",
+]
+
 [[package]]
 name = "solana-cargo-build-bpf"
 version = "2.0.10"
@@ -5846,7 +6191,7 @@ version = "2.0.10"
 dependencies = [
  "assert_matches",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "clap 2.33.3",
  "console",
  "const_format",
@@ -6060,10 +6405,11 @@ name = "solana-core"
 version = "2.0.10"
 dependencies = [
  "ahash 0.8.10",
+ "anchor-lang",
  "assert_matches",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "bytes",
  "chrono",
  "crossbeam-channel",
@@ -6073,12 +6419,17 @@ dependencies = [
  "futures 0.3.30",
  "histogram",
  "itertools 0.12.1",
+ "jito-protos",
+ "jito-tip-distribution",
+ "jito-tip-payment",
  "lazy_static",
  "log",
  "lru",
  "min-max-heap",
  "num_enum",
  "prio-graph",
+ "prost",
+ "prost-types",
  "qualifier_attr",
  "quinn",
  "rand 0.8.5",
@@ -6094,6 +6445,7 @@ dependencies = [
  "serial_test",
  "solana-accounts-db",
  "solana-bloom",
+ "solana-bundle",
  "solana-client",
  "solana-compute-budget",
  "solana-connection-cache",
@@ -6112,11 +6464,13 @@ dependencies = [
  "solana-perf",
  "solana-poh",
  "solana-program-runtime",
+ "solana-program-test",
  "solana-quic-client",
  "solana-rayon-threadlimit",
  "solana-rpc",
  "solana-rpc-client-api",
  "solana-runtime",
+ "solana-runtime-plugin",
  "solana-sdk",
  "solana-send-transaction-service",
  "solana-stake-program",
@@ -6140,6 +6494,8 @@ dependencies = [
  "test-case",
  "thiserror",
  "tokio",
+ "tonic",
+ "tonic-build",
  "trees",
 ]
 
@@ -6286,7 +6642,7 @@ name = "solana-frozen-abi"
 version = "2.0.10"
 dependencies = [
  "bitflags 2.5.0",
- "bs58",
+ "bs58 0.5.1",
  "bv",
  "generic-array 0.14.7",
  "im",
@@ -6306,8 +6662,8 @@ dependencies = [
 name = "solana-frozen-abi-macro"
 version = "2.0.10"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustc_version 0.4.0",
  "syn 2.0.66",
 ]
@@ -6353,7 +6709,7 @@ name = "solana-geyser-plugin-manager"
 version = "2.0.10"
 dependencies = [
  "agave-geyser-plugin-interface",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "json5",
  "jsonrpc-core",
@@ -6437,7 +6793,7 @@ dependencies = [
 name = "solana-keygen"
 version = "2.0.10"
 dependencies = [
- "bs58",
+ "bs58 0.5.1",
  "clap 3.2.23",
  "dirs-next",
  "num_cpus",
@@ -6457,7 +6813,7 @@ dependencies = [
  "assert_matches",
  "bincode",
  "bitflags 2.5.0",
- "bs58",
+ "bs58 0.5.1",
  "byteorder",
  "chrono",
  "chrono-humanize",
@@ -6702,8 +7058,8 @@ dependencies = [
 name = "solana-package-metadata-macro"
 version = "2.0.10"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
  "toml 0.8.12",
 ]
@@ -6804,7 +7160,7 @@ dependencies = [
  "blake3",
  "borsh 0.10.3",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "bv",
  "bytemuck",
  "bytemuck_derive",
@@ -6989,7 +7345,7 @@ version = "2.0.10"
 dependencies = [
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "dashmap",
  "itertools 0.12.1",
@@ -7009,6 +7365,7 @@ dependencies = [
  "soketto",
  "solana-account-decoder",
  "solana-accounts-db",
+ "solana-bundle",
  "solana-client",
  "solana-entry",
  "solana-faucet",
@@ -7020,6 +7377,7 @@ dependencies = [
  "solana-net-utils",
  "solana-perf",
  "solana-poh",
+ "solana-program-runtime",
  "solana-rayon-threadlimit",
  "solana-rpc-client-api",
  "solana-runtime",
@@ -7052,7 +7410,7 @@ dependencies = [
  "async-trait",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "futures 0.3.30",
  "indicatif",
@@ -7080,7 +7438,7 @@ version = "2.0.10"
 dependencies = [
  "anyhow",
  "base64 0.22.1",
- "bs58",
+ "bs58 0.5.1",
  "const_format",
  "jsonrpc-core",
  "reqwest",
@@ -7090,8 +7448,10 @@ dependencies = [
  "serde_derive",
  "serde_json",
  "solana-account-decoder",
+ "solana-bundle",
  "solana-inline-spl",
  "solana-sdk",
+ "solana-svm",
  "solana-transaction-status",
  "solana-version",
  "thiserror",
@@ -7119,13 +7479,14 @@ name = "solana-rpc-test"
 version = "2.0.10"
 dependencies = [
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "futures-util",
  "log",
  "reqwest",
  "serde",
  "serde_json",
+ "serial_test",
  "solana-account-decoder",
  "solana-client",
  "solana-logger",
@@ -7229,6 +7590,24 @@ dependencies = [
  "zstd",
 ]
 
+[[package]]
+name = "solana-runtime-plugin"
+version = "2.0.10"
+dependencies = [
+ "crossbeam-channel",
+ "json5",
+ "jsonrpc-core",
+ "jsonrpc-core-client",
+ "jsonrpc-derive",
+ "jsonrpc-ipc-server",
+ "jsonrpc-server-utils",
+ "libloading",
+ "log",
+ "solana-runtime",
+ "solana-sdk",
+ "thiserror",
+]
+
 [[package]]
 name = "solana-runtime-transaction"
 version = "2.0.10"
@@ -7247,12 +7626,14 @@ dependencies = [
 name = "solana-sdk"
 version = "2.0.10"
 dependencies = [
+ "anchor-lang",
  "anyhow",
  "assert_matches",
+ "base64 0.22.1",
  "bincode",
  "bitflags 2.5.0",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "bytemuck",
  "bytemuck_derive",
  "byteorder",
@@ -7305,9 +7686,9 @@ dependencies = [
 name = "solana-sdk-macro"
 version = "2.0.10"
 dependencies = [
- "bs58",
- "proc-macro2",
- "quote",
+ "bs58 0.5.1",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustversion",
  "syn 2.0.66",
 ]
@@ -7326,11 +7707,13 @@ dependencies = [
  "log",
  "solana-client",
  "solana-connection-cache",
+ "solana-gossip",
  "solana-logger",
  "solana-measure",
  "solana-metrics",
  "solana-runtime",
  "solana-sdk",
+ "solana-streamer",
  "solana-tpu-client",
 ]
 
@@ -7419,7 +7802,7 @@ name = "solana-storage-proto"
 version = "2.0.10"
 dependencies = [
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "enum-iterator",
  "prost",
  "protobuf-src",
@@ -7559,6 +7942,44 @@ dependencies = [
  "solana-sdk",
 ]
 
+[[package]]
+name = "solana-tip-distributor"
+version = "2.0.10"
+dependencies = [
+ "anchor-lang",
+ "clap 4.3.21",
+ "crossbeam-channel",
+ "env_logger",
+ "futures 0.3.30",
+ "gethostname",
+ "im",
+ "itertools 0.12.1",
+ "jito-tip-distribution",
+ "jito-tip-payment",
+ "log",
+ "num-traits",
+ "rand 0.8.5",
+ "serde",
+ "serde_json",
+ "solana-accounts-db",
+ "solana-client",
+ "solana-genesis-utils",
+ "solana-ledger",
+ "solana-measure",
+ "solana-merkle-tree",
+ "solana-metrics",
+ "solana-program",
+ "solana-program-runtime",
+ "solana-rpc-client-api",
+ "solana-runtime",
+ "solana-sdk",
+ "solana-stake-program",
+ "solana-transaction-status",
+ "solana-vote",
+ "thiserror",
+ "tokio",
+]
+
 [[package]]
 name = "solana-tokens"
 version = "2.0.10"
@@ -7685,7 +8106,7 @@ dependencies = [
  "base64 0.22.1",
  "bincode",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "lazy_static",
  "log",
  "serde",
@@ -7900,7 +8321,7 @@ dependencies = [
 name = "solana-zk-keygen"
 version = "2.0.10"
 dependencies = [
- "bs58",
+ "bs58 0.5.1",
  "clap 3.2.23",
  "dirs-next",
  "num_cpus",
@@ -8064,7 +8485,7 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9e8418ea6269dcfb01c712f0444d2c75542c04448b480e87de59d2865edc750"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "spl-discriminator-syn",
  "syn 2.0.66",
 ]
@@ -8075,8 +8496,8 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8c1f05593b7ca9eac7caca309720f2eafb96355e037e6d373b909a80fe7b69b9"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "sha2 0.10.8",
  "syn 2.0.66",
  "thiserror",
@@ -8134,8 +8555,8 @@ version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e6d375dd76c517836353e093c2dbb490938ff72821ab568b545fd30ab3256b3e"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "sha2 0.10.8",
  "syn 2.0.66",
 ]
@@ -8293,9 +8714,9 @@ version = "0.24.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59"
 dependencies = [
- "heck",
- "proc-macro2",
- "quote",
+ "heck 0.4.0",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustversion",
  "syn 1.0.109",
 ]
@@ -8312,14 +8733,25 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a7973cce6668464ea31f176d85b13c7ab3bba2cb3b77a2ed26abd7801688010a"
 
+[[package]]
+name = "syn"
+version = "0.15.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ca4b3b69a77cbe1ffc9e198781b7acb0c7365a883670e8f1c1bc66fba79a5c5"
+dependencies = [
+ "proc-macro2 0.4.30",
+ "quote 0.6.13",
+ "unicode-xid 0.1.0",
+]
+
 [[package]]
 name = "syn"
 version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "unicode-ident",
 ]
 
@@ -8329,8 +8761,8 @@ version = "2.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c42f3f41a2de00b01c0aaad383c5a45241efc8b2d1eda5661812fda5f3cdcff5"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "unicode-ident",
 ]
 
@@ -8341,8 +8773,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1329189c02ff984e9736652b1631330da25eaa6bc639089ed4915d25446cbe7b"
 dependencies = [
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -8358,10 +8790,10 @@ version = "0.12.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
- "unicode-xid",
+ "unicode-xid 0.2.2",
 ]
 
 [[package]]
@@ -8469,8 +8901,8 @@ version = "0.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ee42b4e559f17bce0385ebf511a7beb67d5cc33c12c96b7f4e9789919d9c10f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -8527,8 +8959,8 @@ checksum = "54c25e2cb8f5fcd7318157634e8838aa6f7e4715c96637f969fabaccd1ef5462"
 dependencies = [
  "cfg-if 1.0.0",
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -8539,8 +8971,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "37cfd7bbc88a0104e304229fba519bdc45501a30b760fb72240342f1289ad257"
 dependencies = [
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
  "test-case-core",
 ]
@@ -8575,8 +9007,8 @@ version = "1.0.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "46c3384250002a6d5af4d114f2845d37b57521033f30d5c3f46c4d70e1197533"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -8712,8 +9144,8 @@ name = "tokio-macros"
 version = "2.1.0"
 source = "git+https://github.com/anza-xyz/solana-tokio.git?rev=7cf47705faacf7bf0e43e4131a5377b3291fce21#7cf47705faacf7bf0e43e4131a5377b3291fce21"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -8883,6 +9315,7 @@ dependencies = [
  "percent-encoding 2.3.1",
  "pin-project",
  "prost",
+ "rustls-native-certs",
  "rustls-pemfile 1.0.0",
  "tokio",
  "tokio-rustls",
@@ -8891,6 +9324,7 @@ dependencies = [
  "tower-layer",
  "tower-service",
  "tracing",
+ "webpki-roots 0.23.1",
 ]
 
 [[package]]
@@ -8900,9 +9334,9 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a6fdaae4c2c638bb70fe42803a26fbd6fc6ac8c72f5c59f67ecc2a2dcabf4b07"
 dependencies = [
  "prettyplease",
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "prost-build",
- "quote",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -8956,8 +9390,8 @@ version = "0.1.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -9075,12 +9509,24 @@ dependencies = [
  "tinyvec",
 ]
 
+[[package]]
+name = "unicode-segmentation"
+version = "1.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"
+
 [[package]]
 name = "unicode-width"
 version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973"
 
+[[package]]
+name = "unicode-xid"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
+
 [[package]]
 name = "unicode-xid"
 version = "0.2.2"
@@ -9168,6 +9614,12 @@ version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7cf7d77f457ef8dfa11e4cd5933c5ddb5dc52a94664071951219a97710f0a32b"
 
+[[package]]
+name = "utf8parse"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
+
 [[package]]
 name = "valuable"
 version = "0.1.0"
@@ -9265,8 +9717,8 @@ dependencies = [
  "bumpalo",
  "log",
  "once_cell",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
  "wasm-bindgen-shared",
 ]
@@ -9289,7 +9741,7 @@ version = "0.2.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "wasm-bindgen-macro-support",
 ]
 
@@ -9299,8 +9751,8 @@ version = "0.2.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
@@ -9322,13 +9774,22 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "webpki-roots"
+version = "0.23.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b03058f88386e5ff5310d9111d53f48b17d732b401aeb83a8d5190f2ac459338"
+dependencies = [
+ "rustls-webpki 0.100.3",
+]
+
 [[package]]
 name = "webpki-roots"
 version = "0.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b291546d5d9d1eab74f069c77749f2cb8504a12caa20f0f2de93ddbf6f411888"
 dependencies = [
- "rustls-webpki",
+ "rustls-webpki 0.101.7",
 ]
 
 [[package]]
@@ -9634,6 +10095,12 @@ dependencies = [
  "linked-hash-map",
 ]
 
+[[package]]
+name = "yansi"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09041cd90cf85f7f8b2df60c646f853b7f535ce68f85244eb6731cf89fa498ec"
+
 [[package]]
 name = "zerocopy"
 version = "0.7.31"
@@ -9649,8 +10116,8 @@ version = "0.7.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b3c129550b3e6de3fd0ba67ba5c81818f9805e58b8d7fee80a3a59d2c9fc601a"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
@@ -9669,8 +10136,8 @@ version = "1.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.66",
 ]
 
diff --git a/Cargo.toml b/Cargo.toml
index 7057d15ecd54..80c1fa2d77c1 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -19,6 +19,7 @@ members = [
     "bench-tps",
     "bloom",
     "bucket_map",
+    "bundle",
     "cargo-registry",
     "clap-utils",
     "clap-v3-utils",
@@ -45,6 +46,7 @@ members = [
     "gossip",
     "inline-spl",
     "install",
+    "jito-protos",
     "keygen",
     "ledger",
     "ledger-tool",
@@ -92,6 +94,7 @@ members = [
     "rpc-client-nonce-utils",
     "rpc-test",
     "runtime",
+    "runtime-plugin",
     "runtime-transaction",
     "sdk",
     "sdk/cargo-build-bpf",
@@ -111,6 +114,7 @@ members = [
     "svm",
     "test-validator",
     "thin-client",
+    "tip-distributor",
     "tokens",
     "tps-client",
     "tpu-client",
@@ -133,7 +137,12 @@ members = [
     "zk-token-sdk",
 ]
 
-exclude = ["programs/sbf", "svm/tests/example-programs"]
+exclude = [
+    "anchor",
+    "jito-programs",
+    "programs/sbf",
+    "svm/tests/example-programs",
+]
 
 resolver = "2"
 
@@ -150,6 +159,7 @@ Inflector = "0.11.4"
 aquamarine = "0.3.3"
 aes-gcm-siv = "0.11.1"
 ahash = "0.8.10"
+anchor-lang = { path = "anchor/lang" }
 anyhow = "1.0.82"
 arbitrary = "1.3.2"
 ark-bn254 = "0.4.0"
@@ -238,6 +248,9 @@ jemallocator = { package = "tikv-jemallocator", version = "0.4.1", features = [
     "unprefixed_malloc_on_supported_platforms",
 ] }
 js-sys = "0.3.69"
+jito-protos = { path = "jito-protos", version = "=2.0.10" }
+jito-tip-distribution = { path = "jito-programs/mev-programs/programs/tip-distribution", features = ["no-entrypoint"] }
+jito-tip-payment = { path = "jito-programs/mev-programs/programs/tip-payment", features = ["no-entrypoint"] }
 json5 = "0.4.1"
 jsonrpc-core = "18.0.0"
 jsonrpc-core-client = "18.0.0"
@@ -245,6 +258,7 @@ jsonrpc-derive = "18.0.0"
 jsonrpc-http-server = "18.0.0"
 jsonrpc-ipc-server = "18.0.0"
 jsonrpc-pubsub = "18.0.0"
+jsonrpc-server-utils = "18.0.0"
 lazy-lru = "0.1.2"
 lazy_static = "1.4.0"
 libc = "0.2.155"
@@ -330,6 +344,7 @@ solana-bench-tps = { path = "bench-tps", version = "=2.0.10" }
 solana-bloom = { path = "bloom", version = "=2.0.10" }
 solana-bpf-loader-program = { path = "programs/bpf_loader", version = "=2.0.10" }
 solana-bucket-map = { path = "bucket_map", version = "=2.0.10" }
+solana-bundle = { path = "bundle", version = "=2.0.10" }
 agave-cargo-registry = { path = "cargo-registry", version = "=2.0.10" }
 solana-clap-utils = { path = "clap-utils", version = "=2.0.10" }
 solana-clap-v3-utils = { path = "clap-v3-utils", version = "=2.0.10" }
@@ -384,6 +399,7 @@ solana-rpc-client = { path = "rpc-client", version = "=2.0.10", default-features
 solana-rpc-client-api = { path = "rpc-client-api", version = "=2.0.10" }
 solana-rpc-client-nonce-utils = { path = "rpc-client-nonce-utils", version = "=2.0.10" }
 solana-runtime = { path = "runtime", version = "=2.0.10" }
+solana-runtime-plugin = { path = "runtime-plugin", version = "=2.0.10" }
 solana-runtime-transaction = { path = "runtime-transaction", version = "=2.0.10" }
 solana-sdk = { path = "sdk", version = "=2.0.10" }
 solana-sdk-macro = { path = "sdk/macro", version = "=2.0.10" }
diff --git a/README.md b/README.md
index 0d855e8cc85c..4369c4bcb4d0 100644
--- a/README.md
+++ b/README.md
@@ -4,12 +4,16 @@
   </a>
 </p>
 
-[![Solana crate](https://img.shields.io/crates/v/solana-core.svg)](https://crates.io/crates/solana-core)
-[![Solana documentation](https://docs.rs/solana-core/badge.svg)](https://docs.rs/solana-core)
-[![Build status](https://badge.buildkite.com/8cc350de251d61483db98bdfc895b9ea0ac8ffa4a32ee850ed.svg?branch=master)](https://buildkite.com/solana-labs/solana/builds?branch=master)
-[![codecov](https://codecov.io/gh/solana-labs/solana/branch/master/graph/badge.svg)](https://codecov.io/gh/solana-labs/solana)
+[![Build status](https://badge.buildkite.com/3a7c88c0f777e1a0fddacc190823565271ae4c251ef78d83a8.svg)](https://buildkite.com/jito/jito-solana)
 
-# Building
+# About
+
+This repository contains Jito's fork of the Solana validator.
+
+We recommend checking out our [Gitbook](https://jito-foundation.gitbook.io/mev/jito-solana/building-the-software) for
+more detailed instructions on building and running Jito-Solana.
+
+---
 
 ## **1. Install rustc, cargo and rustfmt.**
 
@@ -25,21 +29,27 @@ When building the master branch, please make sure you are using the latest stabl
 $ rustup update
 ```
 
-When building a specific release branch, you should check the rust version in `ci/rust-version.sh` and if necessary, install that version by running:
+When building a specific release branch, you should check the rust version in `ci/rust-version.sh` and if necessary,
+install that version by running:
+
 ```bash
 $ rustup install VERSION
 ```
-Note that if this is not the latest rust version on your machine, cargo commands may require an [override](https://rust-lang.github.io/rustup/overrides.html) in order to use the correct version.
+
+Note that if this is not the latest rust version on your machine, cargo commands may require
+an [override](https://rust-lang.github.io/rustup/overrides.html) in order to use the correct version.
 
 On Linux systems you may need to install libssl-dev, pkg-config, zlib1g-dev, protobuf etc.
 
 On Ubuntu:
+
 ```bash
 $ sudo apt-get update
 $ sudo apt-get install libssl-dev libudev-dev pkg-config zlib1g-dev llvm clang cmake make libprotobuf-dev protobuf-compiler
 ```
 
 On Fedora:
+
 ```bash
 $ sudo dnf install openssl-devel systemd-devel pkg-config zlib-devel llvm clang cmake make protobuf-devel protobuf-compiler perl-core
 ```
@@ -47,8 +57,8 @@ $ sudo dnf install openssl-devel systemd-devel pkg-config zlib-devel llvm clang
 ## **2. Download the source code.**
 
 ```bash
-$ git clone https://github.com/anza-xyz/agave.git
-$ cd agave
+$ git clone https://github.com/jito-foundation/jito-solana.git
+$ cd jito-solana
 ```
 
 ## **3. Build.**
@@ -72,7 +82,7 @@ Start your own testnet locally, instructions are in the [online docs](https://do
 ### Accessing the remote development cluster
 
 * `devnet` - stable public cluster for development accessible via
-devnet.solana.com. Runs 24/7. Learn more about the [public clusters](https://docs.solanalabs.com/clusters)
+  devnet.solana.com. Runs 24/7. Learn more about the [public clusters](https://docs.solanalabs.com/clusters)
 
 # Benchmarking
 
@@ -104,7 +114,7 @@ $ open target/cov/lcov-local/index.html
 
 Why coverage? While most see coverage as a code quality metric, we see it primarily as a developer
 productivity metric. When a developer makes a change to the codebase, presumably it's a *solution* to
-some problem.  Our unit-test suite is how we encode the set of *problems* the codebase solves. Running
+some problem. Our unit-test suite is how we encode the set of *problems* the codebase solves. Running
 the test suite should indicate that your change didn't *infringe* on anyone else's solutions. Adding a
 test *protects* your solution from future changes. Say you don't understand why a line of code exists,
 try deleting it and running the unit-tests. The nearest test failure should tell you what problem
@@ -113,3 +123,4 @@ problem is solved by this code?" On the other hand, if a test does fail and you
 better way to solve the same problem, a Pull Request with your solution would most certainly be
 welcome! Likewise, if rewriting a test can better communicate what code it's protecting, please
 send us that patch!
+
diff --git a/RELEASE.md b/RELEASE.md
index 14cc160ed8be..9038ca2e7992 100644
--- a/RELEASE.md
+++ b/RELEASE.md
@@ -17,9 +17,10 @@
 ```
 
 ### master branch
+
 All new development occurs on the `master` branch.
 
-Bug fixes that affect a `vX.Y` branch are first made on `master`.  This is to
+Bug fixes that affect a `vX.Y` branch are first made on `master`. This is to
 allow a fix some soak time on `master` before it is applied to one or more
 stabilization branches.
 
@@ -29,7 +30,7 @@ release blocker in a branch causes you to forget to propagate back to
 `master`!)"
 
 Once the bug fix lands on `master` it is cherry-picked into the `vX.Y` branch
-and potentially the `vX.Y-1` branch.  The exception to this rule is when a bug
+and potentially the `vX.Y-1` branch. The exception to this rule is when a bug
 fix for `vX.Y` doesn't apply to `master` or `vX.Y-1`.
 
 Immediately after a new stabilization branch is forged, the `Cargo.toml` minor
@@ -38,10 +39,12 @@ Incrementing the major version of the `master` branch is outside the scope of
 this document.
 
 ### v*X.Y* stabilization branches
+
 These are stabilization branches. They are created from the `master` branch approximately
 every 13 weeks.
 
 ### v*X.Y.Z* release tag
+
 The release tags are created as desired by the owner of the given stabilization
 branch, and cause that *X.Y.Z* release to be shipped to https://crates.io
 
@@ -50,11 +53,13 @@ patch version number (*Z*) of the stabilization branch is incremented by the
 release engineer.
 
 ## Channels
+
 Channels are used by end-users (humans and bots) to consume the branches
 described in the previous section, so they may automatically update to the most
 recent version matching their desired stability.
 
 There are three release channels that map to branches as follows:
+
 * edge - tracks the `master` branch, least stable.
 * beta - tracks the largest (and latest) `vX.Y` stabilization branch, more stable.
 * stable - tracks the second largest `vX.Y` stabilization branch, most stable.
@@ -62,13 +67,14 @@ There are three release channels that map to branches as follows:
 ## Steps to Create a Branch
 
 ### Create the new branch
+
 1. Check out the latest commit on `master` branch:
     ```
     git fetch --all
     git checkout upstream/master
     ```
-1. Determine the new branch name.  The name should be "v" + the first 2 version fields
-   from Cargo.toml.  For example, a Cargo.toml with version = "0.9.0" implies
+1. Determine the new branch name. The name should be "v" + the first 2 version fields
+   from Cargo.toml. For example, a Cargo.toml with version = "0.9.0" implies
    the next branch name is "v0.9".
 1. Create the new branch and push this branch to the `agave` repository:
     ```
@@ -80,7 +86,8 @@ Alternatively use the Github UI.
 
 ### Update master branch to the next release minor version
 
-1. After the new branch has been created and pushed, update the Cargo.toml files on **master** to the next semantic version (e.g. 0.9.0 -> 0.10.0) with:
+1. After the new branch has been created and pushed, update the Cargo.toml files on **master** to the next semantic
+   version (e.g. 0.9.0 -> 0.10.0) with:
      ```
      $ scripts/increment-cargo-version.sh minor
      ```
@@ -91,60 +98,82 @@ Alternatively use the Github UI.
     git commit -m 'Bump version to X.Y+1.0'
     git push -u origin version_update
     ```
-1. Confirm that your freshly cut release branch is shown as `BETA_CHANNEL` and the previous release branch as `STABLE_CHANNEL`:
+1. Confirm that your freshly cut release branch is shown as `BETA_CHANNEL` and the previous release branch
+   as `STABLE_CHANNEL`:
     ```
     ci/channel-info.sh
     ```
 
 ### Miscellaneous Clean up
 
-1. Pin the spl-token-cli version in the newly promoted stable branch by setting `splTokenCliVersion` in scripts/spl-token-cli-version.sh to the latest release that depends on the stable branch (usually this will be the latest spl-token-cli release).
-1. Update [mergify.yml](https://github.com/anza-xyz/agave/blob/master/.mergify.yml) to add backport actions for the new branch and remove actions for the obsolete branch.
-1. Adjust the [Github backport labels](https://github.com/anza-xyz/agave/labels) to add the new branch label and remove the label for the obsolete branch.
+1. Pin the spl-token-cli version in the newly promoted stable branch by setting `splTokenCliVersion` in
+   scripts/spl-token-cli-version.sh to the latest release that depends on the stable branch (usually this will be the
+   latest spl-token-cli release).
+1. Update [mergify.yml](https://github.com/jito-foundation/jito-solana/blob/master/.mergify.yml) to add backport actions
+   for the new branch and remove actions for the obsolete branch.
+1. Adjust the [Github backport labels](https://github.com/jito-foundation/jito-solana/labels) to add the new branch
+   label and remove the label for the obsolete branch.
 1. Announce on Discord #development that the release branch exists so people know to use the new backport labels.
 
 ## Steps to Create a Release
 
 ### Create the Release Tag on GitHub
 
-1. Go to [GitHub Releases](https://github.com/anza-xyz/agave/releases) for tagging a release.
-1. Click "Draft new release".  The release tag must exactly match the `version`
+1. Go to [GitHub Releases](https://github.com/jito-foundation/jito-solana/releases) for tagging a release.
+1. Click "Draft new release". The release tag must exactly match the `version`
    field in `/Cargo.toml` prefixed by `v`.
-   1.  If the Cargo.toml version field is **0.12.3**, then the release tag must be **v0.12.3**
+    1. If the Cargo.toml version field is **0.12.3**, then the release tag must be **v0.12.3**
 1. Make sure the Target Branch field matches the branch you want to make a release on.
-   1.  If you want to release v0.12.0, the target branch must be v0.12
+    1. If you want to release v0.12.0, the target branch must be v0.12
 1. Fill the release notes.
-   1.  If this is the first release on the branch (e.g. v0.13.**0**), paste in [this
-   template](https://raw.githubusercontent.com/anza-xyz/agave/master/.github/RELEASE_TEMPLATE.md).  Engineering Lead can provide summary contents for release notes if needed.
-   1. If this is a patch release, review all the commits since the previous release on this branch and add details as needed.
+    1. If this is the first release on the branch (e.g. v0.13.**0**), paste in [this
+       template](https://raw.githubusercontent.com/jito-foundation/jito-solana/master/.github/RELEASE_TEMPLATE.md).
+       Engineering Lead can provide summary contents for release notes if needed.
+    1. If this is a patch release, review all the commits since the previous release on this branch and add details as
+       needed.
 1. Click "Save Draft", then confirm the release notes look good and the tag name and branch are correct.
 1. Ensure all desired commits (usually backports) are landed on the branch by now.
-1. Ensure the release is marked **"This is a pre-release"**.  This flag will need to be removed manually after confirming the Linux binary artifacts appear at a later step.
+1. Ensure the release is marked **"This is a pre-release"**. This flag will need to be removed manually after confirming
+   the Linux binary artifacts appear at a later step.
 1. Go back into edit the release and click "Publish release" while being marked as a pre-release.
 1. Confirm there is new git tag with intended version number at the intended revision after running `git fetch` locally.
 
-
 ### Update release branch with the next patch version
 
-[This action](https://github.com/anza-xyz/agave/blob/master/.github/workflows/increment-cargo-version-on-release.yml) ensures that publishing a release will trigger the creation of a PR to update the Cargo.toml files on **release branch** to the next semantic version (e.g. 0.9.0 -> 0.9.1). Ensure that the created PR makes it through CI and gets submitted.
+[This action](https://github.com/jito-foundation/jito-solana/blob/master/.github/workflows/increment-cargo-version-on-release.yml)
+ensures that publishing a release will trigger the creation of a PR to update the Cargo.toml files on **release branch**
+to the next semantic version (e.g. 0.9.0 -> 0.9.1). Ensure that the created PR makes it through CI and gets submitted.
 
-Note: As of 2024-03-26 the above action is failing so version bumps are done manually. The version bump script is incorrectly updating hashbrown and proc-macro2 versions which should be reverted.
+Note: As of 2024-03-26 the above action is failing so version bumps are done manually. The version bump script is
+incorrectly updating hashbrown and proc-macro2 versions which should be reverted.
 
 ### Prepare for the next release
-1.  Go to [GitHub Releases](https://github.com/anza-xyz/agave/releases) and create a new draft release for `X.Y.Z+1` with empty release notes.  This allows people to incrementally add new release notes until it's time for the next release
+
+1. Go to [GitHub Releases](https://github.com/jito-foundation/jito-solana/releases) and create a new draft release
+   for `X.Y.Z+1` with empty release notes. This allows people to incrementally add new release notes until it's time for
+   the next release
     1. Also, point the branch field to the same branch and mark the release as **"This is a pre-release"**.
 
 ### Verify release automation success
-Go to [Agave Releases](https://github.com/anza-xyz/agave/releases) and click on the latest release that you just published.
-Verify that all of the build artifacts are present (15 assets), then uncheck **"This is a pre-release"** for the release.
+
+Go to [Agave Releases](https://github.com/jito-foundation/jito-solana/releases) and click on the latest release that you
+just published.
+Verify that all of the build artifacts are present (15 assets), then uncheck **"This is a pre-release"** for the
+release.
 
 Build artifacts can take up to 60 minutes after creating the tag before
-appearing.  To check for progress:
-* The `agave-secondary` Buildkite pipeline handles creating the Linux and macOS release artifacts and updated crates.  Look for a job under the tag name of the release: https://buildkite.com/anza-xyz/agave-secondary.
-* The Windows release artifacts are produced by GitHub Actions.  Look for a job under the tag name of the release: https://github.com/anza-xyz/agave/actions.
+appearing. To check for progress:
 
-[Crates.io agave-validator](https://crates.io/crates/agave-validator) should have an updated agave-validator version.  This can take 2-3 hours, and sometimes fails in the `agave-secondary` job.
+* The `agave-secondary` Buildkite pipeline handles creating the Linux and macOS release artifacts and updated crates.
+  Look for a job under the tag name of the release: https://buildkite.com/jito-foundation/jito-solana-secondary.
+* The Windows release artifacts are produced by GitHub Actions. Look for a job under the tag name of the
+  release: https://github.com/jito-foundation/jito-solana/actions.
+
+[Crates.io agave-validator](https://crates.io/crates/agave-validator) should have an updated agave-validator version.
+This can take 2-3 hours, and sometimes fails in the `agave-secondary` job.
 If this happens and the error is non-fatal, click "Retry" on the "publish crate" job
 
 ### Update software on testnet.solana.com
-See the documentation at https://github.com/solana-labs/cluster-ops/. devnet.solana.com and mainnet-beta.solana.com run stable releases that have been tested on testnet. Do not update devnet or mainnet-beta with a beta release.
+
+See the documentation at https://github.com/solana-labs/cluster-ops/. devnet.solana.com and mainnet-beta.solana.com run
+stable releases that have been tested on testnet. Do not update devnet or mainnet-beta with a beta release.
diff --git a/accounts-db/src/accounts.rs b/accounts-db/src/accounts.rs
index 1f87be1ae86e..9d4f2f946466 100644
--- a/accounts-db/src/accounts.rs
+++ b/accounts-db/src/accounts.rs
@@ -554,19 +554,32 @@ impl Accounts {
     }
 
     fn lock_account(
-        &self,
         account_locks: &mut AccountLocks,
         writable_keys: Vec<&Pubkey>,
         readonly_keys: Vec<&Pubkey>,
+        additional_read_locks: Option<&HashSet<Pubkey>>,
+        additional_write_locks: Option<&HashSet<Pubkey>>,
     ) -> Result<()> {
         for k in writable_keys.iter() {
-            if account_locks.is_locked_write(k) || account_locks.is_locked_readonly(k) {
+            if account_locks.is_locked_write(k)
+                || account_locks.is_locked_readonly(k)
+                || additional_write_locks
+                    .map(|additional_write_locks| additional_write_locks.contains(k))
+                    .unwrap_or(false)
+                || additional_read_locks
+                    .map(|additional_read_locks| additional_read_locks.contains(k))
+                    .unwrap_or(false)
+            {
                 debug!("Writable account in use: {:?}", k);
                 return Err(TransactionError::AccountInUse);
             }
         }
         for k in readonly_keys.iter() {
-            if account_locks.is_locked_write(k) {
+            if account_locks.is_locked_write(k)
+                || additional_write_locks
+                    .map(|additional_write_locks| additional_write_locks.contains(k))
+                    .unwrap_or(false)
+            {
                 debug!("Read-only account in use: {:?}", k);
                 return Err(TransactionError::AccountInUse);
             }
@@ -610,7 +623,7 @@ impl Accounts {
         let tx_account_locks_results: Vec<Result<_>> = txs
             .map(|tx| tx.get_account_locks(tx_account_lock_limit))
             .collect();
-        self.lock_accounts_inner(tx_account_locks_results)
+        self.lock_accounts_inner(tx_account_locks_results, None, None)
     }
 
     #[must_use]
@@ -619,6 +632,8 @@ impl Accounts {
         txs: impl Iterator<Item = &'a SanitizedTransaction>,
         results: impl Iterator<Item = Result<()>>,
         tx_account_lock_limit: usize,
+        additional_read_locks: Option<&HashSet<Pubkey>>,
+        additional_write_locks: Option<&HashSet<Pubkey>>,
     ) -> Vec<Result<()>> {
         let tx_account_locks_results: Vec<Result<_>> = txs
             .zip(results)
@@ -627,22 +642,30 @@ impl Accounts {
                 Err(err) => Err(err),
             })
             .collect();
-        self.lock_accounts_inner(tx_account_locks_results)
+        self.lock_accounts_inner(
+            tx_account_locks_results,
+            additional_read_locks,
+            additional_write_locks,
+        )
     }
 
     #[must_use]
     fn lock_accounts_inner(
         &self,
         tx_account_locks_results: Vec<Result<TransactionAccountLocks>>,
+        additional_read_locks: Option<&HashSet<Pubkey>>,
+        additional_write_locks: Option<&HashSet<Pubkey>>,
     ) -> Vec<Result<()>> {
         let account_locks = &mut self.account_locks.lock().unwrap();
         tx_account_locks_results
             .into_iter()
             .map(|tx_account_locks_result| match tx_account_locks_result {
-                Ok(tx_account_locks) => self.lock_account(
+                Ok(tx_account_locks) => Self::lock_account(
                     account_locks,
                     tx_account_locks.writable,
                     tx_account_locks.readonly,
+                    additional_read_locks,
+                    additional_write_locks,
                 ),
                 Err(err) => Err(err),
             })
@@ -681,8 +704,13 @@ impl Accounts {
         durable_nonce: &DurableNonce,
         lamports_per_signature: u64,
     ) {
-        let (accounts_to_store, transactions) =
-            self.collect_accounts_to_store(txs, res, loaded, durable_nonce, lamports_per_signature);
+        let (accounts_to_store, transactions) = Self::collect_accounts_to_store(
+            txs,
+            res,
+            loaded,
+            durable_nonce,
+            lamports_per_signature,
+        );
         self.accounts_db
             .store_cached_inline_update_index((slot, &accounts_to_store[..]), Some(&transactions));
     }
@@ -697,8 +725,7 @@ impl Accounts {
     }
 
     #[allow(clippy::too_many_arguments)]
-    fn collect_accounts_to_store<'a>(
-        &self,
+    pub fn collect_accounts_to_store<'a>(
         txs: &'a [SanitizedTransaction],
         execution_results: &'a [TransactionExecutionResult],
         load_results: &'a mut [TransactionLoadResult],
@@ -775,6 +802,55 @@ impl Accounts {
         }
         (accounts, transactions)
     }
+
+    pub fn lock_accounts_sequential_with_results<'a>(
+        &self,
+        txs: impl Iterator<Item = &'a SanitizedTransaction>,
+        tx_account_lock_limit: usize,
+    ) -> Vec<Result<()>> {
+        let tx_account_locks_results: Vec<Result<_>> = txs
+            .map(|tx| tx.get_account_locks(tx_account_lock_limit))
+            .collect();
+        self.lock_accounts_sequential_inner(tx_account_locks_results)
+    }
+
+    #[must_use]
+    fn lock_accounts_sequential_inner(
+        &self,
+        tx_account_locks_results: Vec<Result<TransactionAccountLocks>>,
+    ) -> Vec<Result<()>> {
+        let mut l_account_locks = self.account_locks.lock().unwrap();
+        Self::lock_accounts_sequential(&mut l_account_locks, tx_account_locks_results)
+    }
+
+    pub fn lock_accounts_sequential(
+        account_locks: &mut AccountLocks,
+        tx_account_locks_results: Vec<Result<TransactionAccountLocks>>,
+    ) -> Vec<Result<()>> {
+        let mut account_in_use_set = false;
+        tx_account_locks_results
+            .into_iter()
+            .map(|tx_account_locks_result| match tx_account_locks_result {
+                Ok(tx_account_locks) => match account_in_use_set {
+                    true => Err(TransactionError::AccountInUse),
+                    false => {
+                        let locked = Self::lock_account(
+                            account_locks,
+                            tx_account_locks.writable,
+                            tx_account_locks.readonly,
+                            None,
+                            None,
+                        );
+                        if matches!(locked, Err(TransactionError::AccountInUse)) {
+                            account_in_use_set = true;
+                        }
+                        locked
+                    }
+                },
+                Err(err) => Err(err),
+            })
+            .collect()
+    }
 }
 
 fn post_process_failed_tx(
@@ -1476,6 +1552,8 @@ mod tests {
             txs.iter(),
             qos_results.into_iter(),
             MAX_TX_ACCOUNT_LOCKS,
+            None,
+            None,
         );
 
         assert_eq!(
@@ -1597,7 +1675,7 @@ mod tests {
         }
         let txs = vec![tx0.clone(), tx1.clone()];
         let execution_results = vec![new_execution_result(Ok(())); 2];
-        let (collected_accounts, transactions) = accounts.collect_accounts_to_store(
+        let (collected_accounts, transactions) = Accounts::collect_accounts_to_store(
             &txs,
             &execution_results,
             loaded.as_mut_slice(),
@@ -1841,13 +1919,11 @@ mod tests {
         let mut loaded = vec![loaded];
 
         let durable_nonce = DurableNonce::from_blockhash(&Hash::new_unique());
-        let accounts_db = AccountsDb::new_single_for_tests();
-        let accounts = Accounts::new(Arc::new(accounts_db));
         let txs = vec![tx];
         let execution_results = vec![new_execution_result(Err(
             TransactionError::InstructionError(1, InstructionError::InvalidArgument),
         ))];
-        let (collected_accounts, _) = accounts.collect_accounts_to_store(
+        let (collected_accounts, _) = Accounts::collect_accounts_to_store(
             &txs,
             &execution_results,
             loaded.as_mut_slice(),
@@ -1941,13 +2017,11 @@ mod tests {
         let mut loaded = vec![loaded];
 
         let durable_nonce = DurableNonce::from_blockhash(&Hash::new_unique());
-        let accounts_db = AccountsDb::new_single_for_tests();
-        let accounts = Accounts::new(Arc::new(accounts_db));
         let txs = vec![tx];
         let execution_results = vec![new_execution_result(Err(
             TransactionError::InstructionError(1, InstructionError::InvalidArgument),
         ))];
-        let (collected_accounts, _) = accounts.collect_accounts_to_store(
+        let (collected_accounts, _) = Accounts::collect_accounts_to_store(
             &txs,
             &execution_results,
             loaded.as_mut_slice(),
diff --git a/anchor b/anchor
new file mode 160000
index 000000000000..4f52f41cbeaf
--- /dev/null
+++ b/anchor
@@ -0,0 +1 @@
+Subproject commit 4f52f41cbeafb77d85c7b712516dfbeb5b86dd5f
diff --git a/banking-bench/src/main.rs b/banking-bench/src/main.rs
index 7d194d044aa8..6e544039d332 100644
--- a/banking-bench/src/main.rs
+++ b/banking-bench/src/main.rs
@@ -9,6 +9,7 @@ use {
     solana_core::{
         banking_stage::BankingStage,
         banking_trace::{BankingPacketBatch, BankingTracer, BANKING_TRACE_DIR_DEFAULT_BYTE_LIMIT},
+        bundle_stage::bundle_account_locker::BundleAccountLocker,
         validator::BlockProductionMethod,
     },
     solana_gossip::cluster_info::{ClusterInfo, Node},
@@ -37,6 +38,7 @@ use {
     solana_streamer::socket::SocketAddrSpace,
     solana_tpu_client::tpu_client::DEFAULT_TPU_CONNECTION_POOL_SIZE,
     std::{
+        collections::HashSet,
         sync::{atomic::Ordering, Arc, RwLock},
         thread::sleep,
         time::{Duration, Instant},
@@ -58,9 +60,15 @@ fn check_txs(
     let now = Instant::now();
     let mut no_bank = false;
     loop {
-        if let Ok((_bank, (entry, _tick_height))) = receiver.recv_timeout(Duration::from_millis(10))
+        if let Ok(WorkingBankEntry {
+            bank: _,
+            entries_ticks,
+        }) = receiver.recv_timeout(Duration::from_millis(10))
         {
-            total += entry.transactions.len();
+            total += entries_ticks
+                .iter()
+                .map(|e| e.0.transactions.len())
+                .sum::<usize>();
         }
         if total >= ref_tx_count {
             break;
@@ -475,6 +483,8 @@ fn main() {
         bank_forks.clone(),
         &Arc::new(PrioritizationFeeCache::new(0u64)),
         false,
+        HashSet::default(),
+        BundleAccountLocker::default(),
     );
 
     // This is so that the signal_receiver does not go out of scope after the closure.
diff --git a/banks-server/Cargo.toml b/banks-server/Cargo.toml
index 6cf5f77f9254..63f6d12b87bd 100644
--- a/banks-server/Cargo.toml
+++ b/banks-server/Cargo.toml
@@ -15,6 +15,7 @@ crossbeam-channel = { workspace = true }
 futures = { workspace = true }
 solana-banks-interface = { workspace = true }
 solana-client = { workspace = true }
+solana-gossip = { workspace = true }
 solana-runtime = { workspace = true }
 solana-sdk = { workspace = true }
 solana-send-transaction-service = { workspace = true }
diff --git a/banks-server/src/banks_server.rs b/banks-server/src/banks_server.rs
index c08a41c5d91a..3836db9337d7 100644
--- a/banks-server/src/banks_server.rs
+++ b/banks-server/src/banks_server.rs
@@ -8,6 +8,7 @@ use {
         TransactionSimulationDetails, TransactionStatus,
     },
     solana_client::connection_cache::ConnectionCache,
+    solana_gossip::cluster_info::ClusterInfo,
     solana_runtime::{
         bank::{Bank, TransactionSimulationResult},
         bank_forks::BankForks,
@@ -425,7 +426,7 @@ pub async fn start_local_server(
 
 pub async fn start_tcp_server(
     listen_addr: SocketAddr,
-    tpu_addr: SocketAddr,
+    cluster_info: Arc<ClusterInfo>,
     bank_forks: Arc<RwLock<BankForks>>,
     block_commitment_cache: Arc<RwLock<BlockCommitmentCache>>,
     connection_cache: Arc<ConnectionCache>,
@@ -450,7 +451,7 @@ pub async fn start_tcp_server(
             let (sender, receiver) = unbounded();
 
             SendTransactionService::new::<NullTpuInfo>(
-                tpu_addr,
+                cluster_info.clone(),
                 &bank_forks,
                 None,
                 receiver,
diff --git a/bootstrap b/bootstrap
new file mode 100755
index 000000000000..d9b1eed6f439
--- /dev/null
+++ b/bootstrap
@@ -0,0 +1,26 @@
+#!/usr/bin/env bash
+set -eu
+
+BANK_HASH=$(cargo run --release --bin solana-ledger-tool -- -l config/bootstrap-validator bank-hash)
+
+# increase max file handle limit
+ulimit -Hn 1000000
+
+# if above fails, run:
+# sudo bash -c 'echo "*               hard    nofile          1000000" >> /etc/security/limits.conf'
+
+# NOTE: make sure tip-payment and tip-distribution program are deployed using the correct pubkeys
+RUST_LOG=INFO,solana_core::bundle_stage=DEBUG \
+  NDEBUG=1 ./multinode-demo/bootstrap-validator.sh \
+  --wait-for-supermajority 0 \
+  --expected-bank-hash "$BANK_HASH" \
+  --block-engine-url http://127.0.0.1 \
+  --relayer-url http://127.0.0.1:11226 \
+  --rpc-pubsub-enable-block-subscription \
+  --enable-rpc-transaction-history \
+  --tip-payment-program-pubkey T1pyyaTNZsKv2WcRAB8oVnk93mLJw2XzjtVYqCsaHqt \
+  --tip-distribution-program-pubkey 4R3gSG8BpU4t19KYj8CfnbtRpnT8gtk4dvTHxVRwc2r7 \
+  --commission-bps 0 \
+  --shred-receiver-address 127.0.0.1:1002 \
+  --trust-relayer-packets \
+  --trust-block-engine-packets
diff --git a/bundle/Cargo.toml b/bundle/Cargo.toml
new file mode 100644
index 000000000000..8ceaae04793f
--- /dev/null
+++ b/bundle/Cargo.toml
@@ -0,0 +1,37 @@
+[package]
+name = "solana-bundle"
+description = "Library related to handling bundles"
+documentation = "https://docs.rs/solana-bundle"
+readme = "../README.md"
+version = { workspace = true }
+authors = { workspace = true }
+repository = { workspace = true }
+homepage = { workspace = true }
+license = { workspace = true }
+edition = { workspace = true }
+
+[dependencies]
+anchor-lang = { workspace = true }
+itertools = { workspace = true }
+log = { workspace = true }
+serde = { workspace = true }
+solana-accounts-db = { workspace = true }
+solana-ledger = { workspace = true }
+solana-logger = { workspace = true }
+solana-measure = { workspace = true }
+solana-poh = { workspace = true }
+solana-program-runtime = { workspace = true }
+solana-runtime = { workspace = true }
+solana-sdk = { workspace = true }
+solana-svm = { workspace = true }
+solana-transaction-status = { workspace = true }
+thiserror = { workspace = true }
+
+[dev-dependencies]
+assert_matches = { workspace = true }
+solana-logger = { workspace = true }
+solana-runtime = { workspace = true, features = ["dev-context-only-utils"] }
+
+[lib]
+crate-type = ["lib"]
+name = "solana_bundle"
diff --git a/bundle/src/bundle_execution.rs b/bundle/src/bundle_execution.rs
new file mode 100644
index 000000000000..6e396c851379
--- /dev/null
+++ b/bundle/src/bundle_execution.rs
@@ -0,0 +1,1216 @@
+use {
+    itertools::izip,
+    log::*,
+    solana_accounts_db::accounts::Accounts,
+    solana_ledger::token_balances::collect_token_balances,
+    solana_measure::{measure::Measure, measure_us},
+    solana_program_runtime::timings::ExecuteTimings,
+    solana_runtime::{
+        bank::{Bank, LoadAndExecuteTransactionsOutput, TransactionBalances},
+        transaction_batch::TransactionBatch,
+    },
+    solana_sdk::{
+        account::AccountSharedData,
+        bundle::SanitizedBundle,
+        nonce::state::DurableNonce,
+        pubkey::Pubkey,
+        saturating_add_assign,
+        signature::Signature,
+        transaction::{SanitizedTransaction, TransactionError, VersionedTransaction},
+    },
+    solana_svm::{
+        account_loader::TransactionLoadResult,
+        account_overrides::AccountOverrides,
+        transaction_processing_callback::TransactionProcessingCallback,
+        transaction_processor::{ExecutionRecordingConfig, TransactionProcessingConfig},
+        transaction_results::TransactionExecutionResult,
+    },
+    solana_transaction_status::{token_balances::TransactionTokenBalances, PreBalanceInfo},
+    std::{
+        cmp::{max, min},
+        time::{Duration, Instant},
+    },
+    thiserror::Error,
+};
+
+#[derive(Clone, Default)]
+pub struct BundleExecutionMetrics {
+    pub num_retries: u64,
+    pub collect_balances_us: u64,
+    pub load_execute_us: u64,
+    pub collect_pre_post_accounts_us: u64,
+    pub cache_accounts_us: u64,
+    pub execute_timings: ExecuteTimings,
+}
+
+/// Contains the results from executing each TransactionBatch with a final result associated with it
+/// Note that if !result.is_ok(), bundle_transaction_results will not contain the output for every transaction.
+pub struct LoadAndExecuteBundleOutput<'a> {
+    bundle_transaction_results: Vec<BundleTransactionsOutput<'a>>,
+    result: LoadAndExecuteBundleResult<()>,
+    metrics: BundleExecutionMetrics,
+}
+
+impl<'a> LoadAndExecuteBundleOutput<'a> {
+    pub fn executed_ok(&self) -> bool {
+        self.result.is_ok()
+    }
+
+    pub fn result(&self) -> &LoadAndExecuteBundleResult<()> {
+        &self.result
+    }
+
+    pub fn bundle_transaction_results_mut(&mut self) -> &'a mut [BundleTransactionsOutput] {
+        &mut self.bundle_transaction_results
+    }
+
+    pub fn bundle_transaction_results(&self) -> &'a [BundleTransactionsOutput] {
+        &self.bundle_transaction_results
+    }
+
+    pub fn executed_transaction_batches(&self) -> Vec<Vec<VersionedTransaction>> {
+        self.bundle_transaction_results
+            .iter()
+            .map(|br| br.executed_versioned_transactions())
+            .collect()
+    }
+
+    pub fn metrics(&self) -> BundleExecutionMetrics {
+        self.metrics.clone()
+    }
+}
+
+#[derive(Clone, Debug, Error)]
+pub enum LoadAndExecuteBundleError {
+    #[error("Bundle execution timed out")]
+    ProcessingTimeExceeded(Duration),
+
+    #[error(
+        "A transaction in the bundle encountered a lock error: [signature={:?}, transaction_error={:?}]",
+        signature,
+        transaction_error
+    )]
+    LockError {
+        signature: Signature,
+        transaction_error: TransactionError,
+    },
+
+    #[error(
+        "A transaction in the bundle failed to execute: [signature={:?}, execution_result={:?}",
+        signature,
+        execution_result
+    )]
+    TransactionError {
+        signature: Signature,
+        // Box reduces the size between variants in the Error
+        execution_result: Box<TransactionExecutionResult>,
+    },
+
+    #[error("Invalid pre or post accounts")]
+    InvalidPreOrPostAccounts,
+}
+
+pub struct BundleTransactionsOutput<'a> {
+    transactions: &'a [SanitizedTransaction],
+    load_and_execute_transactions_output: LoadAndExecuteTransactionsOutput,
+    pre_balance_info: PreBalanceInfo,
+    post_balance_info: (TransactionBalances, TransactionTokenBalances),
+    // the length of the outer vector should be the same as transactions.len()
+    // for indices that didn't get executed, expect a None.
+    pre_tx_execution_accounts: Vec<Option<Vec<(Pubkey, AccountSharedData)>>>,
+    post_tx_execution_accounts: Vec<Option<Vec<(Pubkey, AccountSharedData)>>>,
+}
+
+impl<'a> BundleTransactionsOutput<'a> {
+    pub fn executed_versioned_transactions(&self) -> Vec<VersionedTransaction> {
+        self.transactions
+            .iter()
+            .zip(
+                self.load_and_execute_transactions_output
+                    .execution_results
+                    .iter(),
+            )
+            .filter_map(|(tx, exec_result)| {
+                exec_result
+                    .was_executed()
+                    .then_some(tx.to_versioned_transaction())
+            })
+            .collect()
+    }
+
+    pub fn executed_transactions(&self) -> Vec<&'a SanitizedTransaction> {
+        self.transactions
+            .iter()
+            .zip(
+                self.load_and_execute_transactions_output
+                    .execution_results
+                    .iter(),
+            )
+            .filter_map(|(tx, exec_result)| exec_result.was_executed().then_some(tx))
+            .collect()
+    }
+
+    pub fn load_and_execute_transactions_output(&self) -> &LoadAndExecuteTransactionsOutput {
+        &self.load_and_execute_transactions_output
+    }
+
+    pub fn transactions(&self) -> &[SanitizedTransaction] {
+        self.transactions
+    }
+
+    pub fn loaded_transactions_mut(&mut self) -> &mut [TransactionLoadResult] {
+        &mut self
+            .load_and_execute_transactions_output
+            .loaded_transactions
+    }
+
+    pub fn execution_results(&self) -> &[TransactionExecutionResult] {
+        &self.load_and_execute_transactions_output.execution_results
+    }
+
+    pub fn pre_balance_info(&mut self) -> &mut PreBalanceInfo {
+        &mut self.pre_balance_info
+    }
+
+    pub fn post_balance_info(&self) -> &(TransactionBalances, TransactionTokenBalances) {
+        &self.post_balance_info
+    }
+
+    pub fn pre_tx_execution_accounts(&self) -> &Vec<Option<Vec<(Pubkey, AccountSharedData)>>> {
+        &self.pre_tx_execution_accounts
+    }
+
+    pub fn post_tx_execution_accounts(&self) -> &Vec<Option<Vec<(Pubkey, AccountSharedData)>>> {
+        &self.post_tx_execution_accounts
+    }
+}
+
+pub type LoadAndExecuteBundleResult<T> = Result<T, LoadAndExecuteBundleError>;
+
+/// Return an Error if a transaction was executed and reverted
+/// NOTE: `execution_results` are zipped with `sanitized_txs` so it's expected a sanitized tx at
+/// position i has a corresponding execution result at position i within the `execution_results`
+/// slice
+pub fn check_bundle_execution_results<'a>(
+    execution_results: &'a [TransactionExecutionResult],
+    sanitized_txs: &'a [SanitizedTransaction],
+) -> Result<(), (&'a SanitizedTransaction, &'a TransactionExecutionResult)> {
+    for (exec_results, sanitized_tx) in execution_results.iter().zip(sanitized_txs) {
+        match exec_results {
+            TransactionExecutionResult::Executed { details, .. } => {
+                if details.status.is_err() {
+                    return Err((sanitized_tx, exec_results));
+                }
+            }
+            TransactionExecutionResult::NotExecuted(e) => {
+                if !matches!(e, TransactionError::AccountInUse) {
+                    return Err((sanitized_tx, exec_results));
+                }
+            }
+        }
+    }
+    Ok(())
+}
+
+/// Executing a bundle is somewhat complicated compared to executing single transactions. In order to
+/// avoid duplicate logic for execution and simulation, this function can be leveraged.
+///
+/// Assumptions for the caller:
+/// - all transactions were signed properly
+/// - user has deduplicated transactions inside the bundle
+///
+/// TODO (LB):
+/// - given a bundle with 3 transactions that write lock the following accounts: [A, B, C], on failure of B
+///   we should add in the BundleTransactionsOutput of A and C and return the error for B.
+#[allow(clippy::too_many_arguments)]
+pub fn load_and_execute_bundle<'a>(
+    bank: &Bank,
+    bundle: &'a SanitizedBundle,
+    // Max blockhash age
+    max_age: usize,
+    // Upper bound on execution time for a bundle
+    max_processing_time: &Duration,
+    transaction_status_sender_enabled: bool,
+    log_messages_bytes_limit: &Option<usize>,
+    // simulation will not use the Bank's account locks when building the TransactionBatch
+    // if simulating on an unfrozen bank, this is helpful to avoid stalling replay and use whatever
+    // state the accounts are in at the current time
+    is_simulation: bool,
+    account_overrides: Option<&mut AccountOverrides>,
+    // these must be the same length as the bundle's transactions
+    // allows one to read account state before and after execution of each transaction in the bundle
+    // will use AccountsOverride + Bank
+    pre_execution_accounts: &[Option<Vec<Pubkey>>],
+    post_execution_accounts: &[Option<Vec<Pubkey>>],
+) -> LoadAndExecuteBundleOutput<'a> {
+    if pre_execution_accounts.len() != post_execution_accounts.len()
+        || post_execution_accounts.len() != bundle.transactions.len()
+    {
+        return LoadAndExecuteBundleOutput {
+            bundle_transaction_results: vec![],
+            result: Err(LoadAndExecuteBundleError::InvalidPreOrPostAccounts),
+            metrics: BundleExecutionMetrics::default(),
+        };
+    }
+
+    let mut binding = AccountOverrides::default();
+    let account_overrides = account_overrides.unwrap_or(&mut binding);
+    if is_simulation {
+        bundle
+            .transactions
+            .iter()
+            .map(|tx| tx.message().account_keys())
+            .for_each(|account_keys| {
+                account_overrides.upsert_account_overrides(
+                    bank.get_account_overrides_for_simulation(&account_keys),
+                );
+
+                // An unfrozen bank's state is always changing.
+                // By taking a snapshot of the accounts we're mocking out grabbing their locks.
+                // **Note** this does not prevent race conditions, just mocks preventing them.
+                if !bank.is_frozen() {
+                    for pk in account_keys.iter() {
+                        // Save on a disk read.
+                        if account_overrides.get(pk).is_none() {
+                            account_overrides.set_account(pk, bank.get_account_shared_data(pk));
+                        }
+                    }
+                }
+            });
+    }
+
+    let mut chunk_start = 0;
+    let start_time = Instant::now();
+
+    let mut bundle_transaction_results = vec![];
+    let mut metrics = BundleExecutionMetrics::default();
+
+    while chunk_start != bundle.transactions.len() {
+        if start_time.elapsed() > *max_processing_time {
+            trace!("bundle: {} took too long to execute", bundle.bundle_id);
+            return LoadAndExecuteBundleOutput {
+                bundle_transaction_results,
+                metrics,
+                result: Err(LoadAndExecuteBundleError::ProcessingTimeExceeded(
+                    start_time.elapsed(),
+                )),
+            };
+        }
+
+        let chunk_end = min(bundle.transactions.len(), chunk_start.saturating_add(128));
+        let chunk = &bundle.transactions[chunk_start..chunk_end];
+
+        // Note: these batches are dropped after execution and before record/commit, which is atypical
+        // compared to BankingStage which holds account locks until record + commit to avoid race conditions with
+        // other BankingStage threads. However, the caller of this method, BundleConsumer, will use BundleAccountLocks
+        // to hold RW locks across all transactions in a bundle until its processed.
+        let batch = if is_simulation {
+            bank.prepare_sequential_sanitized_batch_with_results_for_simulation(chunk)
+        } else {
+            bank.prepare_sequential_sanitized_batch_with_results(chunk)
+        };
+
+        debug!(
+            "bundle: {} batch num locks ok: {}",
+            bundle.bundle_id,
+            batch.lock_results().iter().filter(|lr| lr.is_ok()).count()
+        );
+
+        // Ensures that bundle lock results only return either:
+        // Ok(()) | Err(TransactionError::AccountInUse)
+        // If the error isn't one of those, then error out
+        if let Some((transaction, lock_failure)) = batch.check_bundle_lock_results() {
+            debug!(
+                "bundle: {} lock error; signature: {} error: {}",
+                bundle.bundle_id,
+                transaction.signature(),
+                lock_failure
+            );
+            return LoadAndExecuteBundleOutput {
+                bundle_transaction_results,
+                metrics,
+                result: Err(LoadAndExecuteBundleError::LockError {
+                    signature: *transaction.signature(),
+                    transaction_error: lock_failure.clone(),
+                }),
+            };
+        }
+
+        let mut pre_balance_info = PreBalanceInfo::default();
+        let (_, collect_balances_us) = measure_us!({
+            if transaction_status_sender_enabled {
+                pre_balance_info.native =
+                    bank.collect_balances_with_cache(&batch, Some(account_overrides));
+                pre_balance_info.token = collect_token_balances(
+                    bank,
+                    &batch,
+                    &mut pre_balance_info.mint_decimals,
+                    Some(account_overrides),
+                );
+            }
+        });
+        saturating_add_assign!(metrics.collect_balances_us, collect_balances_us);
+
+        let end = min(
+            chunk_start.saturating_add(batch.sanitized_transactions().len()),
+            pre_execution_accounts.len(),
+        );
+
+        let m = Measure::start("accounts");
+        let accounts_requested = &pre_execution_accounts[chunk_start..end];
+        let pre_tx_execution_accounts =
+            get_account_transactions(bank, account_overrides, accounts_requested, &batch);
+        saturating_add_assign!(metrics.collect_pre_post_accounts_us, m.end_as_us());
+
+        let (mut load_and_execute_transactions_output, load_execute_us) = measure_us!(bank
+            .load_and_execute_transactions(
+                &batch,
+                max_age,
+                &mut metrics.execute_timings,
+                TransactionProcessingConfig {
+                    account_overrides: Some(account_overrides),
+                    check_program_modification_slot: bank.check_program_modification_slot(),
+                    compute_budget: bank.compute_budget(),
+                    log_messages_bytes_limit: *log_messages_bytes_limit,
+                    limit_to_load_programs: true,
+                    recording_config: ExecutionRecordingConfig::new_single_setting(
+                        transaction_status_sender_enabled
+                    ),
+                    transaction_account_lock_limit: Some(bank.get_transaction_account_lock_limit()),
+                },
+            ));
+        debug!(
+            "bundle id: {} loaded_transactions: {:?}",
+            bundle.bundle_id, load_and_execute_transactions_output.loaded_transactions
+        );
+        saturating_add_assign!(metrics.load_execute_us, load_execute_us);
+
+        // All transactions within a bundle are expected to be executable + not fail
+        // If there's any transactions that executed and failed or didn't execute due to
+        // unexpected failures (not locking related), bail out of bundle execution early.
+        if let Err((failing_tx, exec_result)) = check_bundle_execution_results(
+            load_and_execute_transactions_output
+                .execution_results
+                .as_slice(),
+            batch.sanitized_transactions(),
+        ) {
+            // TODO (LB): we should try to return partial results here for successful bundles in a parallel batch.
+            //  given a bundle that write locks the following accounts [[A], [B], [C]]
+            //  when B fails, we could return the execution results for A and C, but leave B out.
+            //  however, if we have bundle that write locks accounts [[A_1], [A_2], [B], [C]] and B fails
+            //  we'll get the results for A_1 but not [A_2], [B], [C] due to the way this loop executes.
+            debug!(
+                "bundle: {} execution error; signature: {} error: {:?}",
+                bundle.bundle_id,
+                failing_tx.signature(),
+                exec_result
+            );
+            return LoadAndExecuteBundleOutput {
+                bundle_transaction_results,
+                metrics,
+                result: Err(LoadAndExecuteBundleError::TransactionError {
+                    signature: *failing_tx.signature(),
+                    execution_result: Box::new(exec_result.clone()),
+                }),
+            };
+        }
+
+        // If none of the transactions were executed, most likely an AccountInUse error
+        // need to retry to ensure that all transactions in the bundle are executed.
+        if !load_and_execute_transactions_output
+            .execution_results
+            .iter()
+            .any(|r| r.was_executed())
+        {
+            saturating_add_assign!(metrics.num_retries, 1);
+            debug!(
+                "bundle: {} no transaction executed, retrying",
+                bundle.bundle_id
+            );
+            continue;
+        }
+
+        // Cache accounts so next iterations of loop can load cached state instead of using
+        // AccountsDB, which will contain stale account state because results aren't committed
+        // to the bank yet.
+        // NOTE: collect_accounts_to_store does not handle any state changes related to
+        // failed, non-nonce transactions.
+        let m = Measure::start("cache");
+
+        let ((last_blockhash, lamports_per_signature), _last_blockhash_us) =
+            measure_us!(bank.last_blockhash_and_lamports_per_signature());
+        let durable_nonce = DurableNonce::from_blockhash(&last_blockhash);
+
+        let accounts = Accounts::collect_accounts_to_store(
+            batch.sanitized_transactions(),
+            &load_and_execute_transactions_output.execution_results,
+            &mut load_and_execute_transactions_output.loaded_transactions,
+            &durable_nonce,
+            lamports_per_signature,
+        )
+        .0;
+        for (pubkey, data) in accounts {
+            account_overrides.set_account(pubkey, Some(data.clone()));
+        }
+        saturating_add_assign!(metrics.cache_accounts_us, m.end_as_us());
+
+        let end = max(
+            chunk_start.saturating_add(batch.sanitized_transactions().len()),
+            post_execution_accounts.len(),
+        );
+
+        let m = Measure::start("accounts");
+        let accounts_requested = &post_execution_accounts[chunk_start..end];
+        let post_tx_execution_accounts =
+            get_account_transactions(bank, account_overrides, accounts_requested, &batch);
+        saturating_add_assign!(metrics.collect_pre_post_accounts_us, m.end_as_us());
+
+        let ((post_balances, post_token_balances), collect_balances_us) =
+            measure_us!(if transaction_status_sender_enabled {
+                let post_balances =
+                    bank.collect_balances_with_cache(&batch, Some(account_overrides));
+                let post_token_balances = collect_token_balances(
+                    bank,
+                    &batch,
+                    &mut pre_balance_info.mint_decimals,
+                    Some(account_overrides),
+                );
+                (post_balances, post_token_balances)
+            } else {
+                (
+                    TransactionBalances::default(),
+                    TransactionTokenBalances::default(),
+                )
+            });
+        saturating_add_assign!(metrics.collect_balances_us, collect_balances_us);
+
+        let processing_end = batch.lock_results().iter().position(|lr| lr.is_err());
+        if let Some(end) = processing_end {
+            chunk_start = chunk_start.saturating_add(end);
+        } else {
+            chunk_start = chunk_end;
+        }
+
+        bundle_transaction_results.push(BundleTransactionsOutput {
+            transactions: chunk,
+            load_and_execute_transactions_output,
+            pre_balance_info,
+            post_balance_info: (post_balances, post_token_balances),
+            pre_tx_execution_accounts,
+            post_tx_execution_accounts,
+        });
+    }
+
+    LoadAndExecuteBundleOutput {
+        bundle_transaction_results,
+        metrics,
+        result: Ok(()),
+    }
+}
+
+fn get_account_transactions(
+    bank: &Bank,
+    account_overrides: &AccountOverrides,
+    accounts: &[Option<Vec<Pubkey>>],
+    batch: &TransactionBatch,
+) -> Vec<Option<Vec<(Pubkey, AccountSharedData)>>> {
+    let iter = izip!(batch.lock_results().iter(), accounts.iter());
+
+    iter.map(|(lock_result, accounts_requested)| {
+        if lock_result.is_ok() {
+            accounts_requested.as_ref().map(|accounts_requested| {
+                accounts_requested
+                    .iter()
+                    .map(|a| match account_overrides.get(a) {
+                        None => (*a, bank.get_account(a).unwrap_or_default()),
+                        Some(data) => (*a, data.clone()),
+                    })
+                    .collect()
+            })
+        } else {
+            None
+        }
+    })
+    .collect()
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        crate::bundle_execution::{load_and_execute_bundle, LoadAndExecuteBundleError},
+        assert_matches::assert_matches,
+        solana_ledger::genesis_utils::create_genesis_config,
+        solana_runtime::{bank::Bank, bank_forks::BankForks, genesis_utils::GenesisConfigInfo},
+        solana_sdk::{
+            bundle::{derive_bundle_id_from_sanitized_transactions, SanitizedBundle},
+            clock::MAX_PROCESSING_AGE,
+            pubkey::Pubkey,
+            signature::{Keypair, Signer},
+            system_transaction::transfer,
+            transaction::{SanitizedTransaction, Transaction, TransactionError},
+        },
+        std::{
+            sync::{Arc, Barrier, RwLock},
+            thread::{sleep, spawn},
+            time::Duration,
+        },
+    };
+
+    const MAX_PROCESSING_TIME: Duration = Duration::from_secs(1);
+    const LOG_MESSAGE_BYTES_LIMITS: Option<usize> = Some(100_000);
+    const MINT_AMOUNT_LAMPORTS: u64 = 1_000_000;
+
+    fn create_simple_test_bank(
+        lamports: u64,
+    ) -> (GenesisConfigInfo, Arc<Bank>, Arc<RwLock<BankForks>>) {
+        let genesis_config_info = create_genesis_config(lamports);
+        let (bank, bank_forks) =
+            Bank::new_with_bank_forks_for_tests(&genesis_config_info.genesis_config);
+        (genesis_config_info, bank, bank_forks)
+    }
+
+    fn make_bundle(txs: &[Transaction], bank: &Bank) -> SanitizedBundle {
+        let transactions: Vec<_> = txs
+            .iter()
+            .map(|tx| {
+                SanitizedTransaction::try_from_legacy_transaction(
+                    tx.clone(),
+                    bank.get_reserved_account_keys(),
+                )
+                .unwrap()
+            })
+            .collect();
+
+        let bundle_id = derive_bundle_id_from_sanitized_transactions(&transactions);
+
+        SanitizedBundle {
+            transactions,
+            bundle_id,
+        }
+    }
+
+    fn find_account_index(tx: &Transaction, account: &Pubkey) -> Option<usize> {
+        tx.message
+            .account_keys
+            .iter()
+            .position(|pubkey| account == pubkey)
+    }
+
+    /// A single, valid bundle shall execute successfully and return the correct BundleTransactionsOutput content
+    #[test]
+    fn test_single_transaction_bundle_success() {
+        const TRANSFER_AMOUNT: u64 = 1_000;
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+        let lamports_per_signature = bank
+            .get_lamports_per_signature_for_blockhash(&genesis_config_info.genesis_config.hash())
+            .unwrap();
+
+        let kp = Keypair::new();
+        let transactions = vec![transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            TRANSFER_AMOUNT,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+        let default_accounts = vec![None; bundle.transactions.len()];
+
+        let execution_result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &MAX_PROCESSING_TIME,
+            true,
+            &LOG_MESSAGE_BYTES_LIMITS,
+            false,
+            None,
+            &default_accounts,
+            &default_accounts,
+        );
+
+        // make sure the bundle succeeded
+        assert!(execution_result.result.is_ok());
+
+        // check to make sure there was one batch returned with one transaction that was the same that was put in
+        assert_eq!(execution_result.bundle_transaction_results.len(), 1);
+        let tx_result = execution_result.bundle_transaction_results.first().unwrap();
+        assert_eq!(tx_result.transactions.len(), 1);
+        assert_eq!(tx_result.transactions[0], bundle.transactions[0]);
+
+        // make sure the transaction executed successfully
+        assert_eq!(
+            tx_result
+                .load_and_execute_transactions_output
+                .execution_results
+                .len(),
+            1
+        );
+        let execution_result = tx_result
+            .load_and_execute_transactions_output
+            .execution_results
+            .first()
+            .unwrap();
+        assert!(execution_result.was_executed());
+        assert!(execution_result.was_executed_successfully());
+
+        // Make sure the post-balances are correct
+        assert_eq!(tx_result.pre_balance_info.native.len(), 1);
+        let post_tx_sol_balances = tx_result.post_balance_info.0.first().unwrap();
+
+        let minter_message_index =
+            find_account_index(&transactions[0], &genesis_config_info.mint_keypair.pubkey())
+                .unwrap();
+        let receiver_message_index = find_account_index(&transactions[0], &kp.pubkey()).unwrap();
+
+        assert_eq!(
+            post_tx_sol_balances[minter_message_index],
+            MINT_AMOUNT_LAMPORTS - lamports_per_signature - TRANSFER_AMOUNT
+        );
+        assert_eq!(
+            post_tx_sol_balances[receiver_message_index],
+            TRANSFER_AMOUNT
+        );
+    }
+
+    /// Test a simple failure
+    #[test]
+    fn test_single_transaction_bundle_fail() {
+        const TRANSFER_AMOUNT: u64 = 1_000;
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+
+        // kp has no funds, transfer will fail
+        let kp = Keypair::new();
+        let transactions = vec![transfer(
+            &kp,
+            &kp.pubkey(),
+            TRANSFER_AMOUNT,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let default_accounts = vec![None; bundle.transactions.len()];
+        let execution_result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &MAX_PROCESSING_TIME,
+            true,
+            &LOG_MESSAGE_BYTES_LIMITS,
+            false,
+            None,
+            &default_accounts,
+            &default_accounts,
+        );
+
+        assert_eq!(execution_result.bundle_transaction_results.len(), 0);
+
+        assert!(execution_result.result.is_err());
+
+        match execution_result.result.unwrap_err() {
+            LoadAndExecuteBundleError::ProcessingTimeExceeded(_)
+            | LoadAndExecuteBundleError::LockError { .. }
+            | LoadAndExecuteBundleError::InvalidPreOrPostAccounts => {
+                unreachable!();
+            }
+            LoadAndExecuteBundleError::TransactionError {
+                signature,
+                execution_result,
+            } => {
+                assert_eq!(signature, *bundle.transactions[0].signature());
+                assert!(!execution_result.was_executed());
+            }
+        }
+    }
+
+    /// Tests a multi-tx bundle that succeeds. Checks the returned results
+    #[test]
+    fn test_multi_transaction_bundle_success() {
+        const TRANSFER_AMOUNT_1: u64 = 100_000;
+        const TRANSFER_AMOUNT_2: u64 = 50_000;
+        const TRANSFER_AMOUNT_3: u64 = 10_000;
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+        let lamports_per_signature = bank
+            .get_lamports_per_signature_for_blockhash(&genesis_config_info.genesis_config.hash())
+            .unwrap();
+
+        // mint transfers 100k to 1
+        // 1 transfers 50k to 2
+        // 2 transfers 10k to 3
+        // should get executed in 3 batches [[1], [2], [3]]
+        let kp1 = Keypair::new();
+        let kp2 = Keypair::new();
+        let kp3 = Keypair::new();
+        let transactions = vec![
+            transfer(
+                &genesis_config_info.mint_keypair,
+                &kp1.pubkey(),
+                TRANSFER_AMOUNT_1,
+                genesis_config_info.genesis_config.hash(),
+            ),
+            transfer(
+                &kp1,
+                &kp2.pubkey(),
+                TRANSFER_AMOUNT_2,
+                genesis_config_info.genesis_config.hash(),
+            ),
+            transfer(
+                &kp2,
+                &kp3.pubkey(),
+                TRANSFER_AMOUNT_3,
+                genesis_config_info.genesis_config.hash(),
+            ),
+        ];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let default_accounts = vec![None; bundle.transactions.len()];
+        let execution_result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &MAX_PROCESSING_TIME,
+            true,
+            &LOG_MESSAGE_BYTES_LIMITS,
+            false,
+            None,
+            &default_accounts,
+            &default_accounts,
+        );
+
+        assert!(execution_result.result.is_ok());
+        assert_eq!(execution_result.bundle_transaction_results.len(), 3);
+
+        // first batch contains the first tx that was executed
+        assert_eq!(
+            execution_result.bundle_transaction_results[0].transactions,
+            bundle.transactions
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .load_and_execute_transactions_output
+                .execution_results
+                .len(),
+            3
+        );
+        assert!(execution_result.bundle_transaction_results[0]
+            .load_and_execute_transactions_output
+            .execution_results[0]
+            .was_executed_successfully());
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .load_and_execute_transactions_output
+                .execution_results[1]
+                .flattened_result(),
+            Err(TransactionError::AccountInUse)
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .load_and_execute_transactions_output
+                .execution_results[2]
+                .flattened_result(),
+            Err(TransactionError::AccountInUse)
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .pre_balance_info
+                .native
+                .len(),
+            3
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .post_balance_info
+                .0
+                .len(),
+            3
+        );
+
+        let minter_index =
+            find_account_index(&transactions[0], &genesis_config_info.mint_keypair.pubkey())
+                .unwrap();
+        let kp1_index = find_account_index(&transactions[0], &kp1.pubkey()).unwrap();
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .post_balance_info
+                .0[0][minter_index],
+            MINT_AMOUNT_LAMPORTS - lamports_per_signature - TRANSFER_AMOUNT_1
+        );
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[0]
+                .post_balance_info
+                .0[0][kp1_index],
+            TRANSFER_AMOUNT_1
+        );
+
+        // in the second batch, the second transaction was executed
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .transactions
+                .to_owned(),
+            bundle.transactions[1..]
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .load_and_execute_transactions_output
+                .execution_results
+                .len(),
+            2
+        );
+        assert!(execution_result.bundle_transaction_results[1]
+            .load_and_execute_transactions_output
+            .execution_results[0]
+            .was_executed_successfully());
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .load_and_execute_transactions_output
+                .execution_results[1]
+                .flattened_result(),
+            Err(TransactionError::AccountInUse)
+        );
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .pre_balance_info
+                .native
+                .len(),
+            2
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .post_balance_info
+                .0
+                .len(),
+            2
+        );
+
+        let kp1_index = find_account_index(&transactions[1], &kp1.pubkey()).unwrap();
+        let kp2_index = find_account_index(&transactions[1], &kp2.pubkey()).unwrap();
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .post_balance_info
+                .0[0][kp1_index],
+            TRANSFER_AMOUNT_1 - lamports_per_signature - TRANSFER_AMOUNT_2
+        );
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[1]
+                .post_balance_info
+                .0[0][kp2_index],
+            TRANSFER_AMOUNT_2
+        );
+
+        // in the third batch, the third transaction was executed
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .transactions
+                .to_owned(),
+            bundle.transactions[2..]
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .load_and_execute_transactions_output
+                .execution_results
+                .len(),
+            1
+        );
+        assert!(execution_result.bundle_transaction_results[2]
+            .load_and_execute_transactions_output
+            .execution_results[0]
+            .was_executed_successfully());
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .pre_balance_info
+                .native
+                .len(),
+            1
+        );
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .post_balance_info
+                .0
+                .len(),
+            1
+        );
+
+        let kp2_index = find_account_index(&transactions[2], &kp2.pubkey()).unwrap();
+        let kp3_index = find_account_index(&transactions[2], &kp3.pubkey()).unwrap();
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .post_balance_info
+                .0[0][kp2_index],
+            TRANSFER_AMOUNT_2 - lamports_per_signature - TRANSFER_AMOUNT_3
+        );
+
+        assert_eq!(
+            execution_result.bundle_transaction_results[2]
+                .post_balance_info
+                .0[0][kp3_index],
+            TRANSFER_AMOUNT_3
+        );
+    }
+
+    /// Tests a multi-tx bundle with the middle transaction failing.
+    #[test]
+    fn test_multi_transaction_bundle_fails() {
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+
+        let kp1 = Keypair::new();
+        let kp2 = Keypair::new();
+        let kp3 = Keypair::new();
+        let transactions = vec![
+            transfer(
+                &genesis_config_info.mint_keypair,
+                &kp1.pubkey(),
+                100_000,
+                genesis_config_info.genesis_config.hash(),
+            ),
+            transfer(
+                &kp2,
+                &kp3.pubkey(),
+                100_000,
+                genesis_config_info.genesis_config.hash(),
+            ),
+            transfer(
+                &kp1,
+                &kp2.pubkey(),
+                100_000,
+                genesis_config_info.genesis_config.hash(),
+            ),
+        ];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let default_accounts = vec![None; bundle.transactions.len()];
+        let execution_result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &MAX_PROCESSING_TIME,
+            true,
+            &LOG_MESSAGE_BYTES_LIMITS,
+            false,
+            None,
+            &default_accounts,
+            &default_accounts,
+        );
+        match execution_result.result.as_ref().unwrap_err() {
+            LoadAndExecuteBundleError::ProcessingTimeExceeded(_)
+            | LoadAndExecuteBundleError::LockError { .. }
+            | LoadAndExecuteBundleError::InvalidPreOrPostAccounts => {
+                unreachable!();
+            }
+
+            LoadAndExecuteBundleError::TransactionError {
+                signature,
+                execution_result: tx_failure,
+            } => {
+                assert_eq!(signature, bundle.transactions[1].signature());
+                assert_eq!(
+                    tx_failure.flattened_result(),
+                    Err(TransactionError::AccountNotFound)
+                );
+                assert_eq!(execution_result.bundle_transaction_results().len(), 0);
+            }
+        }
+    }
+
+    /// Tests that when the max processing time is exceeded, the bundle is an error
+    #[test]
+    fn test_bundle_max_processing_time_exceeded() {
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+
+        let kp = Keypair::new();
+        let transactions = vec![transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            1,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let locked_transfer = vec![SanitizedTransaction::from_transaction_for_tests(transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            2,
+            genesis_config_info.genesis_config.hash(),
+        ))];
+
+        // locks it and prevents execution bc write lock on genesis_config_info.mint_keypair + kp.pubkey() held
+        let _batch = bank.prepare_sanitized_batch(&locked_transfer);
+
+        let default = vec![None; bundle.transactions.len()];
+        let result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &Duration::from_millis(100),
+            false,
+            &None,
+            false,
+            None,
+            &default,
+            &default,
+        );
+        assert_matches!(
+            result.result,
+            Err(LoadAndExecuteBundleError::ProcessingTimeExceeded(_))
+        );
+    }
+
+    #[test]
+    fn test_simulate_bundle_with_locked_account_works() {
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+
+        let kp = Keypair::new();
+        let transactions = vec![transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            1,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let locked_transfer = vec![SanitizedTransaction::from_transaction_for_tests(transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            2,
+            genesis_config_info.genesis_config.hash(),
+        ))];
+
+        let _batch = bank.prepare_sanitized_batch(&locked_transfer);
+
+        // simulation ignores account locks so you can simulate bundles on unfrozen banks
+        let default = vec![None; bundle.transactions.len()];
+        let result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &Duration::from_millis(100),
+            false,
+            &None,
+            true,
+            None,
+            &default,
+            &default,
+        );
+        assert!(result.result.is_ok());
+    }
+
+    /// Creates a multi-tx bundle and temporarily locks the accounts for one of the transactions in a bundle.
+    /// Ensures the result is what's expected
+    #[test]
+    fn test_bundle_works_with_released_account_locks() {
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+        let barrier = Arc::new(Barrier::new(2));
+
+        let kp = Keypair::new();
+
+        let transactions = vec![transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            1,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let locked_transfer = vec![SanitizedTransaction::from_transaction_for_tests(transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            2,
+            genesis_config_info.genesis_config.hash(),
+        ))];
+
+        // background thread locks the accounts for a bit then unlocks them
+        let thread = {
+            let barrier = barrier.clone();
+            let bank = bank.clone();
+            spawn(move || {
+                let batch = bank.prepare_sanitized_batch(&locked_transfer);
+                barrier.wait();
+                sleep(Duration::from_millis(500));
+                drop(batch);
+            })
+        };
+
+        let _ = barrier.wait();
+
+        // load_and_execute_bundle should spin for a bit then process after the 500ms sleep is over
+        let default = vec![None; bundle.transactions.len()];
+        let result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &Duration::from_secs(2),
+            false,
+            &None,
+            false,
+            None,
+            &default,
+            &default,
+        );
+        assert!(result.result.is_ok());
+
+        thread.join().unwrap();
+    }
+
+    /// Tests that when the max processing time is exceeded, the bundle is an error
+    #[test]
+    fn test_bundle_bad_pre_post_accounts() {
+        const PRE_EXECUTION_ACCOUNTS: [Option<Vec<Pubkey>>; 2] = [None, None];
+        let (genesis_config_info, bank, _bank_forks) =
+            create_simple_test_bank(MINT_AMOUNT_LAMPORTS);
+
+        let kp = Keypair::new();
+        let transactions = vec![transfer(
+            &genesis_config_info.mint_keypair,
+            &kp.pubkey(),
+            1,
+            genesis_config_info.genesis_config.hash(),
+        )];
+        let bundle = make_bundle(&transactions, &bank);
+
+        let result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &Duration::from_millis(100),
+            false,
+            &None,
+            false,
+            None,
+            &PRE_EXECUTION_ACCOUNTS,
+            &vec![None; bundle.transactions.len()],
+        );
+        assert_matches!(
+            result.result,
+            Err(LoadAndExecuteBundleError::InvalidPreOrPostAccounts)
+        );
+
+        let result = load_and_execute_bundle(
+            &bank,
+            &bundle,
+            MAX_PROCESSING_AGE,
+            &Duration::from_millis(100),
+            false,
+            &None,
+            false,
+            None,
+            &vec![None; bundle.transactions.len()],
+            &PRE_EXECUTION_ACCOUNTS,
+        );
+        assert_matches!(
+            result.result,
+            Err(LoadAndExecuteBundleError::InvalidPreOrPostAccounts)
+        );
+    }
+}
diff --git a/bundle/src/lib.rs b/bundle/src/lib.rs
new file mode 100644
index 000000000000..a93e0d3d178a
--- /dev/null
+++ b/bundle/src/lib.rs
@@ -0,0 +1,60 @@
+use {
+    crate::bundle_execution::LoadAndExecuteBundleError,
+    anchor_lang::error::Error,
+    serde::{Deserialize, Serialize},
+    solana_poh::poh_recorder::PohRecorderError,
+    solana_sdk::pubkey::Pubkey,
+    thiserror::Error,
+};
+
+pub mod bundle_execution;
+
+#[derive(Error, Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub enum TipError {
+    #[error("account is missing from bank: {0}")]
+    AccountMissing(Pubkey),
+
+    #[error("Anchor error: {0}")]
+    AnchorError(String),
+
+    #[error("Lock error")]
+    LockError,
+
+    #[error("Error executing initialize programs")]
+    InitializeProgramsError,
+
+    #[error("Error cranking tip programs")]
+    CrankTipError,
+}
+
+impl From<anchor_lang::error::Error> for TipError {
+    fn from(anchor_err: Error) -> Self {
+        match anchor_err {
+            Error::AnchorError(e) => Self::AnchorError(e.error_msg),
+            Error::ProgramError(e) => Self::AnchorError(e.to_string()),
+        }
+    }
+}
+
+pub type BundleExecutionResult<T> = Result<T, BundleExecutionError>;
+
+#[derive(Error, Debug, Clone)]
+pub enum BundleExecutionError {
+    #[error("The bank has hit the max allotted time for processing transactions")]
+    BankProcessingTimeLimitReached,
+
+    #[error("The bundle exceeds the cost model")]
+    ExceedsCostModel,
+
+    #[error("Runtime error while executing the bundle: {0}")]
+    TransactionFailure(#[from] LoadAndExecuteBundleError),
+
+    #[error("Error locking bundle because a transaction is malformed")]
+    LockError,
+
+    #[error("PoH record error: {0}")]
+    PohRecordError(#[from] PohRecorderError),
+
+    #[error("Tip payment error {0}")]
+    TipError(#[from] TipError),
+}
diff --git a/ci/buildkite-pipeline-in-disk.sh b/ci/buildkite-pipeline-in-disk.sh
index 81b084ea75e8..c5877ee6f5ea 100755
--- a/ci/buildkite-pipeline-in-disk.sh
+++ b/ci/buildkite-pipeline-in-disk.sh
@@ -289,7 +289,7 @@ if [[ -n $BUILDKITE_TAG ]]; then
   start_pipeline "Tag pipeline for $BUILDKITE_TAG"
 
   annotate --style info --context release-tag \
-    "https://github.com/anza-xyz/agave/releases/$BUILDKITE_TAG"
+    "https://github.com/jito-foundation/jito-solana/releases/$BUILDKITE_TAG"
 
   # Jump directly to the secondary build to publish release artifacts quickly
   trigger_secondary_step
@@ -307,7 +307,7 @@ if [[ $BUILDKITE_BRANCH =~ ^pull ]]; then
 
   # Add helpful link back to the corresponding Github Pull Request
   annotate --style info --context pr-backlink \
-    "Github Pull Request: https://github.com/anza-xyz/agave/$BUILDKITE_BRANCH"
+    "Github Pull Request: https://github.com/jito-foundation/jito-solana/$BUILDKITE_BRANCH"
 
   pull_or_push_steps
   exit 0
diff --git a/ci/buildkite-pipeline.sh b/ci/buildkite-pipeline.sh
index 7d19808ddb8f..78a17d0235de 100755
--- a/ci/buildkite-pipeline.sh
+++ b/ci/buildkite-pipeline.sh
@@ -316,7 +316,7 @@ if [[ -n $BUILDKITE_TAG ]]; then
   start_pipeline "Tag pipeline for $BUILDKITE_TAG"
 
   annotate --style info --context release-tag \
-    "https://github.com/anza-xyz/agave/releases/$BUILDKITE_TAG"
+    "https://github.com/jito-foundation/jito-solana/releases/$BUILDKITE_TAG"
 
   # Jump directly to the secondary build to publish release artifacts quickly
   trigger_secondary_step
@@ -334,7 +334,7 @@ if [[ $BUILDKITE_BRANCH =~ ^pull ]]; then
 
   # Add helpful link back to the corresponding Github Pull Request
   annotate --style info --context pr-backlink \
-    "Github Pull Request: https://github.com/anza-xyz/agave/$BUILDKITE_BRANCH"
+    "Github Pull Request: https://github.com/jito-foundation/jito-solana/$BUILDKITE_BRANCH"
 
   pull_or_push_steps
   exit 0
diff --git a/ci/buildkite-secondary.yml b/ci/buildkite-secondary.yml
index c43c7ee449e7..627a73b2c26a 100644
--- a/ci/buildkite-secondary.yml
+++ b/ci/buildkite-secondary.yml
@@ -18,34 +18,34 @@ steps:
     agents:
       queue: "release-build"
     timeout_in_minutes: 5
-  - wait
-  - name: "publish docker"
-    command: "sdk/docker-solana/build.sh"
-    agents:
-      queue: "release-build"
-    timeout_in_minutes: 60
-  - name: "publish crate"
-    command: "ci/publish-crate.sh"
-    agents:
-      queue: "release-build"
-    retry:
-      manual:
-        permit_on_passed: true
-    timeout_in_minutes: 240
-    branches: "!master"
-  - name: "publish tarball (aarch64-apple-darwin)"
-    command: "ci/publish-tarball.sh"
-    agents:
-      queue: "release-build-aarch64-apple-darwin"
-    retry:
-      manual:
-        permit_on_passed: true
-    timeout_in_minutes: 60
-  - name: "publish tarball (x86_64-apple-darwin)"
-    command: "ci/publish-tarball.sh"
-    agents:
-      queue: "release-build-x86_64-apple-darwin"
-    retry:
-      manual:
-        permit_on_passed: true
-    timeout_in_minutes: 60
+#  - wait
+#  - name: "publish docker"
+#    command: "sdk/docker-solana/build.sh"
+#    agents:
+#      queue: "release-build"
+#    timeout_in_minutes: 60
+#  - name: "publish crate"
+#    command: "ci/publish-crate.sh"
+#    agents:
+#      queue: "release-build"
+#    retry:
+#      manual:
+#        permit_on_passed: true
+#    timeout_in_minutes: 240
+#    branches: "!master"
+#  - name: "publish tarball (aarch64-apple-darwin)"
+#    command: "ci/publish-tarball.sh"
+#    agents:
+#      queue: "release-build-aarch64-apple-darwin"
+#    retry:
+#      manual:
+#        permit_on_passed: true
+#    timeout_in_minutes: 60
+#  - name: "publish tarball (x86_64-apple-darwin)"
+#    command: "ci/publish-tarball.sh"
+#    agents:
+#      queue: "release-build-x86_64-apple-darwin"
+#    retry:
+#      manual:
+#        permit_on_passed: true
+#    timeout_in_minutes: 60
diff --git a/ci/buildkite-solana-private.sh b/ci/buildkite-solana-private.sh
index d514ac0ad25c..5bbf5ca034c2 100755
--- a/ci/buildkite-solana-private.sh
+++ b/ci/buildkite-solana-private.sh
@@ -269,7 +269,7 @@ pull_or_push_steps() {
 #   start_pipeline "Tag pipeline for $BUILDKITE_TAG"
 
 #   annotate --style info --context release-tag \
-#     "https://github.com/solana-labs/solana/releases/$BUILDKITE_TAG"
+#     "https://github.com/jito-foundation/jito-solana/releases/$BUILDKITE_TAG"
 
 #   # Jump directly to the secondary build to publish release artifacts quickly
 #   trigger_secondary_step
@@ -287,7 +287,7 @@ if [[ $BUILDKITE_BRANCH =~ ^pull ]]; then
 
   # Add helpful link back to the corresponding Github Pull Request
   annotate --style info --context pr-backlink \
-    "Github Pull Request: https://github.com/anza-xyz/agave/$BUILDKITE_BRANCH"
+    "Github Pull Request: https://github.com/jito-foundation/jito-solana/$BUILDKITE_BRANCH"
 
   pull_or_push_steps
   exit 0
diff --git a/ci/channel-info.sh b/ci/channel-info.sh
index 2bb808365653..101583307f55 100755
--- a/ci/channel-info.sh
+++ b/ci/channel-info.sh
@@ -11,7 +11,7 @@ here="$(dirname "$0")"
 # shellcheck source=ci/semver_bash/semver.sh
 source "$here"/semver_bash/semver.sh
 
-remote=https://github.com/anza-xyz/agave.git
+remote=https://github.com/jito-foundation/jito-solana.git
 
 # Fetch all vX.Y.Z tags
 #
diff --git a/ci/check-crates.sh b/ci/check-crates.sh
index 4f407824a310..802fe7b63cf9 100755
--- a/ci/check-crates.sh
+++ b/ci/check-crates.sh
@@ -31,6 +31,9 @@ printf "%s\n" "${files[@]}"
 error_count=0
 for file in "${files[@]}"; do
   read -r crate_name package_publish workspace < <(toml get "$file" . | jq -r '(.package.name | tostring)+" "+(.package.publish | tostring)+" "+(.workspace | tostring)')
+  if [ "$crate_name" == "solana-bundle" ]; then
+    continue
+  fi
   echo "=== $crate_name ($file) ==="
 
   if [[ $package_publish = 'false' ]]; then
diff --git a/ci/publish-installer.sh b/ci/publish-installer.sh
index f7d98ffd5ddc..b702e70285f0 100755
--- a/ci/publish-installer.sh
+++ b/ci/publish-installer.sh
@@ -26,14 +26,15 @@ fi
 # upload install script
 source ci/upload-ci-artifact.sh
 
-cat >release.anza.xyz-install <<EOF
+cat >release.jito.wtf-install <<EOF
 SOLANA_RELEASE=$CHANNEL_OR_TAG
 SOLANA_INSTALL_INIT_ARGS=$CHANNEL_OR_TAG
-SOLANA_DOWNLOAD_ROOT=https://release.anza.xyz
+SOLANA_DOWNLOAD_ROOT=https://release.jito.wtf
 EOF
-cat install/agave-install-init.sh >>release.anza.xyz-install
+cat install/agave-install-init.sh >>release.jito.wtf-install
 
 echo --- GCS: "install"
-upload-gcs-artifact "/solana/release.anza.xyz-install" "gs://anza-release/$CHANNEL_OR_TAG/install"
+upload-gcs-artifact "/solana/release.jito.wtf-install" "gs://jito-release/$CHANNEL_OR_TAG/install"
 echo Published to:
-ci/format-url.sh https://release.anza.xyz/"$CHANNEL_OR_TAG"/install
+ci/format-url.sh https://release.jito.wtf/"$CHANNEL_OR_TAG"/install
+
diff --git a/ci/publish-tarball.sh b/ci/publish-tarball.sh
index 4746e9fb2ff9..9401f74915f6 100755
--- a/ci/publish-tarball.sh
+++ b/ci/publish-tarball.sh
@@ -119,10 +119,10 @@ for file in "${TARBALL_BASENAME}"-$TARGET.tar.bz2 "${TARBALL_BASENAME}"-$TARGET.
 
   if [[ -n $BUILDKITE ]]; then
     echo --- GCS Store: "$file"
-    upload-gcs-artifact "/solana/$file" gs://anza-release/"$CHANNEL_OR_TAG"/"$file"
+    upload-gcs-artifact "/solana/$file" gs://jito-release/"$CHANNEL_OR_TAG"/"$file"
 
     echo Published to:
-    $DRYRUN ci/format-url.sh https://release.anza.xyz/"$CHANNEL_OR_TAG"/"$file"
+    $DRYRUN ci/format-url.sh https://release.jito.wtf/"$CHANNEL_OR_TAG"/"$file"
 
     if [[ -n $TAG ]]; then
       ci/upload-github-release-asset.sh "$file"
diff --git a/ci/test-coverage.sh b/ci/test-coverage.sh
index f4288285a41e..323241b294c4 100755
--- a/ci/test-coverage.sh
+++ b/ci/test-coverage.sh
@@ -40,5 +40,5 @@ else
   codecov -t "${CODECOV_TOKEN}" --dir "$here/../target/cov/${SHORT_CI_COMMIT}"
 
   annotate --style success --context codecov.io \
-    "CodeCov report: https://codecov.io/github/anza-xyz/agave/commit/$CI_COMMIT"
+    "CodeCov report: https://codecov.io/github/jito-foundation/jito-solana/commit/$CI_COMMIT"
 fi
diff --git a/ci/upload-github-release-asset.sh b/ci/upload-github-release-asset.sh
index 229fb8993eda..fb4de1af9e94 100755
--- a/ci/upload-github-release-asset.sh
+++ b/ci/upload-github-release-asset.sh
@@ -26,7 +26,7 @@ fi
 # Force CI_REPO_SLUG since sometimes
 # BUILDKITE_TRIGGERED_FROM_BUILD_PIPELINE_SLUG is not set correctly, causing the
 # artifact upload to fail
-CI_REPO_SLUG=anza-xyz/agave
+CI_REPO_SLUG=jito-foundation/jito-solana
 #if [[ -z $CI_REPO_SLUG ]]; then
 #  echo Error: CI_REPO_SLUG not defined
 #  exit 1
diff --git a/core/Cargo.toml b/core/Cargo.toml
index 250a858e9d4b..852dee1eb30d 100644
--- a/core/Cargo.toml
+++ b/core/Cargo.toml
@@ -15,6 +15,7 @@ codecov = { repository = "solana-labs/solana", branch = "master", service = "git
 
 [dependencies]
 ahash = { workspace = true }
+anchor-lang = { workspace = true }
 base64 = { workspace = true }
 bincode = { workspace = true }
 bs58 = { workspace = true }
@@ -26,12 +27,17 @@ etcd-client = { workspace = true, features = ["tls"] }
 futures = { workspace = true }
 histogram = { workspace = true }
 itertools = { workspace = true }
+jito-protos = { workspace = true }
+jito-tip-distribution = { workspace = true }
+jito-tip-payment = { workspace = true }
 lazy_static = { workspace = true }
 log = { workspace = true }
 lru = { workspace = true }
 min-max-heap = { workspace = true }
 num_enum = { workspace = true }
 prio-graph = { workspace = true }
+prost = { workspace = true }
+prost-types = { workspace = true }
 qualifier_attr = { workspace = true }
 quinn = { workspace = true }
 rand = { workspace = true }
@@ -44,6 +50,7 @@ serde_bytes = { workspace = true }
 serde_derive = { workspace = true }
 solana-accounts-db = { workspace = true }
 solana-bloom = { workspace = true }
+solana-bundle = { workspace = true }
 solana-client = { workspace = true }
 solana-compute-budget = { workspace = true }
 solana-connection-cache = { workspace = true }
@@ -65,6 +72,7 @@ solana-rayon-threadlimit = { workspace = true }
 solana-rpc = { workspace = true }
 solana-rpc-client-api = { workspace = true }
 solana-runtime = { workspace = true }
+solana-runtime-plugin = { workspace = true }
 solana-sdk = { workspace = true }
 solana-send-transaction-service = { workspace = true }
 solana-streamer = { workspace = true }
@@ -83,6 +91,7 @@ sys-info = { workspace = true }
 tempfile = { workspace = true }
 thiserror = { workspace = true }
 tokio = { workspace = true, features = ["full"] }
+tonic = { workspace = true }
 trees = { workspace = true }
 
 [dev-dependencies]
@@ -90,12 +99,15 @@ assert_matches = { workspace = true }
 fs_extra = { workspace = true }
 serde_json = { workspace = true }
 serial_test = { workspace = true }
+solana-accounts-db = { workspace = true }
 # See order-crates-for-publishing.py for using this unusual `path = "."`
+solana-bundle = { workspace = true }
 solana-core = { path = ".", features = ["dev-context-only-utils"] }
 solana-ledger = { workspace = true, features = ["dev-context-only-utils"] }
 solana-logger = { workspace = true }
 solana-poh = { workspace = true, features = ["dev-context-only-utils"] }
 solana-program-runtime = { workspace = true }
+solana-program-test = { workspace = true }
 solana-runtime = { workspace = true, features = ["dev-context-only-utils"] }
 solana-sdk = { workspace = true, features = ["dev-context-only-utils"] }
 solana-stake-program = { workspace = true }
@@ -111,6 +123,7 @@ sysctl = { workspace = true }
 
 [build-dependencies]
 rustc_version = { workspace = true }
+tonic-build = { workspace = true }
 
 [features]
 dev-context-only-utils = []
diff --git a/core/benches/banking_stage.rs b/core/benches/banking_stage.rs
index d0efbfafddfc..95d72167da60 100644
--- a/core/benches/banking_stage.rs
+++ b/core/benches/banking_stage.rs
@@ -25,6 +25,7 @@ use {
             BankingStage, BankingStageStats,
         },
         banking_trace::{BankingPacketBatch, BankingTracer},
+        bundle_stage::bundle_account_locker::BundleAccountLocker,
     },
     solana_entry::entry::{next_hash, Entry},
     solana_gossip::cluster_info::{ClusterInfo, Node},
@@ -54,6 +55,7 @@ use {
     },
     solana_streamer::socket::SocketAddrSpace,
     std::{
+        collections::HashSet,
         iter::repeat_with,
         sync::{atomic::Ordering, Arc},
         time::{Duration, Instant},
@@ -65,8 +67,15 @@ fn check_txs(receiver: &Arc<Receiver<WorkingBankEntry>>, ref_tx_count: usize) {
     let mut total = 0;
     let now = Instant::now();
     loop {
-        if let Ok((_bank, (entry, _tick_height))) = receiver.recv_timeout(Duration::new(1, 0)) {
-            total += entry.transactions.len();
+        if let Ok(WorkingBankEntry {
+            bank: _,
+            entries_ticks,
+        }) = receiver.recv_timeout(Duration::new(1, 0))
+        {
+            total += entries_ticks
+                .iter()
+                .map(|e| e.0.transactions.len())
+                .sum::<usize>();
         }
         if total >= ref_tx_count {
             break;
@@ -110,7 +119,14 @@ fn bench_consume_buffered(bencher: &mut Bencher) {
     );
     let (s, _r) = unbounded();
     let committer = Committer::new(None, s, Arc::new(PrioritizationFeeCache::new(0u64)));
-    let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+    let consumer = Consumer::new(
+        committer,
+        recorder,
+        QosService::new(1),
+        None,
+        HashSet::default(),
+        BundleAccountLocker::default(),
+    );
     // This tests the performance of buffering packets.
     // If the packet buffers are copied, performance will be poor.
     bencher.iter(move || {
@@ -304,6 +320,8 @@ fn bench_banking(bencher: &mut Bencher, tx_type: TransactionType) {
         bank_forks,
         &Arc::new(PrioritizationFeeCache::new(0u64)),
         false,
+        HashSet::default(),
+        BundleAccountLocker::default(),
     );
 
     let chunk_len = verified.len() / CHUNKS;
diff --git a/core/benches/consumer.rs b/core/benches/consumer.rs
index d736b93ef96f..d0486219b022 100644
--- a/core/benches/consumer.rs
+++ b/core/benches/consumer.rs
@@ -7,16 +7,16 @@ use {
         iter::IndexedParallelIterator,
         prelude::{IntoParallelIterator, IntoParallelRefIterator, ParallelIterator},
     },
-    solana_core::banking_stage::{
-        committer::Committer, consumer::Consumer, qos_service::QosService,
+    solana_core::{
+        banking_stage::{committer::Committer, consumer::Consumer, qos_service::QosService},
+        bundle_stage::bundle_account_locker::BundleAccountLocker,
     },
-    solana_entry::entry::Entry,
     solana_ledger::{
         blockstore::Blockstore,
         genesis_utils::{create_genesis_config, GenesisConfigInfo},
     },
     solana_poh::{
-        poh_recorder::{create_test_recorder, PohRecorder},
+        poh_recorder::{create_test_recorder, PohRecorder, WorkingBankEntry},
         poh_service::PohService,
     },
     solana_runtime::{bank::Bank, bank_forks::BankForks},
@@ -28,9 +28,12 @@ use {
         system_program, system_transaction,
         transaction::SanitizedTransaction,
     },
-    std::sync::{
-        atomic::{AtomicBool, Ordering},
-        Arc, RwLock,
+    std::{
+        collections::HashSet,
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc, RwLock,
+        },
     },
     tempfile::TempDir,
     test::Bencher,
@@ -84,7 +87,14 @@ fn create_consumer(poh_recorder: &RwLock<PohRecorder>) -> Consumer {
     let (replay_vote_sender, _replay_vote_receiver) = unbounded();
     let committer = Committer::new(None, replay_vote_sender, Arc::default());
     let transaction_recorder = poh_recorder.read().unwrap().new_recorder();
-    Consumer::new(committer, transaction_recorder, QosService::new(0), None)
+    Consumer::new(
+        committer,
+        transaction_recorder,
+        QosService::new(0),
+        None,
+        HashSet::default(),
+        BundleAccountLocker::default(),
+    )
 }
 
 struct BenchFrame {
@@ -94,7 +104,7 @@ struct BenchFrame {
     exit: Arc<AtomicBool>,
     poh_recorder: Arc<RwLock<PohRecorder>>,
     poh_service: PohService,
-    signal_receiver: Receiver<(Arc<Bank>, (Entry, u64))>,
+    signal_receiver: Receiver<WorkingBankEntry>,
 }
 
 fn setup() -> BenchFrame {
diff --git a/core/benches/proto_to_packet.rs b/core/benches/proto_to_packet.rs
new file mode 100644
index 000000000000..87f85f9c7fef
--- /dev/null
+++ b/core/benches/proto_to_packet.rs
@@ -0,0 +1,56 @@
+#![feature(test)]
+
+extern crate test;
+
+use {
+    jito_protos::proto::packet::{
+        Meta as PbMeta, Packet as PbPacket, PacketBatch, PacketFlags as PbFlags,
+    },
+    solana_core::proto_packet_to_packet,
+    solana_sdk::packet::{Packet, PACKET_DATA_SIZE},
+    std::iter::repeat,
+    test::{black_box, Bencher},
+};
+
+fn get_proto_packet(i: u8) -> PbPacket {
+    PbPacket {
+        data: repeat(i).take(PACKET_DATA_SIZE).collect(),
+        meta: Some(PbMeta {
+            size: PACKET_DATA_SIZE as u64,
+            addr: "255.255.255.255:65535".to_string(),
+            port: 65535,
+            flags: Some(PbFlags {
+                discard: false,
+                forwarded: false,
+                repair: false,
+                simple_vote_tx: false,
+                tracer_packet: false,
+            }),
+            sender_stake: 0,
+        }),
+    }
+}
+
+#[bench]
+fn bench_proto_to_packet(bencher: &mut Bencher) {
+    bencher.iter(|| {
+        black_box(proto_packet_to_packet(get_proto_packet(1)));
+    });
+}
+
+#[bench]
+fn bench_batch_list_to_packets(bencher: &mut Bencher) {
+    let packet_batch = PacketBatch {
+        packets: (0..128).map(get_proto_packet).collect(),
+    };
+
+    bencher.iter(|| {
+        black_box(
+            packet_batch
+                .packets
+                .iter()
+                .map(|p| proto_packet_to_packet(p.clone()))
+                .collect::<Vec<Packet>>(),
+        );
+    });
+}
diff --git a/core/src/admin_rpc_post_init.rs b/core/src/admin_rpc_post_init.rs
index 364509a63b98..425a4375c156 100644
--- a/core/src/admin_rpc_post_init.rs
+++ b/core/src/admin_rpc_post_init.rs
@@ -1,6 +1,7 @@
 use {
     crate::{
         cluster_slots_service::cluster_slots::ClusterSlots,
+        proxy::{block_engine_stage::BlockEngineConfig, relayer_stage::RelayerConfig},
         repair::{outstanding_requests::OutstandingRequests, serve_repair::ShredRepairType},
     },
     solana_gossip::cluster_info::ClusterInfo,
@@ -8,8 +9,8 @@ use {
     solana_sdk::{pubkey::Pubkey, quic::NotifyKeyUpdate},
     std::{
         collections::HashSet,
-        net::UdpSocket,
-        sync::{Arc, RwLock},
+        net::{SocketAddr, UdpSocket},
+        sync::{Arc, Mutex, RwLock},
     },
 };
 
@@ -23,4 +24,7 @@ pub struct AdminRpcRequestMetadataPostInit {
     pub repair_socket: Arc<UdpSocket>,
     pub outstanding_repair_requests: Arc<RwLock<OutstandingRequests<ShredRepairType>>>,
     pub cluster_slots: Arc<ClusterSlots>,
+    pub block_engine_config: Arc<Mutex<BlockEngineConfig>>,
+    pub relayer_config: Arc<Mutex<RelayerConfig>>,
+    pub shred_receiver_address: Arc<RwLock<Option<SocketAddr>>>,
 }
diff --git a/core/src/banking_stage.rs b/core/src/banking_stage.rs
index 1bdd7defeec8..607b7ee10dd2 100644
--- a/core/src/banking_stage.rs
+++ b/core/src/banking_stage.rs
@@ -25,6 +25,7 @@ use {
             },
         },
         banking_trace::BankingPacketReceiver,
+        bundle_stage::bundle_account_locker::BundleAccountLocker,
         tracer_packet_stats::TracerPacketStats,
         validator::BlockProductionMethod,
     },
@@ -40,9 +41,11 @@ use {
         bank_forks::BankForks, prioritization_fee_cache::PrioritizationFeeCache,
         vote_sender_types::ReplayVoteSender,
     },
-    solana_sdk::timing::AtomicInterval,
+    solana_sdk::{pubkey::Pubkey, timing::AtomicInterval},
     std::{
-        cmp, env,
+        cmp,
+        collections::HashSet,
+        env,
         sync::{
             atomic::{AtomicU64, AtomicUsize, Ordering},
             Arc, RwLock,
@@ -62,12 +65,12 @@ pub mod unprocessed_packet_batches;
 pub mod unprocessed_transaction_storage;
 
 mod consume_worker;
-mod decision_maker;
+pub(crate) mod decision_maker;
 mod forward_packet_batches_by_accounts;
 mod forward_worker;
-mod immutable_deserialized_packet;
+pub(crate) mod immutable_deserialized_packet;
 mod latest_unprocessed_votes;
-mod leader_slot_timing_metrics;
+pub(crate) mod leader_slot_timing_metrics;
 mod multi_iterator_scanner;
 mod packet_deserializer;
 mod packet_filter;
@@ -340,6 +343,8 @@ impl BankingStage {
         bank_forks: Arc<RwLock<BankForks>>,
         prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
         enable_forwarding: bool,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> Self {
         Self::new_num_threads(
             block_production_method,
@@ -356,6 +361,8 @@ impl BankingStage {
             bank_forks,
             prioritization_fee_cache,
             enable_forwarding,
+            blacklisted_accounts,
+            bundle_account_locker,
         )
     }
 
@@ -375,6 +382,8 @@ impl BankingStage {
         bank_forks: Arc<RwLock<BankForks>>,
         prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
         enable_forwarding: bool,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> Self {
         match block_production_method {
             BlockProductionMethod::ThreadLocalMultiIterator => {
@@ -391,6 +400,8 @@ impl BankingStage {
                     connection_cache,
                     bank_forks,
                     prioritization_fee_cache,
+                    blacklisted_accounts,
+                    bundle_account_locker,
                 )
             }
             BlockProductionMethod::CentralScheduler => Self::new_central_scheduler(
@@ -407,6 +418,8 @@ impl BankingStage {
                 bank_forks,
                 prioritization_fee_cache,
                 enable_forwarding,
+                blacklisted_accounts,
+                bundle_account_locker,
             ),
         }
     }
@@ -425,6 +438,8 @@ impl BankingStage {
         connection_cache: Arc<ConnectionCache>,
         bank_forks: Arc<RwLock<BankForks>>,
         prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> Self {
         assert!(num_threads >= MIN_TOTAL_THREADS);
         // Single thread to generate entries from many banks.
@@ -489,6 +504,8 @@ impl BankingStage {
                     log_messages_bytes_limit,
                     forwarder,
                     unprocessed_transaction_storage,
+                    blacklisted_accounts.clone(),
+                    bundle_account_locker.clone(),
                 )
             })
             .collect();
@@ -510,6 +527,8 @@ impl BankingStage {
         bank_forks: Arc<RwLock<BankForks>>,
         prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
         enable_forwarding: bool,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> Self {
         assert!(num_threads >= MIN_TOTAL_THREADS);
         // Single thread to generate entries from many banks.
@@ -554,6 +573,8 @@ impl BankingStage {
                     latest_unprocessed_votes.clone(),
                     vote_source,
                 ),
+                blacklisted_accounts.clone(),
+                bundle_account_locker.clone(),
             ));
         }
 
@@ -575,6 +596,8 @@ impl BankingStage {
                     poh_recorder.read().unwrap().new_recorder(),
                     QosService::new(id),
                     log_messages_bytes_limit,
+                    blacklisted_accounts.clone(),
+                    bundle_account_locker.clone(),
                 ),
                 finished_work_sender.clone(),
                 poh_recorder.read().unwrap().new_leader_bank_notifier(),
@@ -629,6 +652,7 @@ impl BankingStage {
         Self { bank_thread_hdls }
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn spawn_thread_local_multi_iterator_thread(
         id: u32,
         packet_receiver: BankingPacketReceiver,
@@ -639,13 +663,18 @@ impl BankingStage {
         log_messages_bytes_limit: Option<usize>,
         mut forwarder: Forwarder,
         unprocessed_transaction_storage: UnprocessedTransactionStorage,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> JoinHandle<()> {
         let mut packet_receiver = PacketReceiver::new(id, packet_receiver, bank_forks);
+
         let consumer = Consumer::new(
             committer,
             transaction_recorder,
             QosService::new(id),
             log_messages_bytes_limit,
+            blacklisted_accounts.clone(),
+            bundle_account_locker.clone(),
         );
 
         Builder::new()
@@ -806,7 +835,7 @@ mod tests {
         crate::banking_trace::{BankingPacketBatch, BankingTracer},
         crossbeam_channel::{unbounded, Receiver},
         itertools::Itertools,
-        solana_entry::entry::{self, Entry, EntrySlice},
+        solana_entry::entry::{self, EntrySlice},
         solana_gossip::cluster_info::Node,
         solana_ledger::{
             blockstore::Blockstore,
@@ -820,6 +849,7 @@ mod tests {
         solana_poh::{
             poh_recorder::{
                 create_test_recorder, PohRecorderError, Record, RecordTransactionsSummary,
+                WorkingBankEntry,
             },
             poh_service::PohService,
         },
@@ -891,6 +921,8 @@ mod tests {
                 bank_forks,
                 &Arc::new(PrioritizationFeeCache::new(0u64)),
                 false,
+                HashSet::default(),
+                BundleAccountLocker::default(),
             );
             drop(non_vote_sender);
             drop(tpu_vote_sender);
@@ -947,6 +979,8 @@ mod tests {
                 bank_forks,
                 &Arc::new(PrioritizationFeeCache::new(0u64)),
                 false,
+                HashSet::default(),
+                BundleAccountLocker::default(),
             );
             trace!("sending bank");
             drop(non_vote_sender);
@@ -959,7 +993,12 @@ mod tests {
             trace!("getting entries");
             let entries: Vec<_> = entry_receiver
                 .iter()
-                .map(|(_bank, (entry, _tick_height))| entry)
+                .flat_map(
+                    |WorkingBankEntry {
+                         bank: _,
+                         entries_ticks,
+                     }| entries_ticks.into_iter().map(|(e, _)| e),
+                )
                 .collect();
             trace!("done");
             assert_eq!(entries.len(), genesis_config.ticks_per_slot as usize);
@@ -1027,6 +1066,8 @@ mod tests {
                 bank_forks.clone(), // keep a local-copy of bank-forks so worker threads do not lose weak access to bank-forks
                 &Arc::new(PrioritizationFeeCache::new(0u64)),
                 false,
+                HashSet::default(),
+                BundleAccountLocker::default(),
             );
 
             // fund another account so we can send 2 good transactions in a single batch.
@@ -1078,9 +1119,14 @@ mod tests {
             bank.process_transaction(&fund_tx).unwrap();
             //receive entries + ticks
             loop {
-                let entries: Vec<Entry> = entry_receiver
+                let entries: Vec<_> = entry_receiver
                     .iter()
-                    .map(|(_bank, (entry, _tick_height))| entry)
+                    .flat_map(
+                        |WorkingBankEntry {
+                             bank: _,
+                             entries_ticks,
+                         }| entries_ticks.into_iter().map(|(e, _)| e),
+                    )
                     .collect();
 
                 assert!(entries.verify(&blockhash, &entry::thread_pool_for_tests()));
@@ -1197,6 +1243,8 @@ mod tests {
                     Arc::new(ConnectionCache::new("connection_cache_test")),
                     bank_forks,
                     &Arc::new(PrioritizationFeeCache::new(0u64)),
+                    HashSet::default(),
+                    BundleAccountLocker::default(),
                 );
 
                 // wait for banking_stage to eat the packets
@@ -1215,7 +1263,12 @@ mod tests {
             // check that the balance is what we expect.
             let entries: Vec<_> = entry_receiver
                 .iter()
-                .map(|(_bank, (entry, _tick_height))| entry)
+                .flat_map(
+                    |WorkingBankEntry {
+                         bank: _,
+                         entries_ticks,
+                     }| entries_ticks.into_iter().map(|(e, _)| e),
+                )
                 .collect();
 
             let (bank, _bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
@@ -1278,15 +1331,19 @@ mod tests {
                 system_transaction::transfer(&keypair2, &pubkey2, 1, genesis_config.hash()).into(),
             ];
 
-            let _ = recorder.record_transactions(bank.slot(), txs.clone());
-            let (_bank, (entry, _tick_height)) = entry_receiver.recv().unwrap();
+            let _ = recorder.record_transactions(bank.slot(), vec![txs.clone()]);
+            let WorkingBankEntry {
+                bank,
+                entries_ticks,
+            } = entry_receiver.recv().unwrap();
+            let entry = &entries_ticks.first().unwrap().0;
             assert_eq!(entry.transactions, txs);
 
             // Once bank is set to a new bank (setting bank.slot() + 1 in record_transactions),
             // record_transactions should throw MaxHeightReached
             let next_slot = bank.slot() + 1;
             let RecordTransactionsSummary { result, .. } =
-                recorder.record_transactions(next_slot, txs);
+                recorder.record_transactions(next_slot, vec![txs]);
             assert_matches!(result, Err(PohRecorderError::MaxHeightReached));
             // Should receive nothing from PohRecorder b/c record failed
             assert!(entry_receiver.try_recv().is_err());
@@ -1389,6 +1446,8 @@ mod tests {
                 bank_forks,
                 &Arc::new(PrioritizationFeeCache::new(0u64)),
                 false,
+                HashSet::default(),
+                BundleAccountLocker::default(),
             );
 
             let keypairs = (0..100).map(|_| Keypair::new()).collect_vec();
diff --git a/core/src/banking_stage/committer.rs b/core/src/banking_stage/committer.rs
index 0ca1304a4560..63f69210240c 100644
--- a/core/src/banking_stage/committer.rs
+++ b/core/src/banking_stage/committer.rs
@@ -12,15 +12,13 @@ use {
         transaction_batch::TransactionBatch,
         vote_sender_types::ReplayVoteSender,
     },
-    solana_sdk::{hash::Hash, pubkey::Pubkey, saturating_add_assign},
+    solana_sdk::{hash::Hash, saturating_add_assign},
     solana_svm::{
         account_loader::TransactionLoadResult,
         transaction_results::{TransactionExecutionResult, TransactionResults},
     },
-    solana_transaction_status::{
-        token_balances::TransactionTokenBalancesSet, TransactionTokenBalance,
-    },
-    std::{collections::HashMap, sync::Arc},
+    solana_transaction_status::{token_balances::TransactionTokenBalancesSet, PreBalanceInfo},
+    std::sync::Arc,
 };
 
 #[derive(Clone, Debug, PartialEq, Eq)]
@@ -32,13 +30,6 @@ pub enum CommitTransactionDetails {
     NotCommitted,
 }
 
-#[derive(Default)]
-pub(super) struct PreBalanceInfo {
-    pub native: Vec<Vec<u64>>,
-    pub token: Vec<Vec<TransactionTokenBalance>>,
-    pub mint_decimals: HashMap<Pubkey, u8>,
-}
-
 #[derive(Clone)]
 pub struct Committer {
     transaction_status_sender: Option<TransactionStatusSender>,
@@ -156,7 +147,7 @@ impl Committer {
             let txs = batch.sanitized_transactions().to_vec();
             let post_balances = bank.collect_balances(batch);
             let post_token_balances =
-                collect_token_balances(bank, batch, &mut pre_balance_info.mint_decimals);
+                collect_token_balances(bank, batch, &mut pre_balance_info.mint_decimals, None);
             let mut transaction_index = starting_transaction_index.unwrap_or_default();
             let batch_transaction_indexes: Vec<_> = tx_results
                 .execution_results
diff --git a/core/src/banking_stage/consume_worker.rs b/core/src/banking_stage/consume_worker.rs
index 57a4778d3204..ad91be1cd8cd 100644
--- a/core/src/banking_stage/consume_worker.rs
+++ b/core/src/banking_stage/consume_worker.rs
@@ -697,11 +697,14 @@ impl ConsumeWorkerTransactionErrorMetrics {
 mod tests {
     use {
         super::*,
-        crate::banking_stage::{
-            committer::Committer,
-            qos_service::QosService,
-            scheduler_messages::{TransactionBatchId, TransactionId},
-            tests::{create_slow_genesis_config, sanitize_transactions, simulate_poh},
+        crate::{
+            banking_stage::{
+                committer::Committer,
+                qos_service::QosService,
+                scheduler_messages::{TransactionBatchId, TransactionId},
+                tests::{create_slow_genesis_config, sanitize_transactions, simulate_poh},
+            },
+            bundle_stage::bundle_account_locker::BundleAccountLocker,
         },
         crossbeam_channel::unbounded,
         solana_ledger::{
@@ -718,6 +721,7 @@ mod tests {
             signature::Keypair, system_transaction,
         },
         std::{
+            collections::HashSet,
             sync::{atomic::AtomicBool, RwLock},
             thread::JoinHandle,
         },
@@ -773,7 +777,14 @@ mod tests {
             replay_vote_sender,
             Arc::new(PrioritizationFeeCache::new(0u64)),
         );
-        let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+        let consumer = Consumer::new(
+            committer,
+            recorder,
+            QosService::new(1),
+            None,
+            HashSet::default(),
+            BundleAccountLocker::default(),
+        );
 
         let (consume_sender, consume_receiver) = unbounded();
         let (consumed_sender, consumed_receiver) = unbounded();
diff --git a/core/src/banking_stage/consumer.rs b/core/src/banking_stage/consumer.rs
index 3493a5f3a854..9e74ebb4dd5e 100644
--- a/core/src/banking_stage/consumer.rs
+++ b/core/src/banking_stage/consumer.rs
@@ -1,6 +1,6 @@
 use {
     super::{
-        committer::{CommitTransactionDetails, Committer, PreBalanceInfo},
+        committer::{CommitTransactionDetails, Committer},
         immutable_deserialized_packet::ImmutableDeserializedPacket,
         leader_slot_metrics::{LeaderSlotMetricsTracker, ProcessTransactionsSummary},
         leader_slot_timing_metrics::LeaderExecuteAndCommitTimings,
@@ -8,6 +8,7 @@ use {
         unprocessed_transaction_storage::{ConsumeScannerPayload, UnprocessedTransactionStorage},
         BankingStageStats,
     },
+    crate::bundle_stage::bundle_account_locker::BundleAccountLocker,
     itertools::Itertools,
     solana_compute_budget::compute_budget_processor::process_compute_budget_instructions,
     solana_ledger::token_balances::collect_token_balances,
@@ -16,7 +17,6 @@ use {
         BankStart, PohRecorderError, RecordTransactionsSummary, RecordTransactionsTimings,
         TransactionRecorder,
     },
-    solana_program_runtime::timings::ExecuteTimings,
     solana_runtime::{
         bank::{Bank, LoadAndExecuteTransactionsOutput},
         compute_budget_details::GetComputeBudgetDetails,
@@ -26,6 +26,7 @@ use {
         clock::{Slot, FORWARD_TRANSACTIONS_TO_LEADER_AT_SLOT_OFFSET, MAX_PROCESSING_AGE},
         feature_set,
         message::SanitizedMessage,
+        pubkey::Pubkey,
         saturating_add_assign,
         timing::timestamp,
         transaction::{self, AddressLoader, SanitizedTransaction, TransactionError},
@@ -35,7 +36,9 @@ use {
         transaction_error_metrics::TransactionErrorMetrics,
         transaction_processor::{ExecutionRecordingConfig, TransactionProcessingConfig},
     },
+    solana_transaction_status::PreBalanceInfo,
     std::{
+        collections::HashSet,
         sync::{atomic::Ordering, Arc},
         time::Instant,
     },
@@ -78,6 +81,8 @@ pub struct Consumer {
     transaction_recorder: TransactionRecorder,
     qos_service: QosService,
     log_messages_bytes_limit: Option<usize>,
+    blacklisted_accounts: HashSet<Pubkey>,
+    bundle_account_locker: BundleAccountLocker,
 }
 
 impl Consumer {
@@ -86,12 +91,16 @@ impl Consumer {
         transaction_recorder: TransactionRecorder,
         qos_service: QosService,
         log_messages_bytes_limit: Option<usize>,
+        blacklisted_accounts: HashSet<Pubkey>,
+        bundle_account_locker: BundleAccountLocker,
     ) -> Self {
         Self {
             committer,
             transaction_recorder,
             qos_service,
             log_messages_bytes_limit,
+            blacklisted_accounts,
+            bundle_account_locker,
         }
     }
 
@@ -121,6 +130,7 @@ impl Consumer {
                     packets_to_process,
                 )
             },
+            &self.blacklisted_accounts,
         );
 
         if reached_end_of_slot {
@@ -485,20 +495,26 @@ impl Consumer {
             cost_model_us,
         ) = measure_us!(self.qos_service.select_and_accumulate_transaction_costs(
             bank,
+            &mut bank.write_cost_tracker().unwrap(),
             txs,
             pre_results
         ));
 
         // Only lock accounts for those transactions are selected for the block;
         // Once accounts are locked, other threads cannot encode transactions that will modify the
-        // same account state
+        // same account state.
+        // BundleAccountLocker is used to prevent race conditions with bundled transactions from bundle stage
+        let bundle_account_locks = self.bundle_account_locker.account_locks();
         let (batch, lock_us) = measure_us!(bank.prepare_sanitized_batch_with_results(
             txs,
             transaction_qos_cost_results.iter().map(|r| match r {
                 Ok(_cost) => Ok(()),
                 Err(err) => Err(err.clone()),
-            })
+            }),
+            Some(&bundle_account_locks.read_locks()),
+            Some(&bundle_account_locks.write_locks())
         ));
+        drop(bundle_account_locks);
 
         // retryable_txs includes AccountInUse, WouldExceedMaxBlockCostLimit
         // WouldExceedMaxAccountCostLimit, WouldExceedMaxVoteCostLimit
@@ -530,8 +546,9 @@ impl Consumer {
             .iter_mut()
             .for_each(|x| *x += chunk_offset);
 
-        let (cu, us) =
-            Self::accumulate_execute_units_and_time(&execute_and_commit_timings.execute_timings);
+        let (cu, us) = execute_and_commit_timings
+            .execute_timings
+            .accumulate_execute_units_and_time();
         self.qos_service.accumulate_actual_execute_cu(cu);
         self.qos_service.accumulate_actual_execute_time(us);
 
@@ -568,7 +585,7 @@ impl Consumer {
             if transaction_status_sender_enabled {
                 pre_balance_info.native = bank.collect_balances(batch);
                 pre_balance_info.token =
-                    collect_token_balances(bank, batch, &mut pre_balance_info.mint_decimals)
+                    collect_token_balances(bank, batch, &mut pre_balance_info.mint_decimals, None)
             }
         });
         execute_and_commit_timings.collect_balances_us = collect_balances_us;
@@ -647,7 +664,7 @@ impl Consumer {
 
         let (record_transactions_summary, record_us) = measure_us!(self
             .transaction_recorder
-            .record_transactions(bank.slot(), executed_transactions));
+            .record_transactions(bank.slot(), vec![executed_transactions]));
         execute_and_commit_timings.record_us = record_us;
 
         let RecordTransactionsSummary {
@@ -770,20 +787,6 @@ impl Consumer {
         )
     }
 
-    fn accumulate_execute_units_and_time(execute_timings: &ExecuteTimings) -> (u64, u64) {
-        execute_timings.details.per_program_timings.values().fold(
-            (0, 0),
-            |(units, times), program_timings| {
-                (
-                    units
-                        .saturating_add(program_timings.accumulated_units)
-                        .saturating_add(program_timings.total_errored_units),
-                    times.saturating_add(program_timings.accumulated_us),
-                )
-            },
-        )
-    }
-
     /// This function filters pending packets that are still valid
     /// # Arguments
     /// * `transactions` - a batch of transactions deserialized from packets
@@ -849,7 +852,7 @@ mod tests {
         },
         solana_perf::packet::Packet,
         solana_poh::poh_recorder::{PohRecorder, Record, WorkingBankEntry},
-        solana_program_runtime::timings::ProgramTiming,
+        solana_program_runtime::timings::{ExecuteTimings, ProgramTiming},
         solana_rpc::transaction_status_service::TransactionStatusService,
         solana_runtime::{bank_forks::BankForks, prioritization_fee_cache::PrioritizationFeeCache},
         solana_sdk::{
@@ -926,7 +929,14 @@ mod tests {
             replay_vote_sender,
             Arc::new(PrioritizationFeeCache::new(0u64)),
         );
-        let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+        let consumer = Consumer::new(
+            committer,
+            recorder,
+            QosService::new(1),
+            None,
+            HashSet::default(),
+            BundleAccountLocker::default(),
+        );
         let process_transactions_summary =
             consumer.process_transactions(&bank, &Instant::now(), &transactions);
 
@@ -1101,7 +1111,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let process_transactions_batch_output =
                 consumer.process_and_record_transactions(&bank, &transactions, 0);
@@ -1126,7 +1143,13 @@ mod tests {
 
             let mut done = false;
             // read entries until I find mine, might be ticks...
-            while let Ok((_bank, (entry, _tick_height))) = entry_receiver.recv() {
+            while let Ok(WorkingBankEntry {
+                bank,
+                entries_ticks,
+            }) = entry_receiver.recv()
+            {
+                assert!(entries_ticks.len() == 1);
+                let entry = &entries_ticks.first().unwrap().0;
                 if !entry.is_tick() {
                     trace!("got entry");
                     assert_eq!(entry.transactions.len(), transactions.len());
@@ -1244,11 +1267,10 @@ mod tests {
                         let timeout = Duration::from_millis(10);
                         let record = record_receiver.recv_timeout(timeout);
                         if let Ok(record) = record {
-                            let record_response = poh_recorder.write().unwrap().record(
-                                record.slot,
-                                record.mixin,
-                                record.transactions,
-                            );
+                            let record_response = poh_recorder
+                                .write()
+                                .unwrap()
+                                .record(record.slot, &record.mixins_txs);
                             poh_recorder.write().unwrap().tick();
                             if record.sender.send(record_response).is_err() {
                                 panic!("Error returning mixin hash");
@@ -1285,7 +1307,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let process_transactions_batch_output =
                 consumer.process_and_record_transactions(&bank, &transactions, 0);
@@ -1310,9 +1339,13 @@ mod tests {
 
             let mut done = false;
             // read entries until I find mine, might be ticks...
-            while let Ok((_bank, (entry, _tick_height))) = entry_receiver.recv() {
-                if !entry.is_tick() {
-                    assert_eq!(entry.transactions.len(), transactions.len());
+            while let Ok(WorkingBankEntry {
+                bank: _,
+                entries_ticks,
+            }) = entry_receiver.recv()
+            {
+                if !entries_ticks[0].0.is_tick() {
+                    assert_eq!(entries_ticks[0].0.transactions.len(), transactions.len());
                     done = true;
                     break;
                 }
@@ -1386,7 +1419,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let process_transactions_batch_output =
                 consumer.process_and_record_transactions(&bank, &transactions, 0);
@@ -1462,7 +1502,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let get_block_cost = || bank.read_cost_tracker().unwrap().block_cost();
             let get_tx_count = || bank.read_cost_tracker().unwrap().transaction_count();
@@ -1625,7 +1672,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let process_transactions_batch_output =
                 consumer.process_and_record_transactions(&bank, &transactions, 0);
@@ -1821,7 +1875,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder.clone(), QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder.clone(),
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let process_transactions_summary =
                 consumer.process_transactions(&bank, &Instant::now(), &transactions);
@@ -1948,7 +2009,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let _ = consumer.process_and_record_transactions(&bank, &transactions, 0);
 
@@ -2093,7 +2161,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             let _ = consumer.process_and_record_transactions(&bank, &[sanitized_tx.clone()], 0);
 
@@ -2153,7 +2228,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             // When the working bank in poh_recorder is None, no packets should be processed (consume will not be called)
             assert!(!poh_recorder.read().unwrap().has_bank());
@@ -2238,7 +2320,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             // When the working bank in poh_recorder is None, no packets should be processed
             assert!(!poh_recorder.read().unwrap().has_bank());
@@ -2290,7 +2379,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             // When the working bank in poh_recorder is None, no packets should be processed (consume will not be called)
             assert!(!poh_recorder.read().unwrap().has_bank());
@@ -2422,7 +2518,14 @@ mod tests {
                 replay_vote_sender,
                 Arc::new(PrioritizationFeeCache::new(0u64)),
             );
-            let consumer = Consumer::new(committer, recorder, QosService::new(1), None);
+            let consumer = Consumer::new(
+                committer,
+                recorder,
+                QosService::new(1),
+                None,
+                HashSet::default(),
+                BundleAccountLocker::default(),
+            );
 
             // When the working bank in poh_recorder is None, no packets should be processed (consume will not be called)
             assert!(!poh_recorder.read().unwrap().has_bank());
@@ -2491,7 +2594,7 @@ mod tests {
             expected_units += n * 1000;
         }
 
-        let (units, us) = Consumer::accumulate_execute_units_and_time(&execute_timings);
+        let (units, us) = execute_timings.accumulate_execute_units_and_time();
 
         assert_eq!(expected_units, units);
         assert_eq!(expected_us, us);
diff --git a/core/src/banking_stage/latest_unprocessed_votes.rs b/core/src/banking_stage/latest_unprocessed_votes.rs
index 6e9f20441d9e..8f6ce2280004 100644
--- a/core/src/banking_stage/latest_unprocessed_votes.rs
+++ b/core/src/banking_stage/latest_unprocessed_votes.rs
@@ -140,7 +140,7 @@ pub(crate) fn weighted_random_order_by_stake<'a>(
 }
 
 #[derive(Default, Debug)]
-pub(crate) struct VoteBatchInsertionMetrics {
+pub struct VoteBatchInsertionMetrics {
     pub(crate) num_dropped_gossip: usize,
     pub(crate) num_dropped_tpu: usize,
 }
diff --git a/core/src/banking_stage/qos_service.rs b/core/src/banking_stage/qos_service.rs
index bf8b7df963e3..ecc1d8c4b6ef 100644
--- a/core/src/banking_stage/qos_service.rs
+++ b/core/src/banking_stage/qos_service.rs
@@ -6,7 +6,9 @@
 use {
     super::{committer::CommitTransactionDetails, BatchedTransactionDetails},
     solana_cost_model::{
-        cost_model::CostModel, cost_tracker::UpdatedCosts, transaction_cost::TransactionCost,
+        cost_model::CostModel,
+        cost_tracker::{CostTracker, UpdatedCosts},
+        transaction_cost::TransactionCost,
     },
     solana_measure::measure::Measure,
     solana_runtime::bank::Bank,
@@ -42,6 +44,7 @@ impl QosService {
     pub fn select_and_accumulate_transaction_costs(
         &self,
         bank: &Bank,
+        cost_tracker: &mut CostTracker, // caller should pass in &mut bank.write_cost_tracker().unwrap()
         transactions: &[SanitizedTransaction],
         pre_results: impl Iterator<Item = transaction::Result<()>>,
     ) -> (Vec<transaction::Result<TransactionCost>>, usize) {
@@ -50,7 +53,8 @@ impl QosService {
         let (transactions_qos_cost_results, num_included) = self.select_transactions_per_cost(
             transactions.iter(),
             transaction_costs.into_iter(),
-            bank,
+            bank.slot(),
+            cost_tracker,
         );
         self.accumulate_estimated_transaction_costs(&Self::accumulate_batched_transaction_costs(
             transactions_qos_cost_results.iter(),
@@ -96,10 +100,10 @@ impl QosService {
         &self,
         transactions: impl Iterator<Item = &'a SanitizedTransaction>,
         transactions_costs: impl Iterator<Item = transaction::Result<TransactionCost>>,
-        bank: &Bank,
+        slot: Slot,
+        cost_tracker: &mut CostTracker,
     ) -> (Vec<transaction::Result<TransactionCost>>, usize) {
         let mut cost_tracking_time = Measure::start("cost_tracking_time");
-        let mut cost_tracker = bank.write_cost_tracker().unwrap();
         let mut num_included = 0;
         let select_results = transactions.zip(transactions_costs)
             .map(|(tx, cost)| {
@@ -107,13 +111,13 @@ impl QosService {
                     Ok(cost) => {
                         match cost_tracker.try_add(&cost) {
                             Ok(UpdatedCosts{updated_block_cost, updated_costliest_account_cost}) => {
-                                debug!("slot {:?}, transaction {:?}, cost {:?}, fit into current block, current block cost {}, updated costliest account cost {}", bank.slot(), tx, cost, updated_block_cost, updated_costliest_account_cost);
+                                debug!("slot {:?}, transaction {:?}, cost {:?}, fit into current block, current block cost {}, updated costliest account cost {}", slot, tx, cost, updated_block_cost, updated_costliest_account_cost);
                                 self.metrics.stats.selected_txs_count.fetch_add(1, Ordering::Relaxed);
                                 num_included += 1;
                                 Ok(cost)
                             },
                             Err(e) => {
-                                debug!("slot {:?}, transaction {:?}, cost {:?}, not fit into current block, '{:?}'", bank.slot(), tx, cost, e);
+                                debug!("slot {:?}, transaction {:?}, cost {:?}, not fit into current block, '{:?}'", slot, tx, cost, e);
                                 Err(TransactionError::from(e))
                             }
                         }
@@ -685,8 +689,12 @@ mod tests {
         bank.write_cost_tracker()
             .unwrap()
             .set_limits(cost_limit, cost_limit, cost_limit);
-        let (results, num_selected) =
-            qos_service.select_transactions_per_cost(txs.iter(), txs_costs.into_iter(), &bank);
+        let (results, num_selected) = qos_service.select_transactions_per_cost(
+            txs.iter(),
+            txs_costs.into_iter(),
+            bank.slot(),
+            &mut bank.write_cost_tracker().unwrap(),
+        );
         assert_eq!(num_selected, 2);
 
         // verify that first transfer tx and first vote are allowed
@@ -739,8 +747,12 @@ mod tests {
                 .iter()
                 .map(|cost| cost.as_ref().unwrap().sum())
                 .sum();
-            let (qos_cost_results, _num_included) =
-                qos_service.select_transactions_per_cost(txs.iter(), txs_costs.into_iter(), &bank);
+            let (qos_cost_results, _num_included) = qos_service.select_transactions_per_cost(
+                txs.iter(),
+                txs_costs.into_iter(),
+                bank.slot(),
+                &mut bank.write_cost_tracker().unwrap(),
+            );
             assert_eq!(
                 total_txs_cost,
                 bank.read_cost_tracker().unwrap().block_cost()
@@ -804,8 +816,12 @@ mod tests {
                 .iter()
                 .map(|cost| cost.as_ref().unwrap().sum())
                 .sum();
-            let (qos_cost_results, _num_included) =
-                qos_service.select_transactions_per_cost(txs.iter(), txs_costs.into_iter(), &bank);
+            let (qos_cost_results, _num_included) = qos_service.select_transactions_per_cost(
+                txs.iter(),
+                txs_costs.into_iter(),
+                bank.slot(),
+                &mut bank.write_cost_tracker().unwrap(),
+            );
             assert_eq!(
                 total_txs_cost,
                 bank.read_cost_tracker().unwrap().block_cost()
@@ -859,8 +875,12 @@ mod tests {
                 .iter()
                 .map(|cost| cost.as_ref().unwrap().sum())
                 .sum();
-            let (qos_cost_results, _num_included) =
-                qos_service.select_transactions_per_cost(txs.iter(), txs_costs.into_iter(), &bank);
+            let (qos_cost_results, _num_included) = qos_service.select_transactions_per_cost(
+                txs.iter(),
+                txs_costs.into_iter(),
+                bank.slot(),
+                &mut bank.write_cost_tracker().unwrap(),
+            );
             assert_eq!(
                 total_txs_cost,
                 bank.read_cost_tracker().unwrap().block_cost()
diff --git a/core/src/banking_stage/unprocessed_transaction_storage.rs b/core/src/banking_stage/unprocessed_transaction_storage.rs
index 7a529bd45785..aeb78148c487 100644
--- a/core/src/banking_stage/unprocessed_transaction_storage.rs
+++ b/core/src/banking_stage/unprocessed_transaction_storage.rs
@@ -15,18 +15,29 @@ use {
         },
         BankingStageStats, FilterForwardingResults, ForwardOption,
     },
+    crate::{
+        bundle_stage::bundle_stage_leader_metrics::BundleStageLeaderMetrics,
+        immutable_deserialized_bundle::ImmutableDeserializedBundle,
+    },
     itertools::Itertools,
     min_max_heap::MinMaxHeap,
+    solana_bundle::BundleExecutionError,
     solana_measure::{measure, measure_us},
     solana_runtime::bank::Bank,
     solana_sdk::{
-        clock::FORWARD_TRANSACTIONS_TO_LEADER_AT_SLOT_OFFSET, feature_set::FeatureSet, hash::Hash,
-        saturating_add_assign, transaction::SanitizedTransaction,
+        bundle::SanitizedBundle,
+        clock::{Slot, FORWARD_TRANSACTIONS_TO_LEADER_AT_SLOT_OFFSET},
+        feature_set::FeatureSet,
+        hash::Hash,
+        pubkey::Pubkey,
+        saturating_add_assign,
+        transaction::SanitizedTransaction,
     },
     solana_svm::transaction_error_metrics::TransactionErrorMetrics,
     std::{
-        collections::HashMap,
+        collections::{HashMap, HashSet, VecDeque},
         sync::{atomic::Ordering, Arc},
+        time::Instant,
     },
 };
 
@@ -41,6 +52,7 @@ const MAX_NUM_VOTES_RECEIVE: usize = 10_000;
 pub enum UnprocessedTransactionStorage {
     VoteStorage(VoteStorage),
     LocalTransactionStorage(ThreadLocalUnprocessedPackets),
+    BundleStorage(BundleStorage),
 }
 
 #[derive(Debug)]
@@ -59,10 +71,11 @@ pub struct VoteStorage {
 pub enum ThreadType {
     Voting(VoteSource),
     Transactions,
+    Bundles,
 }
 
 #[derive(Debug)]
-pub(crate) enum InsertPacketBatchSummary {
+pub enum InsertPacketBatchSummary {
     VoteBatchInsertionMetrics(VoteBatchInsertionMetrics),
     PacketBatchInsertionMetrics(PacketBatchInsertionMetrics),
 }
@@ -146,6 +159,7 @@ fn consume_scan_should_process_packet(
     banking_stage_stats: &BankingStageStats,
     packet: &ImmutableDeserializedPacket,
     payload: &mut ConsumeScannerPayload,
+    blacklisted_accounts: &HashSet<Pubkey>,
 ) -> ProcessingDecision {
     // If end of the slot, return should process (quick loop after reached end of slot)
     if payload.reached_end_of_slot {
@@ -176,6 +190,10 @@ fn consume_scan_should_process_packet(
             bank.get_transaction_account_lock_limit(),
         )
         .is_err()
+            || message
+                .account_keys()
+                .iter()
+                .any(|key| blacklisted_accounts.contains(key))
         {
             payload
                 .message_hash_to_transaction
@@ -271,10 +289,25 @@ impl UnprocessedTransactionStorage {
         })
     }
 
+    pub fn new_bundle_storage() -> Self {
+        Self::BundleStorage(BundleStorage {
+            last_update_slot: Slot::default(),
+            unprocessed_bundle_storage: VecDeque::with_capacity(
+                BundleStorage::BUNDLE_STORAGE_CAPACITY,
+            ),
+            cost_model_buffered_bundle_storage: VecDeque::with_capacity(
+                BundleStorage::BUNDLE_STORAGE_CAPACITY,
+            ),
+        })
+    }
+
     pub fn is_empty(&self) -> bool {
         match self {
             Self::VoteStorage(vote_storage) => vote_storage.is_empty(),
             Self::LocalTransactionStorage(transaction_storage) => transaction_storage.is_empty(),
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                bundle_storage.is_empty()
+            }
         }
     }
 
@@ -282,6 +315,10 @@ impl UnprocessedTransactionStorage {
         match self {
             Self::VoteStorage(vote_storage) => vote_storage.len(),
             Self::LocalTransactionStorage(transaction_storage) => transaction_storage.len(),
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                bundle_storage.unprocessed_bundles_len()
+                    + bundle_storage.cost_model_buffered_bundles_len()
+            }
         }
     }
 
@@ -291,6 +328,7 @@ impl UnprocessedTransactionStorage {
             Self::LocalTransactionStorage(transaction_storage) => {
                 transaction_storage.get_min_compute_unit_price()
             }
+            UnprocessedTransactionStorage::BundleStorage(_) => None,
         }
     }
 
@@ -300,6 +338,7 @@ impl UnprocessedTransactionStorage {
             Self::LocalTransactionStorage(transaction_storage) => {
                 transaction_storage.get_max_compute_unit_price()
             }
+            UnprocessedTransactionStorage::BundleStorage(_) => None,
         }
     }
 
@@ -310,6 +349,9 @@ impl UnprocessedTransactionStorage {
             Self::LocalTransactionStorage(transaction_storage) => {
                 transaction_storage.max_receive_size()
             }
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                bundle_storage.max_receive_size()
+            }
         }
     }
 
@@ -336,6 +378,9 @@ impl UnprocessedTransactionStorage {
             Self::LocalTransactionStorage(transaction_storage) => {
                 transaction_storage.forward_option()
             }
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                bundle_storage.forward_option()
+            }
         }
     }
 
@@ -343,6 +388,16 @@ impl UnprocessedTransactionStorage {
         match self {
             Self::LocalTransactionStorage(transaction_storage) => transaction_storage.clear(), // Since we set everything as forwarded this is the same
             Self::VoteStorage(vote_storage) => vote_storage.clear_forwarded_packets(),
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                let _ = bundle_storage.reset();
+            }
+        }
+    }
+
+    pub fn bundle_storage(&mut self) -> Option<&mut BundleStorage> {
+        match self {
+            UnprocessedTransactionStorage::BundleStorage(bundle_stoge) => Some(bundle_stoge),
+            _ => None,
         }
     }
 
@@ -357,6 +412,11 @@ impl UnprocessedTransactionStorage {
             Self::LocalTransactionStorage(transaction_storage) => InsertPacketBatchSummary::from(
                 transaction_storage.insert_batch(deserialized_packets),
             ),
+            UnprocessedTransactionStorage::BundleStorage(_) => {
+                panic!(
+                    "bundles must be inserted using UnprocessedTransactionStorage::insert_bundle"
+                )
+            }
         }
     }
 
@@ -376,6 +436,9 @@ impl UnprocessedTransactionStorage {
                     bank,
                     forward_packet_batches_by_accounts,
                 ),
+            UnprocessedTransactionStorage::BundleStorage(_) => {
+                panic!("bundles are not forwarded between leaders")
+            }
         }
     }
 
@@ -389,6 +452,7 @@ impl UnprocessedTransactionStorage {
         banking_stage_stats: &BankingStageStats,
         slot_metrics_tracker: &mut LeaderSlotMetricsTracker,
         processing_function: F,
+        blacklisted_accounts: &HashSet<Pubkey>,
     ) -> bool
     where
         F: FnMut(
@@ -403,15 +467,62 @@ impl UnprocessedTransactionStorage {
                     banking_stage_stats,
                     slot_metrics_tracker,
                     processing_function,
+                    blacklisted_accounts,
                 ),
             Self::VoteStorage(vote_storage) => vote_storage.process_packets(
                 bank,
                 banking_stage_stats,
                 slot_metrics_tracker,
                 processing_function,
+                blacklisted_accounts,
+            ),
+            UnprocessedTransactionStorage::BundleStorage(_) => panic!(
+                "UnprocessedTransactionStorage::BundleStorage does not support processing packets"
             ),
         }
     }
+
+    #[must_use]
+    pub fn process_bundles<F>(
+        &mut self,
+        bank: Arc<Bank>,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+        blacklisted_accounts: &HashSet<Pubkey>,
+        processing_function: F,
+    ) -> bool
+    where
+        F: FnMut(
+            &[(ImmutableDeserializedBundle, SanitizedBundle)],
+            &mut BundleStageLeaderMetrics,
+        ) -> Vec<Result<(), BundleExecutionError>>,
+    {
+        match self {
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => bundle_storage
+                .process_bundles(
+                    bank,
+                    bundle_stage_leader_metrics,
+                    blacklisted_accounts,
+                    processing_function,
+                ),
+            _ => panic!("class does not support processing bundles"),
+        }
+    }
+
+    /// Inserts bundles into storage. Only supported for UnprocessedTransactionStorage::BundleStorage
+    pub(crate) fn insert_bundles(
+        &mut self,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+    ) -> InsertPacketBundlesSummary {
+        match self {
+            UnprocessedTransactionStorage::BundleStorage(bundle_storage) => {
+                bundle_storage.insert_unprocessed_bundles(deserialized_bundles, true)
+            }
+            UnprocessedTransactionStorage::LocalTransactionStorage(_)
+            | UnprocessedTransactionStorage::VoteStorage(_) => {
+                panic!("UnprocessedTransactionStorage::insert_bundles only works for type UnprocessedTransactionStorage::BundleStorage");
+            }
+        }
+    }
 }
 
 impl VoteStorage {
@@ -480,6 +591,7 @@ impl VoteStorage {
         banking_stage_stats: &BankingStageStats,
         slot_metrics_tracker: &mut LeaderSlotMetricsTracker,
         mut processing_function: F,
+        blacklisted_accounts: &HashSet<Pubkey>,
     ) -> bool
     where
         F: FnMut(
@@ -493,7 +605,13 @@ impl VoteStorage {
 
         let should_process_packet =
             |packet: &Arc<ImmutableDeserializedPacket>, payload: &mut ConsumeScannerPayload| {
-                consume_scan_should_process_packet(&bank, banking_stage_stats, packet, payload)
+                consume_scan_should_process_packet(
+                    &bank,
+                    banking_stage_stats,
+                    packet,
+                    payload,
+                    blacklisted_accounts,
+                )
             };
 
         // Based on the stake distribution present in the supplied bank, drain the unprocessed votes
@@ -579,6 +697,7 @@ impl ThreadLocalUnprocessedPackets {
             ThreadType::Transactions => ForwardOption::ForwardTransaction,
             ThreadType::Voting(VoteSource::Tpu) => ForwardOption::ForwardTpuVote,
             ThreadType::Voting(VoteSource::Gossip) => ForwardOption::NotForward,
+            ThreadType::Bundles => ForwardOption::NotForward,
         }
     }
 
@@ -904,6 +1023,7 @@ impl ThreadLocalUnprocessedPackets {
         banking_stage_stats: &BankingStageStats,
         slot_metrics_tracker: &mut LeaderSlotMetricsTracker,
         mut processing_function: F,
+        blacklisted_accounts: &HashSet<Pubkey>,
     ) -> bool
     where
         F: FnMut(
@@ -918,7 +1038,13 @@ impl ThreadLocalUnprocessedPackets {
 
         let should_process_packet =
             |packet: &Arc<ImmutableDeserializedPacket>, payload: &mut ConsumeScannerPayload| {
-                consume_scan_should_process_packet(bank, banking_stage_stats, packet, payload)
+                consume_scan_should_process_packet(
+                    bank,
+                    banking_stage_stats,
+                    packet,
+                    payload,
+                    blacklisted_accounts,
+                )
             };
         let mut scanner = create_consume_multi_iterator(
             &all_packets_to_process,
@@ -995,6 +1121,319 @@ impl ThreadLocalUnprocessedPackets {
     }
 }
 
+pub struct InsertPacketBundlesSummary {
+    pub insert_packets_summary: InsertPacketBatchSummary,
+    pub num_bundles_inserted: usize,
+    pub num_packets_inserted: usize,
+    pub num_bundles_dropped: usize,
+}
+
+/// Bundle storage has two deques: one for unprocessed bundles and another for ones that exceeded
+/// the cost model and need to get retried next slot.
+#[derive(Debug)]
+pub struct BundleStorage {
+    last_update_slot: Slot,
+    unprocessed_bundle_storage: VecDeque<ImmutableDeserializedBundle>,
+    // Storage for bundles that exceeded the cost model for the slot they were last attempted
+    // execution on
+    cost_model_buffered_bundle_storage: VecDeque<ImmutableDeserializedBundle>,
+}
+
+impl BundleStorage {
+    pub const BUNDLE_STORAGE_CAPACITY: usize = 1000;
+    fn is_empty(&self) -> bool {
+        self.unprocessed_bundle_storage.is_empty()
+    }
+
+    pub fn unprocessed_bundles_len(&self) -> usize {
+        self.unprocessed_bundle_storage.len()
+    }
+
+    pub fn unprocessed_packets_len(&self) -> usize {
+        self.unprocessed_bundle_storage
+            .iter()
+            .map(|b| b.len())
+            .sum::<usize>()
+    }
+
+    pub(crate) fn cost_model_buffered_bundles_len(&self) -> usize {
+        self.cost_model_buffered_bundle_storage.len()
+    }
+
+    pub(crate) fn cost_model_buffered_packets_len(&self) -> usize {
+        self.cost_model_buffered_bundle_storage
+            .iter()
+            .map(|b| b.len())
+            .sum()
+    }
+
+    pub(crate) fn max_receive_size(&self) -> usize {
+        self.unprocessed_bundle_storage.capacity() - self.unprocessed_bundle_storage.len()
+    }
+
+    fn forward_option(&self) -> ForwardOption {
+        ForwardOption::NotForward
+    }
+
+    /// Returns the number of unprocessed bundles + cost model buffered cleared
+    pub fn reset(&mut self) -> (usize, usize) {
+        let num_unprocessed_bundles = self.unprocessed_bundle_storage.len();
+        let num_cost_model_buffered_bundles = self.cost_model_buffered_bundle_storage.len();
+        self.unprocessed_bundle_storage.clear();
+        self.cost_model_buffered_bundle_storage.clear();
+        (num_unprocessed_bundles, num_cost_model_buffered_bundles)
+    }
+
+    fn insert_bundles(
+        deque: &mut VecDeque<ImmutableDeserializedBundle>,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+        push_back: bool,
+    ) -> InsertPacketBundlesSummary {
+        // deque should be initialized with size [Self::BUNDLE_STORAGE_CAPACITY]
+        let deque_free_space = Self::BUNDLE_STORAGE_CAPACITY
+            .checked_sub(deque.len())
+            .unwrap();
+        let bundles_to_insert_count = std::cmp::min(deque_free_space, deserialized_bundles.len());
+        let num_bundles_dropped = deserialized_bundles
+            .len()
+            .checked_sub(bundles_to_insert_count)
+            .unwrap();
+        let num_packets_inserted = deserialized_bundles
+            .iter()
+            .take(bundles_to_insert_count)
+            .map(|b| b.len())
+            .sum::<usize>();
+        let num_packets_dropped = deserialized_bundles
+            .iter()
+            .skip(bundles_to_insert_count)
+            .map(|b| b.len())
+            .sum::<usize>();
+
+        let to_insert = deserialized_bundles
+            .into_iter()
+            .take(bundles_to_insert_count);
+        if push_back {
+            deque.extend(to_insert)
+        } else {
+            to_insert.for_each(|b| deque.push_front(b));
+        }
+
+        InsertPacketBundlesSummary {
+            insert_packets_summary: PacketBatchInsertionMetrics {
+                num_dropped_packets: num_packets_dropped,
+                num_dropped_tracer_packets: 0,
+            }
+            .into(),
+            num_bundles_inserted: bundles_to_insert_count,
+            num_packets_inserted,
+            num_bundles_dropped,
+        }
+    }
+
+    fn push_front_unprocessed_bundles(
+        &mut self,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+    ) -> InsertPacketBundlesSummary {
+        Self::insert_bundles(
+            &mut self.unprocessed_bundle_storage,
+            deserialized_bundles,
+            false,
+        )
+    }
+
+    fn push_back_cost_model_buffered_bundles(
+        &mut self,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+    ) -> InsertPacketBundlesSummary {
+        Self::insert_bundles(
+            &mut self.cost_model_buffered_bundle_storage,
+            deserialized_bundles,
+            true,
+        )
+    }
+
+    fn insert_unprocessed_bundles(
+        &mut self,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+        push_back: bool,
+    ) -> InsertPacketBundlesSummary {
+        Self::insert_bundles(
+            &mut self.unprocessed_bundle_storage,
+            deserialized_bundles,
+            push_back,
+        )
+    }
+
+    /// Drains bundles from the queue, sanitizes them to prepare for execution, executes them by
+    /// calling `processing_function`, then potentially rebuffer them.
+    pub fn process_bundles<F>(
+        &mut self,
+        bank: Arc<Bank>,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+        blacklisted_accounts: &HashSet<Pubkey>,
+        mut processing_function: F,
+    ) -> bool
+    where
+        F: FnMut(
+            &[(ImmutableDeserializedBundle, SanitizedBundle)],
+            &mut BundleStageLeaderMetrics,
+        ) -> Vec<Result<(), BundleExecutionError>>,
+    {
+        let sanitized_bundles = self.drain_and_sanitize_bundles(
+            bank,
+            bundle_stage_leader_metrics,
+            blacklisted_accounts,
+        );
+
+        debug!("processing {} bundles", sanitized_bundles.len());
+        let bundle_execution_results =
+            processing_function(&sanitized_bundles, bundle_stage_leader_metrics);
+
+        let mut is_slot_over = false;
+
+        let mut rebuffered_bundles = Vec::new();
+
+        sanitized_bundles
+            .into_iter()
+            .zip(bundle_execution_results)
+            .for_each(
+                |((deserialized_bundle, sanitized_bundle), result)| match result {
+                    Ok(_) => {
+                        debug!("bundle={} executed ok", sanitized_bundle.bundle_id);
+                        // yippee
+                    }
+                    Err(BundleExecutionError::PohRecordError(e)) => {
+                        // buffer the bundle to the front of the queue to be attempted next slot
+                        debug!(
+                            "bundle={} poh record error: {e:?}",
+                            sanitized_bundle.bundle_id
+                        );
+                        rebuffered_bundles.push(deserialized_bundle);
+                        is_slot_over = true;
+                    }
+                    Err(BundleExecutionError::BankProcessingTimeLimitReached) => {
+                        // buffer the bundle to the front of the queue to be attempted next slot
+                        debug!("bundle={} bank processing done", sanitized_bundle.bundle_id);
+                        rebuffered_bundles.push(deserialized_bundle);
+                        is_slot_over = true;
+                    }
+                    Err(BundleExecutionError::TransactionFailure(e)) => {
+                        debug!(
+                            "bundle={} execution error: {:?}",
+                            sanitized_bundle.bundle_id, e
+                        );
+                        // do nothing
+                    }
+                    Err(BundleExecutionError::ExceedsCostModel) => {
+                        // cost model buffered bundles contain most recent bundles at the front of the queue
+                        debug!("bundle={} exceeds cost model", sanitized_bundle.bundle_id);
+                        self.push_back_cost_model_buffered_bundles(vec![deserialized_bundle]);
+                    }
+                    Err(BundleExecutionError::TipError(e)) => {
+                        debug!("bundle={} tip error: {}", sanitized_bundle.bundle_id, e);
+                        // Tip errors are _typically_ due to misconfiguration (except for poh record error, bank processing error, exceeds cost model)
+                        // in order to prevent buffering too many bundles, we'll just drop the bundle
+                    }
+                    Err(BundleExecutionError::LockError) => {
+                        // lock errors are irrecoverable due to malformed transactions
+                        debug!("bundle={} lock error", sanitized_bundle.bundle_id);
+                    }
+                },
+            );
+
+        // rebuffered bundles are pushed onto deque in reverse order so the first bundle is at the front
+        for bundle in rebuffered_bundles.into_iter().rev() {
+            self.push_front_unprocessed_bundles(vec![bundle]);
+        }
+
+        is_slot_over
+    }
+
+    /// Drains the unprocessed_bundle_storage, converting bundle packets into SanitizedBundles
+    fn drain_and_sanitize_bundles(
+        &mut self,
+        bank: Arc<Bank>,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+        blacklisted_accounts: &HashSet<Pubkey>,
+    ) -> Vec<(ImmutableDeserializedBundle, SanitizedBundle)> {
+        let mut error_metrics = TransactionErrorMetrics::default();
+
+        let start = Instant::now();
+
+        let mut sanitized_bundles = Vec::new();
+
+        // on new slot, drain anything that was buffered from last slot
+        if bank.slot() != self.last_update_slot {
+            sanitized_bundles.extend(
+                self.cost_model_buffered_bundle_storage
+                    .drain(..)
+                    .filter_map(|packet_bundle| {
+                        let r = packet_bundle.build_sanitized_bundle(
+                            &bank,
+                            blacklisted_accounts,
+                            &mut error_metrics,
+                        );
+                        bundle_stage_leader_metrics
+                            .bundle_stage_metrics_tracker()
+                            .increment_sanitize_transaction_result(&r);
+
+                        match r {
+                            Ok(sanitized_bundle) => Some((packet_bundle, sanitized_bundle)),
+                            Err(e) => {
+                                debug!(
+                                    "bundle id: {} error sanitizing: {}",
+                                    packet_bundle.bundle_id(),
+                                    e
+                                );
+                                None
+                            }
+                        }
+                    }),
+            );
+
+            self.last_update_slot = bank.slot();
+        }
+
+        sanitized_bundles.extend(self.unprocessed_bundle_storage.drain(..).filter_map(
+            |packet_bundle| {
+                let r = packet_bundle.build_sanitized_bundle(
+                    &bank,
+                    blacklisted_accounts,
+                    &mut error_metrics,
+                );
+                bundle_stage_leader_metrics
+                    .bundle_stage_metrics_tracker()
+                    .increment_sanitize_transaction_result(&r);
+                match r {
+                    Ok(sanitized_bundle) => Some((packet_bundle, sanitized_bundle)),
+                    Err(e) => {
+                        debug!(
+                            "bundle id: {} error sanitizing: {}",
+                            packet_bundle.bundle_id(),
+                            e
+                        );
+                        None
+                    }
+                }
+            },
+        ));
+
+        let elapsed = start.elapsed().as_micros();
+        bundle_stage_leader_metrics
+            .bundle_stage_metrics_tracker()
+            .increment_sanitize_bundle_elapsed_us(elapsed as u64);
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .increment_transactions_from_packets_us(elapsed as u64);
+
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .accumulate_transaction_errors(&error_metrics);
+
+        sanitized_bundles
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use {
@@ -1315,6 +1754,7 @@ mod tests {
                         .collect_vec(),
                 )
             },
+            &HashSet::default(),
         );
 
         // All packets should remain in the transaction storage
diff --git a/core/src/banking_trace.rs b/core/src/banking_trace.rs
index c2b3c38695d1..96358b245f92 100644
--- a/core/src/banking_trace.rs
+++ b/core/src/banking_trace.rs
@@ -321,6 +321,7 @@ impl BankingTracer {
     }
 }
 
+#[derive(Clone)]
 pub struct TracedSender {
     label: ChannelLabel,
     sender: Sender<BankingPacketBatch>,
diff --git a/core/src/bundle_stage.rs b/core/src/bundle_stage.rs
new file mode 100644
index 000000000000..e935529df505
--- /dev/null
+++ b/core/src/bundle_stage.rs
@@ -0,0 +1,434 @@
+//! The `bundle_stage` processes bundles, which are list of transactions to be executed
+//! sequentially and atomically.
+use {
+    crate::{
+        banking_stage::{
+            decision_maker::{BufferedPacketsDecision, DecisionMaker},
+            qos_service::QosService,
+            unprocessed_transaction_storage::UnprocessedTransactionStorage,
+        },
+        bundle_stage::{
+            bundle_account_locker::BundleAccountLocker, bundle_consumer::BundleConsumer,
+            bundle_packet_receiver::BundleReceiver,
+            bundle_reserved_space_manager::BundleReservedSpaceManager,
+            bundle_stage_leader_metrics::BundleStageLeaderMetrics, committer::Committer,
+        },
+        packet_bundle::PacketBundle,
+        proxy::block_engine_stage::BlockBuilderFeeInfo,
+        tip_manager::TipManager,
+    },
+    crossbeam_channel::{Receiver, RecvTimeoutError},
+    solana_cost_model::block_cost_limits::MAX_BLOCK_UNITS,
+    solana_gossip::cluster_info::ClusterInfo,
+    solana_ledger::blockstore_processor::TransactionStatusSender,
+    solana_measure::measure,
+    solana_poh::poh_recorder::PohRecorder,
+    solana_runtime::{
+        bank_forks::BankForks, prioritization_fee_cache::PrioritizationFeeCache,
+        vote_sender_types::ReplayVoteSender,
+    },
+    solana_sdk::timing::AtomicInterval,
+    std::{
+        sync::{
+            atomic::{AtomicBool, AtomicU64, Ordering},
+            Arc, Mutex, RwLock,
+        },
+        thread::{self, Builder, JoinHandle},
+        time::{Duration, Instant},
+    },
+};
+
+pub mod bundle_account_locker;
+mod bundle_consumer;
+mod bundle_packet_deserializer;
+mod bundle_packet_receiver;
+mod bundle_reserved_space_manager;
+pub(crate) mod bundle_stage_leader_metrics;
+mod committer;
+
+const MAX_BUNDLE_RETRY_DURATION: Duration = Duration::from_millis(10);
+const SLOT_BOUNDARY_CHECK_PERIOD: Duration = Duration::from_millis(10);
+
+// Stats emitted periodically
+#[derive(Default)]
+pub struct BundleStageLoopMetrics {
+    last_report: AtomicInterval,
+    id: u32,
+
+    // total received
+    num_bundles_received: AtomicU64,
+    num_packets_received: AtomicU64,
+
+    // newly buffered
+    newly_buffered_bundles_count: AtomicU64,
+
+    // currently buffered
+    current_buffered_bundles_count: AtomicU64,
+    current_buffered_packets_count: AtomicU64,
+
+    // buffered due to cost model
+    cost_model_buffered_bundles_count: AtomicU64,
+    cost_model_buffered_packets_count: AtomicU64,
+
+    // number of bundles dropped during insertion
+    num_bundles_dropped: AtomicU64,
+
+    // timings
+    receive_and_buffer_bundles_elapsed_us: AtomicU64,
+    process_buffered_bundles_elapsed_us: AtomicU64,
+}
+
+impl BundleStageLoopMetrics {
+    fn new(id: u32) -> Self {
+        BundleStageLoopMetrics {
+            id,
+            ..BundleStageLoopMetrics::default()
+        }
+    }
+
+    pub fn increment_num_bundles_received(&mut self, count: u64) {
+        self.num_bundles_received
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_num_packets_received(&mut self, count: u64) {
+        self.num_packets_received
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_newly_buffered_bundles_count(&mut self, count: u64) {
+        self.newly_buffered_bundles_count
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_current_buffered_bundles_count(&mut self, count: u64) {
+        self.current_buffered_bundles_count
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_current_buffered_packets_count(&mut self, count: u64) {
+        self.current_buffered_packets_count
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_cost_model_buffered_bundles_count(&mut self, count: u64) {
+        self.cost_model_buffered_bundles_count
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_cost_model_buffered_packets_count(&mut self, count: u64) {
+        self.cost_model_buffered_packets_count
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_num_bundles_dropped(&mut self, count: u64) {
+        self.num_bundles_dropped.fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_receive_and_buffer_bundles_elapsed_us(&mut self, count: u64) {
+        self.receive_and_buffer_bundles_elapsed_us
+            .fetch_add(count, Ordering::Relaxed);
+    }
+
+    pub fn increment_process_buffered_bundles_elapsed_us(&mut self, count: u64) {
+        self.process_buffered_bundles_elapsed_us
+            .fetch_add(count, Ordering::Relaxed);
+    }
+}
+
+impl BundleStageLoopMetrics {
+    fn maybe_report(&mut self, report_interval_ms: u64) {
+        if self.last_report.should_update(report_interval_ms) {
+            datapoint_info!(
+                "bundle_stage-loop_stats",
+                ("id", self.id, i64),
+                (
+                    "num_bundles_received",
+                    self.num_bundles_received.swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "num_packets_received",
+                    self.num_packets_received.swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "newly_buffered_bundles_count",
+                    self.newly_buffered_bundles_count.swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "current_buffered_bundles_count",
+                    self.current_buffered_bundles_count
+                        .swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "current_buffered_packets_count",
+                    self.current_buffered_packets_count
+                        .swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "num_bundles_dropped",
+                    self.num_bundles_dropped.swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "receive_and_buffer_bundles_elapsed_us",
+                    self.receive_and_buffer_bundles_elapsed_us
+                        .swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+                (
+                    "process_buffered_bundles_elapsed_us",
+                    self.process_buffered_bundles_elapsed_us
+                        .swap(0, Ordering::Acquire) as i64,
+                    i64
+                ),
+            );
+        }
+    }
+}
+
+pub struct BundleStage {
+    bundle_thread: JoinHandle<()>,
+}
+
+impl BundleStage {
+    #[allow(clippy::new_ret_no_self)]
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(
+        cluster_info: &Arc<ClusterInfo>,
+        poh_recorder: &Arc<RwLock<PohRecorder>>,
+        bundle_receiver: Receiver<Vec<PacketBundle>>,
+        transaction_status_sender: Option<TransactionStatusSender>,
+        replay_vote_sender: ReplayVoteSender,
+        log_messages_bytes_limit: Option<usize>,
+        exit: Arc<AtomicBool>,
+        tip_manager: TipManager,
+        bundle_account_locker: BundleAccountLocker,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        preallocated_bundle_cost: u64,
+        bank_forks: Arc<RwLock<BankForks>>,
+        prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
+    ) -> Self {
+        Self::start_bundle_thread(
+            cluster_info,
+            poh_recorder,
+            bundle_receiver,
+            transaction_status_sender,
+            replay_vote_sender,
+            log_messages_bytes_limit,
+            exit,
+            tip_manager,
+            bundle_account_locker,
+            MAX_BUNDLE_RETRY_DURATION,
+            block_builder_fee_info,
+            preallocated_bundle_cost,
+            bank_forks,
+            prioritization_fee_cache,
+        )
+    }
+
+    pub fn join(self) -> thread::Result<()> {
+        self.bundle_thread.join()
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    fn start_bundle_thread(
+        cluster_info: &Arc<ClusterInfo>,
+        poh_recorder: &Arc<RwLock<PohRecorder>>,
+        bundle_receiver: Receiver<Vec<PacketBundle>>,
+        transaction_status_sender: Option<TransactionStatusSender>,
+        replay_vote_sender: ReplayVoteSender,
+        log_message_bytes_limit: Option<usize>,
+        exit: Arc<AtomicBool>,
+        tip_manager: TipManager,
+        bundle_account_locker: BundleAccountLocker,
+        max_bundle_retry_duration: Duration,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        preallocated_bundle_cost: u64,
+        bank_forks: Arc<RwLock<BankForks>>,
+        prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
+    ) -> Self {
+        const BUNDLE_STAGE_ID: u32 = 10_000;
+        let poh_recorder = poh_recorder.clone();
+        let cluster_info = cluster_info.clone();
+
+        let mut bundle_receiver =
+            BundleReceiver::new(BUNDLE_STAGE_ID, bundle_receiver, bank_forks, Some(5));
+
+        let committer = Committer::new(
+            transaction_status_sender,
+            replay_vote_sender,
+            prioritization_fee_cache.clone(),
+        );
+        let decision_maker = DecisionMaker::new(cluster_info.id(), poh_recorder.clone());
+
+        let unprocessed_bundle_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let reserved_ticks = poh_recorder
+            .read()
+            .unwrap()
+            .ticks_per_slot()
+            .saturating_mul(8)
+            .saturating_div(10);
+
+        // The first 80% of the block, based on poh ticks, has `preallocated_bundle_cost` less compute units.
+        // The last 20% has has full compute so blockspace is maximized if BundleStage is idle.
+        let reserved_space = BundleReservedSpaceManager::new(
+            MAX_BLOCK_UNITS,
+            preallocated_bundle_cost,
+            reserved_ticks,
+        );
+
+        let consumer = BundleConsumer::new(
+            committer,
+            poh_recorder.read().unwrap().new_recorder(),
+            QosService::new(BUNDLE_STAGE_ID),
+            log_message_bytes_limit,
+            tip_manager,
+            bundle_account_locker,
+            block_builder_fee_info.clone(),
+            max_bundle_retry_duration,
+            cluster_info,
+            reserved_space,
+        );
+
+        let bundle_thread = Builder::new()
+            .name("solBundleStgTx".to_string())
+            .spawn(move || {
+                Self::process_loop(
+                    &mut bundle_receiver,
+                    decision_maker,
+                    consumer,
+                    BUNDLE_STAGE_ID,
+                    unprocessed_bundle_storage,
+                    exit,
+                );
+            })
+            .unwrap();
+
+        Self { bundle_thread }
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    fn process_loop(
+        bundle_receiver: &mut BundleReceiver,
+        decision_maker: DecisionMaker,
+        mut consumer: BundleConsumer,
+        id: u32,
+        mut unprocessed_bundle_storage: UnprocessedTransactionStorage,
+        exit: Arc<AtomicBool>,
+    ) {
+        let mut last_metrics_update = Instant::now();
+
+        let mut bundle_stage_metrics = BundleStageLoopMetrics::new(id);
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(id);
+
+        while !exit.load(Ordering::Relaxed) {
+            if !unprocessed_bundle_storage.is_empty()
+                || last_metrics_update.elapsed() >= SLOT_BOUNDARY_CHECK_PERIOD
+            {
+                let (_, process_buffered_packets_time) = measure!(
+                    Self::process_buffered_bundles(
+                        &decision_maker,
+                        &mut consumer,
+                        &mut unprocessed_bundle_storage,
+                        &mut bundle_stage_leader_metrics,
+                    ),
+                    "process_buffered_packets",
+                );
+                bundle_stage_leader_metrics
+                    .leader_slot_metrics_tracker()
+                    .increment_process_buffered_packets_us(process_buffered_packets_time.as_us());
+                last_metrics_update = Instant::now();
+            }
+
+            match bundle_receiver.receive_and_buffer_bundles(
+                &mut unprocessed_bundle_storage,
+                &mut bundle_stage_metrics,
+                &mut bundle_stage_leader_metrics,
+            ) {
+                Ok(_) | Err(RecvTimeoutError::Timeout) => (),
+                Err(RecvTimeoutError::Disconnected) => break,
+            }
+
+            let bundle_storage = unprocessed_bundle_storage.bundle_storage().unwrap();
+            bundle_stage_metrics.increment_current_buffered_bundles_count(
+                bundle_storage.unprocessed_bundles_len() as u64,
+            );
+            bundle_stage_metrics.increment_current_buffered_packets_count(
+                bundle_storage.unprocessed_packets_len() as u64,
+            );
+            bundle_stage_metrics.increment_cost_model_buffered_bundles_count(
+                bundle_storage.cost_model_buffered_bundles_len() as u64,
+            );
+            bundle_stage_metrics.increment_cost_model_buffered_packets_count(
+                bundle_storage.cost_model_buffered_packets_len() as u64,
+            );
+            bundle_stage_metrics.maybe_report(1_000);
+        }
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    fn process_buffered_bundles(
+        decision_maker: &DecisionMaker,
+        consumer: &mut BundleConsumer,
+        unprocessed_bundle_storage: &mut UnprocessedTransactionStorage,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) {
+        let (decision, make_decision_time) =
+            measure!(decision_maker.make_consume_or_forward_decision());
+
+        let (metrics_action, banking_stage_metrics_action) = bundle_stage_leader_metrics
+            .check_leader_slot_boundary(decision.bank_start(), Some(unprocessed_bundle_storage));
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .increment_make_decision_us(make_decision_time.as_us());
+
+        match decision {
+            // BufferedPacketsDecision::Consume means this leader is scheduled to be running at the moment.
+            // Execute, record, and commit as many bundles possible given time, compute, and other constraints.
+            BufferedPacketsDecision::Consume(bank_start) => {
+                // Take metrics action before consume packets (potentially resetting the
+                // slot metrics tracker to the next slot) so that we don't count the
+                // packet processing metrics from the next slot towards the metrics
+                // of the previous slot
+                bundle_stage_leader_metrics
+                    .apply_action(metrics_action, banking_stage_metrics_action);
+
+                let (_, consume_buffered_packets_time) = measure!(
+                    consumer.consume_buffered_bundles(
+                        &bank_start,
+                        unprocessed_bundle_storage,
+                        bundle_stage_leader_metrics,
+                    ),
+                    "consume_buffered_bundles",
+                );
+                bundle_stage_leader_metrics
+                    .leader_slot_metrics_tracker()
+                    .increment_consume_buffered_packets_us(consume_buffered_packets_time.as_us());
+            }
+            // BufferedPacketsDecision::Forward means the leader is slot is far away.
+            // Bundles aren't forwarded because it breaks atomicity guarantees, so just drop them.
+            BufferedPacketsDecision::Forward => {
+                let (_num_bundles_cleared, _num_cost_model_buffered_bundles) =
+                    unprocessed_bundle_storage.bundle_storage().unwrap().reset();
+
+                // TODO (LB): add metrics here for how many bundles were cleared
+
+                bundle_stage_leader_metrics
+                    .apply_action(metrics_action, banking_stage_metrics_action);
+            }
+            // BufferedPacketsDecision::ForwardAndHold | BufferedPacketsDecision::Hold means the validator
+            // is approaching the leader slot, hold bundles. Also, bundles aren't forwarded because it breaks
+            // atomicity guarantees
+            BufferedPacketsDecision::ForwardAndHold | BufferedPacketsDecision::Hold => {
+                bundle_stage_leader_metrics
+                    .apply_action(metrics_action, banking_stage_metrics_action);
+            }
+        }
+    }
+}
diff --git a/core/src/bundle_stage/bundle_account_locker.rs b/core/src/bundle_stage/bundle_account_locker.rs
new file mode 100644
index 000000000000..82070e3d3ade
--- /dev/null
+++ b/core/src/bundle_stage/bundle_account_locker.rs
@@ -0,0 +1,326 @@
+//! Handles pre-locking bundle accounts so that accounts bundles touch can be reserved ahead
+// of time for execution. Also, ensures that ALL accounts mentioned across a bundle are locked
+// to avoid race conditions between BundleStage and BankingStage.
+//
+// For instance, imagine a bundle with three transactions and the set of accounts for each transaction
+// is: {{A, B}, {B, C}, {C, D}}. We need to lock A, B, and C even though only one is executed at a time.
+// Imagine BundleStage is in the middle of processing {C, D} and we didn't have a lock on accounts {A, B, C}.
+// In this situation, there's a chance that BankingStage can process a transaction containing A or B
+// and commit the results before the bundle completes. By the time the bundle commits the new account
+// state for {A, B, C}, A and B would be incorrect and the entries containing the bundle would be
+// replayed improperly and that leader would have produced an invalid block.
+use {
+    solana_runtime::bank::Bank,
+    solana_sdk::{bundle::SanitizedBundle, pubkey::Pubkey, transaction::TransactionAccountLocks},
+    std::{
+        collections::{hash_map::Entry, HashMap, HashSet},
+        sync::{Arc, Mutex, MutexGuard},
+    },
+    thiserror::Error,
+};
+
+#[derive(Clone, Error, Debug)]
+pub enum BundleAccountLockerError {
+    #[error("locking error")]
+    LockingError,
+}
+
+pub type BundleAccountLockerResult<T> = Result<T, BundleAccountLockerError>;
+
+pub struct LockedBundle<'a, 'b> {
+    bundle_account_locker: &'a BundleAccountLocker,
+    sanitized_bundle: &'b SanitizedBundle,
+    bank: Arc<Bank>,
+}
+
+impl<'a, 'b> LockedBundle<'a, 'b> {
+    pub fn new(
+        bundle_account_locker: &'a BundleAccountLocker,
+        sanitized_bundle: &'b SanitizedBundle,
+        bank: &Arc<Bank>,
+    ) -> Self {
+        Self {
+            bundle_account_locker,
+            sanitized_bundle,
+            bank: bank.clone(),
+        }
+    }
+
+    pub fn sanitized_bundle(&self) -> &SanitizedBundle {
+        self.sanitized_bundle
+    }
+}
+
+// Automatically unlock bundle accounts when destructed
+impl<'a, 'b> Drop for LockedBundle<'a, 'b> {
+    fn drop(&mut self) {
+        let _ = self
+            .bundle_account_locker
+            .unlock_bundle_accounts(self.sanitized_bundle, &self.bank);
+    }
+}
+
+#[derive(Default, Clone)]
+pub struct BundleAccountLocks {
+    read_locks: HashMap<Pubkey, u64>,
+    write_locks: HashMap<Pubkey, u64>,
+}
+
+impl BundleAccountLocks {
+    pub fn read_locks(&self) -> HashSet<Pubkey> {
+        self.read_locks.keys().cloned().collect()
+    }
+
+    pub fn write_locks(&self) -> HashSet<Pubkey> {
+        self.write_locks.keys().cloned().collect()
+    }
+
+    pub fn lock_accounts(
+        &mut self,
+        read_locks: HashMap<Pubkey, u64>,
+        write_locks: HashMap<Pubkey, u64>,
+    ) {
+        for (acc, count) in read_locks {
+            *self.read_locks.entry(acc).or_insert(0) += count;
+        }
+        for (acc, count) in write_locks {
+            *self.write_locks.entry(acc).or_insert(0) += count;
+        }
+    }
+
+    pub fn unlock_accounts(
+        &mut self,
+        read_locks: HashMap<Pubkey, u64>,
+        write_locks: HashMap<Pubkey, u64>,
+    ) {
+        for (acc, count) in read_locks {
+            if let Entry::Occupied(mut entry) = self.read_locks.entry(acc) {
+                let val = entry.get_mut();
+                *val = val.saturating_sub(count);
+                if entry.get() == &0 {
+                    let _ = entry.remove();
+                }
+            } else {
+                warn!("error unlocking read-locked account, account: {:?}", acc);
+            }
+        }
+        for (acc, count) in write_locks {
+            if let Entry::Occupied(mut entry) = self.write_locks.entry(acc) {
+                let val = entry.get_mut();
+                *val = val.saturating_sub(count);
+                if entry.get() == &0 {
+                    let _ = entry.remove();
+                }
+            } else {
+                warn!("error unlocking write-locked account, account: {:?}", acc);
+            }
+        }
+    }
+}
+
+#[derive(Clone, Default)]
+pub struct BundleAccountLocker {
+    account_locks: Arc<Mutex<BundleAccountLocks>>,
+}
+
+impl BundleAccountLocker {
+    /// used in BankingStage during TransactionBatch construction to ensure that BankingStage
+    /// doesn't lock anything currently locked in the BundleAccountLocker
+    pub fn read_locks(&self) -> HashSet<Pubkey> {
+        self.account_locks.lock().unwrap().read_locks()
+    }
+
+    /// used in BankingStage during TransactionBatch construction to ensure that BankingStage
+    /// doesn't lock anything currently locked in the BundleAccountLocker
+    pub fn write_locks(&self) -> HashSet<Pubkey> {
+        self.account_locks.lock().unwrap().write_locks()
+    }
+
+    /// used in BankingStage during TransactionBatch construction to ensure that BankingStage
+    /// doesn't lock anything currently locked in the BundleAccountLocker
+    pub fn account_locks(&self) -> MutexGuard<BundleAccountLocks> {
+        self.account_locks.lock().unwrap()
+    }
+
+    /// Prepares a locked bundle and returns a LockedBundle containing locked accounts.
+    /// When a LockedBundle is dropped, the accounts are automatically unlocked
+    pub fn prepare_locked_bundle<'a, 'b>(
+        &'a self,
+        sanitized_bundle: &'b SanitizedBundle,
+        bank: &Arc<Bank>,
+    ) -> BundleAccountLockerResult<LockedBundle<'a, 'b>> {
+        let (read_locks, write_locks) = Self::get_read_write_locks(sanitized_bundle, bank)?;
+
+        self.account_locks
+            .lock()
+            .unwrap()
+            .lock_accounts(read_locks, write_locks);
+        Ok(LockedBundle::new(self, sanitized_bundle, bank))
+    }
+
+    /// Unlocks bundle accounts. Note that LockedBundle::drop will auto-drop the bundle account locks
+    fn unlock_bundle_accounts(
+        &self,
+        sanitized_bundle: &SanitizedBundle,
+        bank: &Bank,
+    ) -> BundleAccountLockerResult<()> {
+        let (read_locks, write_locks) = Self::get_read_write_locks(sanitized_bundle, bank)?;
+
+        self.account_locks
+            .lock()
+            .unwrap()
+            .unlock_accounts(read_locks, write_locks);
+        Ok(())
+    }
+
+    /// Returns the read and write locks for this bundle
+    /// Each lock type contains a HashMap which maps Pubkey to number of locks held
+    fn get_read_write_locks(
+        bundle: &SanitizedBundle,
+        bank: &Bank,
+    ) -> BundleAccountLockerResult<(HashMap<Pubkey, u64>, HashMap<Pubkey, u64>)> {
+        let transaction_locks: Vec<TransactionAccountLocks> = bundle
+            .transactions
+            .iter()
+            .filter_map(|tx| {
+                tx.get_account_locks(bank.get_transaction_account_lock_limit())
+                    .ok()
+            })
+            .collect();
+
+        if transaction_locks.len() != bundle.transactions.len() {
+            return Err(BundleAccountLockerError::LockingError);
+        }
+
+        let bundle_read_locks = transaction_locks
+            .iter()
+            .flat_map(|tx| tx.readonly.iter().map(|a| **a));
+        let bundle_read_locks =
+            bundle_read_locks
+                .into_iter()
+                .fold(HashMap::new(), |mut map, acc| {
+                    *map.entry(acc).or_insert(0) += 1;
+                    map
+                });
+
+        let bundle_write_locks = transaction_locks
+            .iter()
+            .flat_map(|tx| tx.writable.iter().map(|a| **a));
+        let bundle_write_locks =
+            bundle_write_locks
+                .into_iter()
+                .fold(HashMap::new(), |mut map, acc| {
+                    *map.entry(acc).or_insert(0) += 1;
+                    map
+                });
+
+        Ok((bundle_read_locks, bundle_write_locks))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        crate::{
+            bundle_stage::bundle_account_locker::BundleAccountLocker,
+            immutable_deserialized_bundle::ImmutableDeserializedBundle,
+            packet_bundle::PacketBundle,
+        },
+        solana_ledger::genesis_utils::create_genesis_config,
+        solana_perf::packet::PacketBatch,
+        solana_runtime::{bank::Bank, genesis_utils::GenesisConfigInfo},
+        solana_sdk::{
+            packet::Packet, signature::Signer, signer::keypair::Keypair, system_program,
+            system_transaction::transfer, transaction::VersionedTransaction,
+        },
+        solana_svm::transaction_error_metrics::TransactionErrorMetrics,
+        std::collections::HashSet,
+    };
+
+    #[test]
+    fn test_simple_lock_bundles() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(2);
+        let (bank, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let bundle_account_locker = BundleAccountLocker::default();
+
+        let kp0 = Keypair::new();
+        let kp1 = Keypair::new();
+
+        let tx0 = VersionedTransaction::from(transfer(
+            &mint_keypair,
+            &kp0.pubkey(),
+            1,
+            genesis_config.hash(),
+        ));
+        let tx1 = VersionedTransaction::from(transfer(
+            &mint_keypair,
+            &kp1.pubkey(),
+            1,
+            genesis_config.hash(),
+        ));
+
+        let mut packet_bundle0 = PacketBundle {
+            batch: PacketBatch::new(vec![Packet::from_data(None, &tx0).unwrap()]),
+            bundle_id: tx0.signatures[0].to_string(),
+        };
+        let mut packet_bundle1 = PacketBundle {
+            batch: PacketBatch::new(vec![Packet::from_data(None, &tx1).unwrap()]),
+            bundle_id: tx1.signatures[0].to_string(),
+        };
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+
+        let sanitized_bundle0 = ImmutableDeserializedBundle::new(&mut packet_bundle0, None)
+            .unwrap()
+            .build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors)
+            .expect("sanitize bundle 0");
+        let sanitized_bundle1 = ImmutableDeserializedBundle::new(&mut packet_bundle1, None)
+            .unwrap()
+            .build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors)
+            .expect("sanitize bundle 1");
+
+        let locked_bundle0 = bundle_account_locker
+            .prepare_locked_bundle(&sanitized_bundle0, &bank)
+            .unwrap();
+
+        assert_eq!(
+            bundle_account_locker.write_locks(),
+            HashSet::from_iter([mint_keypair.pubkey(), kp0.pubkey()])
+        );
+        assert_eq!(
+            bundle_account_locker.read_locks(),
+            HashSet::from_iter([system_program::id()])
+        );
+
+        let locked_bundle1 = bundle_account_locker
+            .prepare_locked_bundle(&sanitized_bundle1, &bank)
+            .unwrap();
+        assert_eq!(
+            bundle_account_locker.write_locks(),
+            HashSet::from_iter([mint_keypair.pubkey(), kp0.pubkey(), kp1.pubkey()])
+        );
+        assert_eq!(
+            bundle_account_locker.read_locks(),
+            HashSet::from_iter([system_program::id()])
+        );
+
+        drop(locked_bundle0);
+        assert_eq!(
+            bundle_account_locker.write_locks(),
+            HashSet::from_iter([mint_keypair.pubkey(), kp1.pubkey()])
+        );
+        assert_eq!(
+            bundle_account_locker.read_locks(),
+            HashSet::from_iter([system_program::id()])
+        );
+
+        drop(locked_bundle1);
+        assert!(bundle_account_locker.write_locks().is_empty());
+        assert!(bundle_account_locker.read_locks().is_empty());
+    }
+}
diff --git a/core/src/bundle_stage/bundle_consumer.rs b/core/src/bundle_stage/bundle_consumer.rs
new file mode 100644
index 000000000000..b8d71edaf6e0
--- /dev/null
+++ b/core/src/bundle_stage/bundle_consumer.rs
@@ -0,0 +1,1584 @@
+use {
+    crate::{
+        banking_stage::{
+            committer::CommitTransactionDetails, leader_slot_metrics::ProcessTransactionsSummary,
+            leader_slot_timing_metrics::LeaderExecuteAndCommitTimings, qos_service::QosService,
+            unprocessed_transaction_storage::UnprocessedTransactionStorage,
+        },
+        bundle_stage::{
+            bundle_account_locker::{BundleAccountLocker, LockedBundle},
+            bundle_reserved_space_manager::BundleReservedSpaceManager,
+            bundle_stage_leader_metrics::BundleStageLeaderMetrics,
+            committer::Committer,
+        },
+        consensus_cache_updater::ConsensusCacheUpdater,
+        immutable_deserialized_bundle::ImmutableDeserializedBundle,
+        proxy::block_engine_stage::BlockBuilderFeeInfo,
+        tip_manager::TipManager,
+    },
+    solana_bundle::{
+        bundle_execution::{load_and_execute_bundle, BundleExecutionMetrics},
+        BundleExecutionError, BundleExecutionResult, TipError,
+    },
+    solana_cost_model::transaction_cost::TransactionCost,
+    solana_gossip::cluster_info::ClusterInfo,
+    solana_measure::{measure, measure_us},
+    solana_poh::poh_recorder::{BankStart, RecordTransactionsSummary, TransactionRecorder},
+    solana_runtime::bank::Bank,
+    solana_sdk::{
+        bundle::SanitizedBundle,
+        clock::{Slot, MAX_PROCESSING_AGE},
+        pubkey::Pubkey,
+        transaction::{self},
+    },
+    solana_svm::transaction_error_metrics::TransactionErrorMetrics,
+    std::{
+        collections::HashSet,
+        sync::{Arc, Mutex},
+        time::{Duration, Instant},
+    },
+};
+
+pub struct ExecuteRecordCommitResult {
+    commit_transaction_details: Vec<CommitTransactionDetails>,
+    result: BundleExecutionResult<()>,
+    execution_metrics: BundleExecutionMetrics,
+    execute_and_commit_timings: LeaderExecuteAndCommitTimings,
+    transaction_error_counter: TransactionErrorMetrics,
+}
+
+pub struct BundleConsumer {
+    committer: Committer,
+    transaction_recorder: TransactionRecorder,
+    qos_service: QosService,
+    log_messages_bytes_limit: Option<usize>,
+
+    consensus_cache_updater: ConsensusCacheUpdater,
+
+    tip_manager: TipManager,
+    last_tip_update_slot: Slot,
+
+    blacklisted_accounts: HashSet<Pubkey>,
+
+    // Manages account locks across multiple transactions within a bundle to prevent race conditions
+    // with BankingStage
+    bundle_account_locker: BundleAccountLocker,
+
+    block_builder_fee_info: Arc<Mutex<BlockBuilderFeeInfo>>,
+
+    max_bundle_retry_duration: Duration,
+
+    cluster_info: Arc<ClusterInfo>,
+
+    reserved_space: BundleReservedSpaceManager,
+}
+
+impl BundleConsumer {
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(
+        committer: Committer,
+        transaction_recorder: TransactionRecorder,
+        qos_service: QosService,
+        log_messages_bytes_limit: Option<usize>,
+        tip_manager: TipManager,
+        bundle_account_locker: BundleAccountLocker,
+        block_builder_fee_info: Arc<Mutex<BlockBuilderFeeInfo>>,
+        max_bundle_retry_duration: Duration,
+        cluster_info: Arc<ClusterInfo>,
+        reserved_space: BundleReservedSpaceManager,
+    ) -> Self {
+        Self {
+            committer,
+            transaction_recorder,
+            qos_service,
+            log_messages_bytes_limit,
+            consensus_cache_updater: ConsensusCacheUpdater::default(),
+            tip_manager,
+            // MAX because sending tips during slot 0 in tests doesn't work
+            last_tip_update_slot: u64::MAX,
+            blacklisted_accounts: HashSet::default(),
+            bundle_account_locker,
+            block_builder_fee_info,
+            max_bundle_retry_duration,
+            cluster_info,
+            reserved_space,
+        }
+    }
+
+    // A bundle is a series of transactions to be executed sequentially, atomically, and all-or-nothing.
+    // Sequentially:
+    //  - Transactions are executed in order
+    // Atomically:
+    //  - All transactions in a bundle get recoded to PoH and committed to the bank in the same slot. Account locks
+    //  for all accounts in all transactions in a bundle are held during the entire execution to remove POH record race conditions
+    //  with transactions in BankingStage.
+    // All-or-nothing:
+    //  - All transactions are committed or none. Modified state for the entire bundle isn't recorded to PoH and committed to the
+    //  bank until all transactions in the bundle have executed.
+    //
+    // Some corner cases to be aware of when working with BundleStage:
+    // A bundle is not allowed to call the Tip Payment program in a bundle (or BankingStage).
+    // - This is to avoid stealing of tips by malicious parties with bundles that crank the tip
+    // payment program and set the tip receiver to themself.
+    // A bundle is not allowed to touch consensus-related accounts
+    //  - This is to avoid stalling the voting BankingStage threads.
+    pub fn consume_buffered_bundles(
+        &mut self,
+        bank_start: &BankStart,
+        unprocessed_transaction_storage: &mut UnprocessedTransactionStorage,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) {
+        self.maybe_update_blacklist(bank_start);
+        self.reserved_space.tick(&bank_start.working_bank);
+
+        let reached_end_of_slot = unprocessed_transaction_storage.process_bundles(
+            bank_start.working_bank.clone(),
+            bundle_stage_leader_metrics,
+            &self.blacklisted_accounts,
+            |bundles, bundle_stage_leader_metrics| {
+                Self::do_process_bundles(
+                    &self.bundle_account_locker,
+                    &self.tip_manager,
+                    &mut self.last_tip_update_slot,
+                    &self.cluster_info,
+                    &self.block_builder_fee_info,
+                    &self.committer,
+                    &self.transaction_recorder,
+                    &self.qos_service,
+                    &self.log_messages_bytes_limit,
+                    self.max_bundle_retry_duration,
+                    &self.reserved_space,
+                    bundles,
+                    bank_start,
+                    bundle_stage_leader_metrics,
+                )
+            },
+        );
+
+        if reached_end_of_slot {
+            bundle_stage_leader_metrics
+                .leader_slot_metrics_tracker()
+                .set_end_of_slot_unprocessed_buffer_len(
+                    unprocessed_transaction_storage.len() as u64
+                );
+        }
+    }
+
+    /// Blacklist is updated with the tip payment program + any consensus accounts.
+    fn maybe_update_blacklist(&mut self, bank_start: &BankStart) {
+        if self
+            .consensus_cache_updater
+            .maybe_update(&bank_start.working_bank)
+        {
+            self.blacklisted_accounts = self
+                .consensus_cache_updater
+                .consensus_accounts_cache()
+                .union(&HashSet::from_iter([self
+                    .tip_manager
+                    .tip_payment_program_id()]))
+                .cloned()
+                .collect();
+
+            debug!(
+                "updated blacklist with {} accounts",
+                self.blacklisted_accounts.len()
+            );
+        }
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    fn do_process_bundles(
+        bundle_account_locker: &BundleAccountLocker,
+        tip_manager: &TipManager,
+        last_tip_updated_slot: &mut Slot,
+        cluster_info: &Arc<ClusterInfo>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        committer: &Committer,
+        recorder: &TransactionRecorder,
+        qos_service: &QosService,
+        log_messages_bytes_limit: &Option<usize>,
+        max_bundle_retry_duration: Duration,
+        reserved_space: &BundleReservedSpaceManager,
+        bundles: &[(ImmutableDeserializedBundle, SanitizedBundle)],
+        bank_start: &BankStart,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) -> Vec<Result<(), BundleExecutionError>> {
+        // BundleAccountLocker holds RW locks for ALL accounts in ALL transactions within a single bundle.
+        // By pre-locking bundles before they're ready to be processed, it will prevent BankingStage from
+        // grabbing those locks so BundleStage can process as fast as possible.
+        // A LockedBundle is similar to TransactionBatch; once its dropped the locks are released.
+        #[allow(clippy::needless_collect)]
+        let (locked_bundle_results, locked_bundles_elapsed) = measure!(
+            bundles
+                .iter()
+                .map(|(_, sanitized_bundle)| {
+                    bundle_account_locker
+                        .prepare_locked_bundle(sanitized_bundle, &bank_start.working_bank)
+                })
+                .collect::<Vec<_>>(),
+            "locked_bundles_elapsed"
+        );
+        bundle_stage_leader_metrics
+            .bundle_stage_metrics_tracker()
+            .increment_locked_bundle_elapsed_us(locked_bundles_elapsed.as_us());
+
+        let (execution_results, execute_locked_bundles_elapsed) = measure!(locked_bundle_results
+            .into_iter()
+            .map(|r| match r {
+                Ok(locked_bundle) => {
+                    let (r, measure) = measure_us!(Self::process_bundle(
+                        bundle_account_locker,
+                        tip_manager,
+                        last_tip_updated_slot,
+                        cluster_info,
+                        block_builder_fee_info,
+                        committer,
+                        recorder,
+                        qos_service,
+                        log_messages_bytes_limit,
+                        max_bundle_retry_duration,
+                        reserved_space,
+                        &locked_bundle,
+                        bank_start,
+                        bundle_stage_leader_metrics,
+                    ));
+                    bundle_stage_leader_metrics
+                        .leader_slot_metrics_tracker()
+                        .increment_process_packets_transactions_us(measure);
+                    r
+                }
+                Err(_) => {
+                    Err(BundleExecutionError::LockError)
+                }
+            })
+            .collect::<Vec<_>>());
+
+        bundle_stage_leader_metrics
+            .bundle_stage_metrics_tracker()
+            .increment_execute_locked_bundles_elapsed_us(execute_locked_bundles_elapsed.as_us());
+        execution_results.iter().for_each(|result| {
+            bundle_stage_leader_metrics
+                .bundle_stage_metrics_tracker()
+                .increment_bundle_execution_result(result);
+        });
+
+        execution_results
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    fn process_bundle(
+        bundle_account_locker: &BundleAccountLocker,
+        tip_manager: &TipManager,
+        last_tip_updated_slot: &mut Slot,
+        cluster_info: &Arc<ClusterInfo>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        committer: &Committer,
+        recorder: &TransactionRecorder,
+        qos_service: &QosService,
+        log_messages_bytes_limit: &Option<usize>,
+        max_bundle_retry_duration: Duration,
+        reserved_space: &BundleReservedSpaceManager,
+        locked_bundle: &LockedBundle,
+        bank_start: &BankStart,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) -> Result<(), BundleExecutionError> {
+        if !Bank::should_bank_still_be_processing_txs(
+            &bank_start.bank_creation_time,
+            bank_start.working_bank.ns_per_slot,
+        ) {
+            return Err(BundleExecutionError::BankProcessingTimeLimitReached);
+        }
+
+        if bank_start.working_bank.slot() != *last_tip_updated_slot
+            && Self::bundle_touches_tip_pdas(
+                locked_bundle.sanitized_bundle(),
+                &tip_manager.get_tip_accounts(),
+            )
+        {
+            let start = Instant::now();
+            let result = Self::handle_tip_programs(
+                bundle_account_locker,
+                tip_manager,
+                cluster_info,
+                block_builder_fee_info,
+                committer,
+                recorder,
+                qos_service,
+                log_messages_bytes_limit,
+                max_bundle_retry_duration,
+                reserved_space,
+                bank_start,
+                bundle_stage_leader_metrics,
+            );
+
+            bundle_stage_leader_metrics
+                .bundle_stage_metrics_tracker()
+                .increment_change_tip_receiver_elapsed_us(start.elapsed().as_micros() as u64);
+
+            result?;
+
+            *last_tip_updated_slot = bank_start.working_bank.slot();
+        }
+
+        Self::update_qos_and_execute_record_commit_bundle(
+            committer,
+            recorder,
+            qos_service,
+            log_messages_bytes_limit,
+            max_bundle_retry_duration,
+            reserved_space,
+            locked_bundle.sanitized_bundle(),
+            bank_start,
+            bundle_stage_leader_metrics,
+        )?;
+
+        Ok(())
+    }
+
+    /// The validator needs to manage state on two programs related to tips
+    #[allow(clippy::too_many_arguments)]
+    fn handle_tip_programs(
+        bundle_account_locker: &BundleAccountLocker,
+        tip_manager: &TipManager,
+        cluster_info: &Arc<ClusterInfo>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        committer: &Committer,
+        recorder: &TransactionRecorder,
+        qos_service: &QosService,
+        log_messages_bytes_limit: &Option<usize>,
+        max_bundle_retry_duration: Duration,
+        reserved_space: &BundleReservedSpaceManager,
+        bank_start: &BankStart,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) -> Result<(), BundleExecutionError> {
+        debug!("handle_tip_programs");
+
+        // This will setup the tip payment and tip distribution program if they haven't been
+        // initialized yet, which is typically helpful for local validators. On mainnet and testnet,
+        // this code should never run.
+        let keypair = cluster_info.keypair().clone();
+        let initialize_tip_programs_bundle =
+            tip_manager.get_initialize_tip_programs_bundle(&bank_start.working_bank, &keypair);
+        if let Some(bundle) = initialize_tip_programs_bundle {
+            debug!(
+                "initializing tip programs with {} transactions, bundle id: {}",
+                bundle.transactions.len(),
+                bundle.bundle_id
+            );
+
+            let locked_init_tip_programs_bundle = bundle_account_locker
+                .prepare_locked_bundle(&bundle, &bank_start.working_bank)
+                .map_err(|_| BundleExecutionError::TipError(TipError::LockError))?;
+
+            Self::update_qos_and_execute_record_commit_bundle(
+                committer,
+                recorder,
+                qos_service,
+                log_messages_bytes_limit,
+                max_bundle_retry_duration,
+                reserved_space,
+                locked_init_tip_programs_bundle.sanitized_bundle(),
+                bank_start,
+                bundle_stage_leader_metrics,
+            )
+            .map_err(|e| {
+                bundle_stage_leader_metrics
+                    .bundle_stage_metrics_tracker()
+                    .increment_num_init_tip_account_errors(1);
+                error!(
+                    "bundle: {} error initializing tip programs: {:?}",
+                    locked_init_tip_programs_bundle.sanitized_bundle().bundle_id,
+                    e
+                );
+                BundleExecutionError::TipError(TipError::InitializeProgramsError)
+            })?;
+
+            bundle_stage_leader_metrics
+                .bundle_stage_metrics_tracker()
+                .increment_num_init_tip_account_ok(1);
+        }
+
+        // There are two frequently run internal cranks inside the jito-solana validator that have to do with managing MEV tips.
+        // One is initialize the TipDistributionAccount, which is a validator's "tip piggy bank" for an epoch
+        // The other is ensuring the tip_receiver is configured correctly to ensure tips are routed to the correct
+        // address. The validator must drain the tip accounts to the previous tip receiver before setting the tip receiver to
+        // themselves.
+
+        let kp = cluster_info.keypair().clone();
+        let tip_crank_bundle = tip_manager.get_tip_programs_crank_bundle(
+            &bank_start.working_bank,
+            &kp,
+            &block_builder_fee_info.lock().unwrap(),
+        )?;
+        debug!("tip_crank_bundle is_some: {}", tip_crank_bundle.is_some());
+
+        if let Some(bundle) = tip_crank_bundle {
+            info!(
+                "bundle id: {} cranking tip programs with {} transactions",
+                bundle.bundle_id,
+                bundle.transactions.len()
+            );
+
+            let locked_tip_crank_bundle = bundle_account_locker
+                .prepare_locked_bundle(&bundle, &bank_start.working_bank)
+                .map_err(|_| BundleExecutionError::TipError(TipError::LockError))?;
+
+            Self::update_qos_and_execute_record_commit_bundle(
+                committer,
+                recorder,
+                qos_service,
+                log_messages_bytes_limit,
+                max_bundle_retry_duration,
+                reserved_space,
+                locked_tip_crank_bundle.sanitized_bundle(),
+                bank_start,
+                bundle_stage_leader_metrics,
+            )
+            .map_err(|e| {
+                bundle_stage_leader_metrics
+                    .bundle_stage_metrics_tracker()
+                    .increment_num_change_tip_receiver_errors(1);
+                error!(
+                    "bundle: {} error cranking tip programs: {:?}",
+                    locked_tip_crank_bundle.sanitized_bundle().bundle_id,
+                    e
+                );
+                BundleExecutionError::TipError(TipError::CrankTipError)
+            })?;
+
+            bundle_stage_leader_metrics
+                .bundle_stage_metrics_tracker()
+                .increment_num_change_tip_receiver_ok(1);
+        }
+
+        Ok(())
+    }
+
+    /// Reserves space for the entire bundle up-front to ensure the entire bundle can execute.
+    /// Rolls back the reserved space if there's not enough blockspace for all transactions in the bundle.
+    fn reserve_bundle_blockspace(
+        qos_service: &QosService,
+        reserved_space: &BundleReservedSpaceManager,
+        sanitized_bundle: &SanitizedBundle,
+        bank: &Arc<Bank>,
+    ) -> BundleExecutionResult<(Vec<transaction::Result<TransactionCost>>, usize)> {
+        let mut write_cost_tracker = bank.write_cost_tracker().unwrap();
+
+        // set the block cost limit to the original block cost limit, run the select + accumulate
+        // then reset back to the expected block cost limit. this allows bundle stage to potentially
+        // increase block_compute_limits, allocate the space, and reset the block_cost_limits to
+        // the reserved space without BankingStage racing to allocate this extra reserved space
+        write_cost_tracker.set_block_cost_limit(reserved_space.block_cost_limit());
+        let (transaction_qos_cost_results, cost_model_throttled_transactions_count) = qos_service
+            .select_and_accumulate_transaction_costs(
+                bank,
+                &mut write_cost_tracker,
+                &sanitized_bundle.transactions,
+                std::iter::repeat(Ok(())),
+            );
+        write_cost_tracker.set_block_cost_limit(reserved_space.expected_block_cost_limits(bank));
+        drop(write_cost_tracker);
+
+        // rollback all transaction costs if it can't fit and
+        if transaction_qos_cost_results.iter().any(|c| c.is_err()) {
+            QosService::remove_or_update_costs(transaction_qos_cost_results.iter(), None, bank);
+            return Err(BundleExecutionError::ExceedsCostModel);
+        }
+
+        Ok((
+            transaction_qos_cost_results,
+            cost_model_throttled_transactions_count,
+        ))
+    }
+
+    fn update_qos_and_execute_record_commit_bundle(
+        committer: &Committer,
+        recorder: &TransactionRecorder,
+        qos_service: &QosService,
+        log_messages_bytes_limit: &Option<usize>,
+        max_bundle_retry_duration: Duration,
+        reserved_space: &BundleReservedSpaceManager,
+        sanitized_bundle: &SanitizedBundle,
+        bank_start: &BankStart,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) -> BundleExecutionResult<()> {
+        debug!(
+            "bundle: {} reserving blockspace for {} transactions",
+            sanitized_bundle.bundle_id,
+            sanitized_bundle.transactions.len()
+        );
+
+        let (
+            (transaction_qos_cost_results, _cost_model_throttled_transactions_count),
+            cost_model_elapsed_us,
+        ) = measure_us!(Self::reserve_bundle_blockspace(
+            qos_service,
+            reserved_space,
+            sanitized_bundle,
+            &bank_start.working_bank
+        )?);
+
+        debug!(
+            "bundle: {} executing, recording, and committing",
+            sanitized_bundle.bundle_id
+        );
+
+        let (result, process_transactions_us) = measure_us!(Self::execute_record_commit_bundle(
+            committer,
+            recorder,
+            log_messages_bytes_limit,
+            max_bundle_retry_duration,
+            sanitized_bundle,
+            bank_start,
+        ));
+
+        bundle_stage_leader_metrics
+            .bundle_stage_metrics_tracker()
+            .increment_num_execution_retries(result.execution_metrics.num_retries);
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .accumulate_transaction_errors(&result.transaction_error_counter);
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .increment_process_transactions_us(process_transactions_us);
+
+        let (cu, us) = result
+            .execute_and_commit_timings
+            .execute_timings
+            .accumulate_execute_units_and_time();
+        qos_service.accumulate_actual_execute_cu(cu);
+        qos_service.accumulate_actual_execute_time(us);
+
+        let num_committed = result
+            .commit_transaction_details
+            .iter()
+            .filter(|c| matches!(c, CommitTransactionDetails::Committed { .. }))
+            .count();
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .accumulate_process_transactions_summary(&ProcessTransactionsSummary {
+                reached_max_poh_height: matches!(
+                    result.result,
+                    Err(BundleExecutionError::BankProcessingTimeLimitReached)
+                        | Err(BundleExecutionError::PohRecordError(_))
+                ),
+                transactions_attempted_execution_count: sanitized_bundle.transactions.len(),
+                committed_transactions_count: num_committed,
+                // NOTE: this assumes that bundles are committed all-or-nothing
+                committed_transactions_with_successful_result_count: num_committed,
+                failed_commit_count: 0,
+                retryable_transaction_indexes: vec![],
+                cost_model_throttled_transactions_count: 0,
+                cost_model_us: cost_model_elapsed_us,
+                execute_and_commit_timings: result.execute_and_commit_timings,
+                error_counters: result.transaction_error_counter,
+                min_prioritization_fees: 0, // TODO (LB)
+                max_prioritization_fees: 0, // TODO (LB)
+            });
+
+        match result.result {
+            Ok(_) => {
+                QosService::remove_or_update_costs(
+                    transaction_qos_cost_results.iter(),
+                    Some(&result.commit_transaction_details),
+                    &bank_start.working_bank,
+                );
+
+                qos_service.report_metrics(bank_start.working_bank.slot());
+                Ok(())
+            }
+            Err(e) => {
+                // on bundle failure, none of the transactions are committed, so need to revert
+                // all compute reserved
+                QosService::remove_or_update_costs(
+                    transaction_qos_cost_results.iter(),
+                    None,
+                    &bank_start.working_bank,
+                );
+                qos_service.report_metrics(bank_start.working_bank.slot());
+
+                Err(e)
+            }
+        }
+    }
+
+    fn execute_record_commit_bundle(
+        committer: &Committer,
+        recorder: &TransactionRecorder,
+        log_messages_bytes_limit: &Option<usize>,
+        max_bundle_retry_duration: Duration,
+        sanitized_bundle: &SanitizedBundle,
+        bank_start: &BankStart,
+    ) -> ExecuteRecordCommitResult {
+        let transaction_status_sender_enabled = committer.transaction_status_sender_enabled();
+
+        let mut execute_and_commit_timings = LeaderExecuteAndCommitTimings::default();
+
+        debug!("bundle: {} executing", sanitized_bundle.bundle_id);
+        let default_accounts = vec![None; sanitized_bundle.transactions.len()];
+        let mut bundle_execution_results = load_and_execute_bundle(
+            &bank_start.working_bank,
+            sanitized_bundle,
+            MAX_PROCESSING_AGE,
+            &max_bundle_retry_duration,
+            transaction_status_sender_enabled,
+            log_messages_bytes_limit,
+            false,
+            None,
+            &default_accounts,
+            &default_accounts,
+        );
+
+        let execution_metrics = bundle_execution_results.metrics();
+
+        execute_and_commit_timings.collect_balances_us = execution_metrics.collect_balances_us;
+        execute_and_commit_timings.load_execute_us = execution_metrics.load_execute_us;
+        execute_and_commit_timings
+            .execute_timings
+            .accumulate(&execution_metrics.execute_timings);
+
+        let mut transaction_error_counter = TransactionErrorMetrics::default();
+        bundle_execution_results
+            .bundle_transaction_results()
+            .iter()
+            .for_each(|r| {
+                transaction_error_counter
+                    .accumulate(&r.load_and_execute_transactions_output().error_counters);
+            });
+
+        debug!(
+            "bundle: {} executed, is_ok: {}",
+            sanitized_bundle.bundle_id,
+            bundle_execution_results.result().is_ok()
+        );
+
+        // don't commit bundle if failure executing any part of the bundle
+        if let Err(e) = bundle_execution_results.result() {
+            return ExecuteRecordCommitResult {
+                commit_transaction_details: vec![],
+                result: Err(e.clone().into()),
+                execution_metrics,
+                execute_and_commit_timings,
+                transaction_error_counter,
+            };
+        }
+
+        let (executed_batches, execution_results_to_transactions_us) =
+            measure_us!(bundle_execution_results.executed_transaction_batches());
+
+        debug!(
+            "bundle: {} recording {} batches of {:?} transactions",
+            sanitized_bundle.bundle_id,
+            executed_batches.len(),
+            executed_batches
+                .iter()
+                .map(|b| b.len())
+                .collect::<Vec<usize>>()
+        );
+
+        let (freeze_lock, freeze_lock_us) = measure_us!(bank_start.working_bank.freeze_lock());
+        execute_and_commit_timings.freeze_lock_us = freeze_lock_us;
+
+        let (last_blockhash, lamports_per_signature) = bank_start
+            .working_bank
+            .last_blockhash_and_lamports_per_signature();
+
+        let (
+            RecordTransactionsSummary {
+                result: record_transactions_result,
+                record_transactions_timings,
+                starting_transaction_index,
+            },
+            record_us,
+        ) = measure_us!(
+            recorder.record_transactions(bank_start.working_bank.slot(), executed_batches)
+        );
+
+        execute_and_commit_timings.record_us = record_us;
+        execute_and_commit_timings.record_transactions_timings = record_transactions_timings;
+        execute_and_commit_timings
+            .record_transactions_timings
+            .execution_results_to_transactions_us = execution_results_to_transactions_us;
+
+        debug!(
+            "bundle: {} record result: {}",
+            sanitized_bundle.bundle_id,
+            record_transactions_result.is_ok()
+        );
+
+        // don't commit bundle if failed to record
+        if let Err(e) = record_transactions_result {
+            return ExecuteRecordCommitResult {
+                commit_transaction_details: vec![],
+                result: Err(e.into()),
+                execution_metrics,
+                execute_and_commit_timings,
+                transaction_error_counter,
+            };
+        }
+
+        // note: execute_and_commit_timings.commit_us handled inside this function
+        let (commit_us, commit_bundle_details) = committer.commit_bundle(
+            &mut bundle_execution_results,
+            last_blockhash,
+            lamports_per_signature,
+            starting_transaction_index,
+            &bank_start.working_bank,
+            &mut execute_and_commit_timings,
+        );
+        execute_and_commit_timings.commit_us = commit_us;
+
+        drop(freeze_lock);
+
+        // commit_bundle_details contains transactions that were and were not committed
+        // given the current implementation only executes, records, and commits bundles
+        // where all transactions executed, we can filter out the non-committed
+        // TODO (LB): does this make more sense in commit_bundle for future when failing bundles are accepted?
+        let commit_transaction_details = commit_bundle_details
+            .commit_transaction_details
+            .into_iter()
+            .flat_map(|commit_details| {
+                commit_details
+                    .into_iter()
+                    .filter(|d| matches!(d, CommitTransactionDetails::Committed { .. }))
+            })
+            .collect();
+        debug!(
+            "bundle: {} commit details: {:?}",
+            sanitized_bundle.bundle_id, commit_transaction_details
+        );
+
+        ExecuteRecordCommitResult {
+            commit_transaction_details,
+            result: Ok(()),
+            execution_metrics,
+            execute_and_commit_timings,
+            transaction_error_counter,
+        }
+    }
+
+    /// Returns true if any of the transactions in a bundle mention one of the tip PDAs
+    fn bundle_touches_tip_pdas(bundle: &SanitizedBundle, tip_pdas: &HashSet<Pubkey>) -> bool {
+        bundle.transactions.iter().any(|tx| {
+            tx.message()
+                .account_keys()
+                .iter()
+                .any(|a| tip_pdas.contains(a))
+        })
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        crate::{
+            bundle_stage::{
+                bundle_account_locker::BundleAccountLocker, bundle_consumer::BundleConsumer,
+                bundle_packet_deserializer::BundlePacketDeserializer,
+                bundle_reserved_space_manager::BundleReservedSpaceManager,
+                bundle_stage_leader_metrics::BundleStageLeaderMetrics, committer::Committer,
+                QosService, UnprocessedTransactionStorage,
+            },
+            packet_bundle::PacketBundle,
+            proxy::block_engine_stage::BlockBuilderFeeInfo,
+            tip_manager::{TipDistributionAccountConfig, TipManager, TipManagerConfig},
+        },
+        crossbeam_channel::{unbounded, Receiver},
+        jito_tip_distribution::sdk::derive_tip_distribution_account_address,
+        rand::{thread_rng, RngCore},
+        solana_cost_model::{block_cost_limits::MAX_BLOCK_UNITS, cost_model::CostModel},
+        solana_gossip::{cluster_info::ClusterInfo, contact_info::ContactInfo},
+        solana_ledger::{
+            blockstore::Blockstore, genesis_utils::create_genesis_config,
+            get_tmp_ledger_path_auto_delete, leader_schedule_cache::LeaderScheduleCache,
+        },
+        solana_perf::packet::PacketBatch,
+        solana_poh::{
+            poh_recorder::{PohRecorder, Record, WorkingBankEntry},
+            poh_service::PohService,
+        },
+        solana_program_test::programs::spl_programs,
+        solana_runtime::{
+            bank::Bank,
+            bank_forks::BankForks,
+            genesis_utils::{create_genesis_config_with_leader_ex, GenesisConfigInfo},
+            installed_scheduler_pool::BankWithScheduler,
+            prioritization_fee_cache::PrioritizationFeeCache,
+        },
+        solana_sdk::{
+            bundle::{derive_bundle_id, SanitizedBundle},
+            clock::MAX_PROCESSING_AGE,
+            fee_calculator::{FeeRateGovernor, DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE},
+            genesis_config::ClusterType,
+            hash::Hash,
+            native_token::sol_to_lamports,
+            packet::Packet,
+            poh_config::PohConfig,
+            pubkey::Pubkey,
+            rent::Rent,
+            signature::{Keypair, Signer},
+            system_transaction::transfer,
+            transaction::{SanitizedTransaction, TransactionError, VersionedTransaction},
+            vote::state::VoteState,
+        },
+        solana_streamer::socket::SocketAddrSpace,
+        solana_svm::{
+            account_loader::TransactionCheckResult,
+            transaction_error_metrics::TransactionErrorMetrics,
+        },
+        std::{
+            collections::HashSet,
+            str::FromStr,
+            sync::{
+                atomic::{AtomicBool, Ordering},
+                Arc, Mutex, RwLock,
+            },
+            thread::{Builder, JoinHandle},
+            time::Duration,
+        },
+    };
+
+    struct TestFixture {
+        genesis_config_info: GenesisConfigInfo,
+        leader_keypair: Keypair,
+        bank: Arc<Bank>,
+        exit: Arc<AtomicBool>,
+        poh_recorder: Arc<RwLock<PohRecorder>>,
+        poh_simulator: JoinHandle<()>,
+        entry_receiver: Receiver<WorkingBankEntry>,
+        bank_forks: Arc<RwLock<BankForks>>,
+    }
+
+    pub(crate) fn simulate_poh(
+        record_receiver: Receiver<Record>,
+        poh_recorder: &Arc<RwLock<PohRecorder>>,
+    ) -> JoinHandle<()> {
+        let poh_recorder = poh_recorder.clone();
+        let is_exited = poh_recorder.read().unwrap().is_exited.clone();
+        let tick_producer = Builder::new()
+            .name("solana-simulate_poh".to_string())
+            .spawn(move || loop {
+                PohService::read_record_receiver_and_process(
+                    &poh_recorder,
+                    &record_receiver,
+                    Duration::from_millis(10),
+                );
+                if is_exited.load(Ordering::Relaxed) {
+                    break;
+                }
+            });
+        tick_producer.unwrap()
+    }
+
+    pub fn create_test_recorder(
+        bank: &Arc<Bank>,
+        blockstore: Arc<Blockstore>,
+        poh_config: Option<PohConfig>,
+        leader_schedule_cache: Option<Arc<LeaderScheduleCache>>,
+    ) -> (
+        Arc<AtomicBool>,
+        Arc<RwLock<PohRecorder>>,
+        JoinHandle<()>,
+        Receiver<WorkingBankEntry>,
+    ) {
+        let leader_schedule_cache = match leader_schedule_cache {
+            Some(provided_cache) => provided_cache,
+            None => Arc::new(LeaderScheduleCache::new_from_bank(bank)),
+        };
+        let exit = Arc::new(AtomicBool::new(false));
+        let poh_config = poh_config.unwrap_or_default();
+
+        let (mut poh_recorder, entry_receiver, record_receiver) = PohRecorder::new(
+            bank.tick_height(),
+            bank.last_blockhash(),
+            bank.clone(),
+            Some((4, 4)),
+            bank.ticks_per_slot(),
+            blockstore,
+            &leader_schedule_cache,
+            &poh_config,
+            exit.clone(),
+        );
+        poh_recorder.set_bank(
+            BankWithScheduler::new_without_scheduler(bank.clone()),
+            false,
+        );
+
+        let poh_recorder = Arc::new(RwLock::new(poh_recorder));
+        let poh_simulator = simulate_poh(record_receiver, &poh_recorder);
+
+        (exit, poh_recorder, poh_simulator, entry_receiver)
+    }
+
+    fn create_test_fixture(mint_sol: u64) -> TestFixture {
+        let mint_keypair = Keypair::new();
+        let leader_keypair = Keypair::new();
+        let voting_keypair = Keypair::new();
+
+        let rent = Rent::default();
+
+        let mut genesis_config = create_genesis_config_with_leader_ex(
+            sol_to_lamports(mint_sol as f64),
+            &mint_keypair.pubkey(),
+            &leader_keypair.pubkey(),
+            &voting_keypair.pubkey(),
+            &solana_sdk::pubkey::new_rand(),
+            rent.minimum_balance(VoteState::size_of()) + sol_to_lamports(1_000_000.0),
+            sol_to_lamports(1_000_000.0),
+            FeeRateGovernor {
+                // Initialize with a non-zero fee
+                lamports_per_signature: DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE / 2,
+                ..FeeRateGovernor::default()
+            },
+            rent.clone(), // most tests don't expect rent
+            ClusterType::Development,
+            spl_programs(&rent),
+        );
+        genesis_config.ticks_per_slot *= 8;
+
+        // workaround for https://github.com/solana-labs/solana/issues/30085
+        // the test can deploy and use spl_programs in the genensis slot without waiting for the next one
+        let (bank, bank_forks) = Bank::new_with_bank_forks_for_tests(&genesis_config);
+
+        let bank = Arc::new(Bank::new_from_parent(bank, &Pubkey::default(), 1));
+
+        let ledger_path = get_tmp_ledger_path_auto_delete!();
+        let blockstore = Arc::new(
+            Blockstore::open(ledger_path.path())
+                .expect("Expected to be able to open database ledger"),
+        );
+
+        let (exit, poh_recorder, poh_simulator, entry_receiver) =
+            create_test_recorder(&bank, blockstore, Some(PohConfig::default()), None);
+
+        let validator_pubkey = voting_keypair.pubkey();
+        TestFixture {
+            genesis_config_info: GenesisConfigInfo {
+                genesis_config,
+                mint_keypair,
+                voting_keypair,
+                validator_pubkey,
+            },
+            leader_keypair,
+            bank,
+            bank_forks,
+            exit,
+            poh_recorder,
+            poh_simulator,
+            entry_receiver,
+        }
+    }
+
+    fn make_random_overlapping_bundles(
+        mint_keypair: &Keypair,
+        num_bundles: usize,
+        num_packets_per_bundle: usize,
+        hash: Hash,
+        max_transfer_amount: u64,
+    ) -> Vec<PacketBundle> {
+        let mut rng = thread_rng();
+
+        (0..num_bundles)
+            .map(|_| {
+                let transfers: Vec<_> = (0..num_packets_per_bundle)
+                    .map(|_| {
+                        VersionedTransaction::from(transfer(
+                            mint_keypair,
+                            &mint_keypair.pubkey(),
+                            rng.next_u64() % max_transfer_amount,
+                            hash,
+                        ))
+                    })
+                    .collect();
+                let bundle_id = derive_bundle_id(&transfers);
+
+                PacketBundle {
+                    batch: PacketBatch::new(
+                        transfers
+                            .iter()
+                            .map(|tx| Packet::from_data(None, tx).unwrap())
+                            .collect(),
+                    ),
+                    bundle_id,
+                }
+            })
+            .collect()
+    }
+
+    fn get_tip_manager(vote_account: &Pubkey) -> TipManager {
+        TipManager::new(TipManagerConfig {
+            tip_payment_program_id: Pubkey::from_str("T1pyyaTNZsKv2WcRAB8oVnk93mLJw2XzjtVYqCsaHqt")
+                .unwrap(),
+            tip_distribution_program_id: Pubkey::from_str(
+                "4R3gSG8BpU4t19KYj8CfnbtRpnT8gtk4dvTHxVRwc2r7",
+            )
+            .unwrap(),
+            tip_distribution_account_config: TipDistributionAccountConfig {
+                merkle_root_upload_authority: Pubkey::new_unique(),
+                vote_account: *vote_account,
+                commission_bps: 10,
+            },
+        })
+    }
+
+    /// Happy-path bundle execution w/ no tip management
+    #[test]
+    fn test_bundle_no_tip_success() {
+        solana_logger::setup();
+        let TestFixture {
+            genesis_config_info,
+            leader_keypair,
+            bank,
+            exit,
+            poh_recorder,
+            poh_simulator,
+            entry_receiver,
+            bank_forks: _bank_forks,
+        } = create_test_fixture(1_000_000);
+        let recorder = poh_recorder.read().unwrap().new_recorder();
+
+        let status = poh_recorder
+            .read()
+            .unwrap()
+            .reached_leader_slot(&leader_keypair.pubkey());
+        info!("status: {:?}", status);
+
+        let (replay_vote_sender, _replay_vote_receiver) = unbounded();
+        let committer = Committer::new(
+            None,
+            replay_vote_sender,
+            Arc::new(PrioritizationFeeCache::new(0u64)),
+        );
+
+        let block_builder_pubkey = Pubkey::new_unique();
+        let tip_manager = get_tip_manager(&genesis_config_info.voting_keypair.pubkey());
+        let block_builder_info = Arc::new(Mutex::new(BlockBuilderFeeInfo {
+            block_builder: block_builder_pubkey,
+            block_builder_commission: 10,
+        }));
+
+        let cluster_info = Arc::new(ClusterInfo::new(
+            ContactInfo::new(leader_keypair.pubkey(), 0, 0),
+            Arc::new(leader_keypair),
+            SocketAddrSpace::new(true),
+        ));
+
+        let mut consumer = BundleConsumer::new(
+            committer,
+            recorder,
+            QosService::new(1),
+            None,
+            tip_manager,
+            BundleAccountLocker::default(),
+            block_builder_info,
+            Duration::from_secs(10),
+            cluster_info,
+            BundleReservedSpaceManager::new(
+                MAX_BLOCK_UNITS,
+                3_000_000,
+                poh_recorder
+                    .read()
+                    .unwrap()
+                    .ticks_per_slot()
+                    .saturating_mul(8)
+                    .saturating_div(10),
+            ),
+        );
+
+        let bank_start = poh_recorder.read().unwrap().bank_start().unwrap();
+
+        let mut bundle_storage = UnprocessedTransactionStorage::new_bundle_storage();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(1);
+
+        let mut packet_bundles = make_random_overlapping_bundles(
+            &genesis_config_info.mint_keypair,
+            1,
+            3,
+            genesis_config_info.genesis_config.hash(),
+            10_000,
+        );
+        let deserialized_bundle = BundlePacketDeserializer::deserialize_bundle(
+            packet_bundles.get_mut(0).unwrap(),
+            false,
+            None,
+        )
+        .unwrap();
+        let mut error_metrics = TransactionErrorMetrics::default();
+        let sanitized_bundle = deserialized_bundle
+            .build_sanitized_bundle(
+                &bank_start.working_bank,
+                &HashSet::default(),
+                &mut error_metrics,
+            )
+            .unwrap();
+
+        let summary = bundle_storage.insert_bundles(vec![deserialized_bundle]);
+        assert_eq!(
+            summary.num_packets_inserted,
+            sanitized_bundle.transactions.len()
+        );
+        assert_eq!(summary.num_bundles_dropped, 0);
+        assert_eq!(summary.num_bundles_inserted, 1);
+
+        consumer.consume_buffered_bundles(
+            &bank_start,
+            &mut bundle_storage,
+            &mut bundle_stage_leader_metrics,
+        );
+
+        let mut transactions = Vec::new();
+        while let Ok(WorkingBankEntry {
+            bank: wbe_bank,
+            entries_ticks,
+        }) = entry_receiver.recv()
+        {
+            assert_eq!(bank.slot(), wbe_bank.slot());
+            for (entry, _) in entries_ticks {
+                if !entry.transactions.is_empty() {
+                    // transactions in this test are all overlapping, so each entry will contain 1 transaction
+                    assert_eq!(entry.transactions.len(), 1);
+                    transactions.extend(entry.transactions);
+                }
+            }
+            if transactions.len() == sanitized_bundle.transactions.len() {
+                break;
+            }
+        }
+
+        let bundle_versioned_transactions: Vec<_> = sanitized_bundle
+            .transactions
+            .iter()
+            .map(|tx| tx.to_versioned_transaction())
+            .collect();
+        assert_eq!(transactions, bundle_versioned_transactions);
+
+        let check_results = bank.check_transactions(
+            &sanitized_bundle.transactions,
+            &vec![Ok(()); sanitized_bundle.transactions.len()],
+            MAX_PROCESSING_AGE,
+            &mut error_metrics,
+        );
+
+        let expected_result: Vec<TransactionCheckResult> =
+            vec![Err(TransactionError::AlreadyProcessed); sanitized_bundle.transactions.len()];
+
+        assert_eq!(check_results, expected_result);
+
+        poh_recorder
+            .write()
+            .unwrap()
+            .is_exited
+            .store(true, Ordering::Relaxed);
+        exit.store(true, Ordering::Relaxed);
+        poh_simulator.join().unwrap();
+        // TODO (LB): cleanup blockstore
+    }
+
+    /// Happy-path bundle execution to ensure tip management works.
+    /// Tip management involves cranking setup bundles before executing the test bundle
+    #[test]
+    fn test_bundle_tip_program_setup_success() {
+        solana_logger::setup();
+        let TestFixture {
+            genesis_config_info,
+            leader_keypair,
+            bank,
+            exit,
+            poh_recorder,
+            poh_simulator,
+            entry_receiver,
+            bank_forks: _bank_forks,
+        } = create_test_fixture(1_000_000);
+        let recorder = poh_recorder.read().unwrap().new_recorder();
+
+        let (replay_vote_sender, _replay_vote_receiver) = unbounded();
+        let committer = Committer::new(
+            None,
+            replay_vote_sender,
+            Arc::new(PrioritizationFeeCache::new(0u64)),
+        );
+
+        let block_builder_pubkey = Pubkey::new_unique();
+        let tip_manager = get_tip_manager(&genesis_config_info.voting_keypair.pubkey());
+        let block_builder_info = Arc::new(Mutex::new(BlockBuilderFeeInfo {
+            block_builder: block_builder_pubkey,
+            block_builder_commission: 10,
+        }));
+
+        let cluster_info = Arc::new(ClusterInfo::new(
+            ContactInfo::new(leader_keypair.pubkey(), 0, 0),
+            Arc::new(leader_keypair),
+            SocketAddrSpace::new(true),
+        ));
+
+        let mut consumer = BundleConsumer::new(
+            committer,
+            recorder,
+            QosService::new(1),
+            None,
+            tip_manager.clone(),
+            BundleAccountLocker::default(),
+            block_builder_info,
+            Duration::from_secs(10),
+            cluster_info.clone(),
+            BundleReservedSpaceManager::new(
+                MAX_BLOCK_UNITS,
+                3_000_000,
+                poh_recorder
+                    .read()
+                    .unwrap()
+                    .ticks_per_slot()
+                    .saturating_mul(8)
+                    .saturating_div(10),
+            ),
+        );
+
+        let bank_start = poh_recorder.read().unwrap().bank_start().unwrap();
+
+        let mut bundle_storage = UnprocessedTransactionStorage::new_bundle_storage();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(1);
+        // MAIN LOGIC
+
+        // a bundle that tips the tip program
+        let tip_accounts = tip_manager.get_tip_accounts();
+        let tip_account = tip_accounts.iter().collect::<Vec<_>>()[0];
+        let mut packet_bundle = PacketBundle {
+            batch: PacketBatch::new(vec![Packet::from_data(
+                None,
+                transfer(
+                    &genesis_config_info.mint_keypair,
+                    tip_account,
+                    1,
+                    genesis_config_info.genesis_config.hash(),
+                ),
+            )
+            .unwrap()]),
+            bundle_id: "test_transfer".to_string(),
+        };
+
+        let deserialized_bundle =
+            BundlePacketDeserializer::deserialize_bundle(&mut packet_bundle, false, None).unwrap();
+        let mut error_metrics = TransactionErrorMetrics::default();
+        let sanitized_bundle = deserialized_bundle
+            .build_sanitized_bundle(
+                &bank_start.working_bank,
+                &HashSet::default(),
+                &mut error_metrics,
+            )
+            .unwrap();
+
+        let summary = bundle_storage.insert_bundles(vec![deserialized_bundle]);
+        assert_eq!(summary.num_bundles_inserted, 1);
+        assert_eq!(summary.num_packets_inserted, 1);
+        assert_eq!(summary.num_bundles_dropped, 0);
+
+        consumer.consume_buffered_bundles(
+            &bank_start,
+            &mut bundle_storage,
+            &mut bundle_stage_leader_metrics,
+        );
+
+        // its expected there are 3 transactions. One to initialize the tip program configuration, one to change the tip receiver,
+        // and another with the tip
+
+        let mut transactions = Vec::new();
+        while let Ok(WorkingBankEntry {
+            bank: wbe_bank,
+            entries_ticks,
+        }) = entry_receiver.recv()
+        {
+            assert_eq!(bank.slot(), wbe_bank.slot());
+            transactions.extend(entries_ticks.into_iter().flat_map(|(e, _)| e.transactions));
+            if transactions.len() == 5 {
+                break;
+            }
+        }
+
+        // tip management on the first bundle involves:
+        // calling initialize on the tip payment and tip distribution programs
+        // creating the tip distribution account for this validator's epoch (the MEV piggy bank)
+        // changing the tip receiver and block builder tx
+        // the original transfer that was sent
+        let keypair = cluster_info.keypair().clone();
+
+        assert_eq!(
+            transactions[0],
+            tip_manager
+                .initialize_tip_payment_program_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        assert_eq!(
+            transactions[1],
+            tip_manager
+                .initialize_tip_distribution_config_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        assert_eq!(
+            transactions[2],
+            tip_manager
+                .initialize_tip_distribution_account_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        // the first tip receiver + block builder are the initializer (keypair.pubkey()) as set by the
+        // TipPayment program during initialization
+        assert_eq!(
+            transactions[3],
+            tip_manager
+                .build_change_tip_receiver_and_block_builder_tx(
+                    &keypair.pubkey(),
+                    &derive_tip_distribution_account_address(
+                        &tip_manager.tip_distribution_program_id(),
+                        &genesis_config_info.validator_pubkey,
+                        bank_start.working_bank.epoch()
+                    )
+                    .0,
+                    &bank_start.working_bank,
+                    &keypair,
+                    &keypair.pubkey(),
+                    &block_builder_pubkey,
+                    10
+                )
+                .to_versioned_transaction()
+        );
+        assert_eq!(
+            transactions[4],
+            sanitized_bundle.transactions[0].to_versioned_transaction()
+        );
+
+        poh_recorder
+            .write()
+            .unwrap()
+            .is_exited
+            .store(true, Ordering::Relaxed);
+        exit.store(true, Ordering::Relaxed);
+        poh_simulator.join().unwrap();
+    }
+
+    #[test]
+    fn test_handle_tip_programs() {
+        solana_logger::setup();
+        let TestFixture {
+            genesis_config_info,
+            leader_keypair,
+            bank,
+            exit,
+            poh_recorder,
+            poh_simulator,
+            entry_receiver,
+            bank_forks: _bank_forks,
+        } = create_test_fixture(1_000_000);
+        let recorder = poh_recorder.read().unwrap().new_recorder();
+
+        let (replay_vote_sender, _replay_vote_receiver) = unbounded();
+        let committer = Committer::new(
+            None,
+            replay_vote_sender,
+            Arc::new(PrioritizationFeeCache::new(0u64)),
+        );
+
+        let block_builder_pubkey = Pubkey::new_unique();
+        let tip_manager = get_tip_manager(&genesis_config_info.voting_keypair.pubkey());
+        let block_builder_info = Arc::new(Mutex::new(BlockBuilderFeeInfo {
+            block_builder: block_builder_pubkey,
+            block_builder_commission: 10,
+        }));
+
+        let cluster_info = Arc::new(ClusterInfo::new(
+            ContactInfo::new(leader_keypair.pubkey(), 0, 0),
+            Arc::new(leader_keypair),
+            SocketAddrSpace::new(true),
+        ));
+
+        let bank_start = poh_recorder.read().unwrap().bank_start().unwrap();
+
+        let reserved_ticks = bank.max_tick_height().saturating_mul(8).saturating_div(10);
+
+        // The first 80% of the block, based on poh ticks, has `preallocated_bundle_cost` less compute units.
+        // The last 20% has has full compute so blockspace is maximized if BundleStage is idle.
+        let reserved_space =
+            BundleReservedSpaceManager::new(MAX_BLOCK_UNITS, 3_000_000, reserved_ticks);
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(1);
+        assert_matches!(
+            BundleConsumer::handle_tip_programs(
+                &BundleAccountLocker::default(),
+                &tip_manager,
+                &cluster_info,
+                &block_builder_info,
+                &committer,
+                &recorder,
+                &QosService::new(1),
+                &None,
+                Duration::from_secs(10),
+                &reserved_space,
+                &bank_start,
+                &mut bundle_stage_leader_metrics
+            ),
+            Ok(())
+        );
+
+        let mut transactions = Vec::new();
+        while let Ok(WorkingBankEntry {
+            bank: wbe_bank,
+            entries_ticks,
+        }) = entry_receiver.recv()
+        {
+            assert_eq!(bank.slot(), wbe_bank.slot());
+            transactions.extend(entries_ticks.into_iter().flat_map(|(e, _)| e.transactions));
+            if transactions.len() == 4 {
+                break;
+            }
+        }
+
+        let keypair = cluster_info.keypair().clone();
+        // expect to see initialize tip payment program, tip distribution program, initialize tip distribution account, change tip receiver + change block builder
+        assert_eq!(
+            transactions[0],
+            tip_manager
+                .initialize_tip_payment_program_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        assert_eq!(
+            transactions[1],
+            tip_manager
+                .initialize_tip_distribution_config_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        assert_eq!(
+            transactions[2],
+            tip_manager
+                .initialize_tip_distribution_account_tx(&bank, &keypair)
+                .to_versioned_transaction()
+        );
+        // the first tip receiver + block builder are the initializer (keypair.pubkey()) as set by the
+        // TipPayment program during initialization
+        assert_eq!(
+            transactions[3],
+            tip_manager
+                .build_change_tip_receiver_and_block_builder_tx(
+                    &keypair.pubkey(),
+                    &derive_tip_distribution_account_address(
+                        &tip_manager.tip_distribution_program_id(),
+                        &genesis_config_info.validator_pubkey,
+                        bank_start.working_bank.epoch()
+                    )
+                    .0,
+                    &bank_start.working_bank,
+                    &keypair,
+                    &keypair.pubkey(),
+                    &block_builder_pubkey,
+                    10
+                )
+                .to_versioned_transaction()
+        );
+
+        poh_recorder
+            .write()
+            .unwrap()
+            .is_exited
+            .store(true, Ordering::Relaxed);
+        exit.store(true, Ordering::Relaxed);
+        poh_simulator.join().unwrap();
+    }
+
+    #[test]
+    fn test_reserve_bundle_blockspace_success() {
+        let GenesisConfigInfo { genesis_config, .. } = create_genesis_config(10);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config));
+
+        let keypair1 = Keypair::new();
+        let keypair2 = Keypair::new();
+        let transfer_tx = SanitizedTransaction::from_transaction_for_tests(transfer(
+            &keypair1,
+            &keypair2.pubkey(),
+            1,
+            bank.parent_hash(),
+        ));
+        let sanitized_bundle = SanitizedBundle {
+            transactions: vec![transfer_tx],
+            bundle_id: String::default(),
+        };
+
+        let transfer_cost =
+            CostModel::calculate_cost(&sanitized_bundle.transactions[0], &bank.feature_set);
+
+        let qos_service = QosService::new(1);
+        let reserved_ticks = bank.max_tick_height().saturating_mul(8).saturating_div(10);
+
+        // The first 80% of the block, based on poh ticks, has `preallocated_bundle_cost` less compute units.
+        // The last 20% has has full compute so blockspace is maximized if BundleStage is idle.
+        let reserved_space =
+            BundleReservedSpaceManager::new(MAX_BLOCK_UNITS, 3_000_000, reserved_ticks);
+
+        assert!(BundleConsumer::reserve_bundle_blockspace(
+            &qos_service,
+            &reserved_space,
+            &sanitized_bundle,
+            &bank
+        )
+        .is_ok());
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost(),
+            transfer_cost.sum()
+        );
+    }
+
+    #[test]
+    fn test_reserve_bundle_blockspace_failure() {
+        let GenesisConfigInfo { genesis_config, .. } = create_genesis_config(10);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config));
+
+        let keypair1 = Keypair::new();
+        let keypair2 = Keypair::new();
+        let transfer_tx1 = SanitizedTransaction::from_transaction_for_tests(transfer(
+            &keypair1,
+            &keypair2.pubkey(),
+            1,
+            bank.parent_hash(),
+        ));
+        let transfer_tx2 = SanitizedTransaction::from_transaction_for_tests(transfer(
+            &keypair1,
+            &keypair2.pubkey(),
+            2,
+            bank.parent_hash(),
+        ));
+        let sanitized_bundle = SanitizedBundle {
+            transactions: vec![transfer_tx1, transfer_tx2],
+            bundle_id: String::default(),
+        };
+
+        // set block cost limit to 1 transfer transaction, try to process 2, should return an error
+        // and rollback block cost added
+        let transfer_cost =
+            CostModel::calculate_cost(&sanitized_bundle.transactions[0], &bank.feature_set);
+        bank.write_cost_tracker()
+            .unwrap()
+            .set_block_cost_limit(transfer_cost.sum());
+
+        let qos_service = QosService::new(1);
+        let reserved_ticks = bank.max_tick_height().saturating_mul(8).saturating_div(10);
+
+        // The first 80% of the block, based on poh ticks, has `preallocated_bundle_cost` less compute units.
+        // The last 20% has has full compute so blockspace is maximized if BundleStage is idle.
+        let reserved_space = BundleReservedSpaceManager::new(
+            bank.read_cost_tracker().unwrap().block_cost(),
+            50,
+            reserved_ticks,
+        );
+
+        assert!(BundleConsumer::reserve_bundle_blockspace(
+            &qos_service,
+            &reserved_space,
+            &sanitized_bundle,
+            &bank
+        )
+        .is_err());
+        assert_eq!(bank.read_cost_tracker().unwrap().block_cost(), 0);
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            bank.read_cost_tracker()
+                .unwrap()
+                .block_cost_limit()
+                .saturating_sub(50)
+        );
+    }
+}
diff --git a/core/src/bundle_stage/bundle_packet_deserializer.rs b/core/src/bundle_stage/bundle_packet_deserializer.rs
new file mode 100644
index 000000000000..563902722e41
--- /dev/null
+++ b/core/src/bundle_stage/bundle_packet_deserializer.rs
@@ -0,0 +1,271 @@
+//! Deserializes PacketBundles
+use {
+    crate::{
+        immutable_deserialized_bundle::{DeserializedBundleError, ImmutableDeserializedBundle},
+        packet_bundle::PacketBundle,
+    },
+    crossbeam_channel::{Receiver, RecvTimeoutError},
+    solana_runtime::bank_forks::BankForks,
+    solana_sdk::saturating_add_assign,
+    std::{
+        sync::{Arc, RwLock},
+        time::{Duration, Instant},
+    },
+};
+
+/// Results from deserializing packet batches.
+#[derive(Debug)]
+pub struct ReceiveBundleResults {
+    /// Deserialized bundles from all received bundle packets
+    pub deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+    /// Number of dropped bundles
+    pub num_dropped_bundles: usize,
+}
+
+pub struct BundlePacketDeserializer {
+    /// Receiver for bundle packets
+    bundle_packet_receiver: Receiver<Vec<PacketBundle>>,
+    /// Provides working bank for deserializer to check feature activation
+    bank_forks: Arc<RwLock<BankForks>>,
+    /// Max packets per bundle
+    max_packets_per_bundle: Option<usize>,
+}
+
+impl BundlePacketDeserializer {
+    pub fn new(
+        bundle_packet_receiver: Receiver<Vec<PacketBundle>>,
+        bank_forks: Arc<RwLock<BankForks>>,
+        max_packets_per_bundle: Option<usize>,
+    ) -> Self {
+        Self {
+            bundle_packet_receiver,
+            bank_forks,
+            max_packets_per_bundle,
+        }
+    }
+
+    /// Handles receiving bundles and deserializing them
+    pub fn receive_bundles(
+        &self,
+        recv_timeout: Duration,
+        capacity: usize,
+    ) -> Result<ReceiveBundleResults, RecvTimeoutError> {
+        let (bundle_count, _packet_count, mut bundles) =
+            self.receive_until(recv_timeout, capacity)?;
+
+        // Note: this can be removed after feature `round_compute_unit_price` is activated in
+        // mainnet-beta
+        let _working_bank = self.bank_forks.read().unwrap().working_bank();
+        let round_compute_unit_price_enabled = false; // TODO get from working_bank.feature_set
+
+        Ok(Self::deserialize_and_collect_bundles(
+            bundle_count,
+            &mut bundles,
+            round_compute_unit_price_enabled,
+            self.max_packets_per_bundle,
+        ))
+    }
+
+    /// Deserialize packet batches, aggregates tracer packet stats, and collect
+    /// them into ReceivePacketResults
+    fn deserialize_and_collect_bundles(
+        bundle_count: usize,
+        bundles: &mut [PacketBundle],
+        round_compute_unit_price_enabled: bool,
+        max_packets_per_bundle: Option<usize>,
+    ) -> ReceiveBundleResults {
+        let mut deserialized_bundles = Vec::with_capacity(bundle_count);
+        let mut num_dropped_bundles: usize = 0;
+
+        for bundle in bundles.iter_mut() {
+            match Self::deserialize_bundle(
+                bundle,
+                round_compute_unit_price_enabled,
+                max_packets_per_bundle,
+            ) {
+                Ok(deserialized_bundle) => {
+                    deserialized_bundles.push(deserialized_bundle);
+                }
+                Err(_) => {
+                    saturating_add_assign!(num_dropped_bundles, 1);
+                }
+            }
+        }
+
+        ReceiveBundleResults {
+            deserialized_bundles,
+            num_dropped_bundles,
+        }
+    }
+
+    /// Receives bundle packets
+    fn receive_until(
+        &self,
+        recv_timeout: Duration,
+        bundle_count_upperbound: usize,
+    ) -> Result<(usize, usize, Vec<PacketBundle>), RecvTimeoutError> {
+        let start = Instant::now();
+
+        let mut bundles = self.bundle_packet_receiver.recv_timeout(recv_timeout)?;
+        let mut num_packets_received: usize = bundles.iter().map(|pb| pb.batch.len()).sum();
+        let mut num_bundles_received: usize = bundles.len();
+
+        if num_bundles_received <= bundle_count_upperbound {
+            while let Ok(bundle_packets) = self.bundle_packet_receiver.try_recv() {
+                trace!("got more packet batches in bundle packet deserializer");
+
+                saturating_add_assign!(
+                    num_packets_received,
+                    bundle_packets
+                        .iter()
+                        .map(|pb| pb.batch.len())
+                        .sum::<usize>()
+                );
+                saturating_add_assign!(num_bundles_received, bundle_packets.len());
+
+                bundles.extend(bundle_packets);
+
+                if start.elapsed() >= recv_timeout
+                    || num_bundles_received >= bundle_count_upperbound
+                {
+                    break;
+                }
+            }
+        }
+
+        Ok((num_bundles_received, num_packets_received, bundles))
+    }
+
+    /// Deserializes the Bundle into DeserializedBundlePackets, returning None if any packet in the
+    /// bundle failed to deserialize
+    pub fn deserialize_bundle(
+        bundle: &mut PacketBundle,
+        round_compute_unit_price_enabled: bool,
+        max_packets_per_bundle: Option<usize>,
+    ) -> Result<ImmutableDeserializedBundle, DeserializedBundleError> {
+        bundle.batch.iter_mut().for_each(|p| {
+            p.meta_mut()
+                .set_round_compute_unit_price(round_compute_unit_price_enabled);
+        });
+
+        ImmutableDeserializedBundle::new(bundle, max_packets_per_bundle)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        super::*,
+        crossbeam_channel::unbounded,
+        solana_ledger::genesis_utils::create_genesis_config,
+        solana_perf::packet::PacketBatch,
+        solana_runtime::{bank::Bank, genesis_utils::GenesisConfigInfo},
+        solana_sdk::{packet::Packet, signature::Signer, system_transaction::transfer},
+    };
+
+    #[test]
+    fn test_deserialize_and_collect_bundles_empty() {
+        let results =
+            BundlePacketDeserializer::deserialize_and_collect_bundles(0, &mut [], false, Some(5));
+        assert_eq!(results.deserialized_bundles.len(), 0);
+        assert_eq!(results.num_dropped_bundles, 0);
+    }
+
+    #[test]
+    fn test_receive_bundles_capacity() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let (sender, receiver) = unbounded();
+
+        let deserializer = BundlePacketDeserializer::new(receiver, bank_forks, Some(10));
+
+        let packet_bundles: Vec<_> = (0..10)
+            .map(|_| PacketBundle {
+                batch: PacketBatch::new(vec![Packet::from_data(
+                    None,
+                    transfer(
+                        &mint_keypair,
+                        &mint_keypair.pubkey(),
+                        100,
+                        genesis_config.hash(),
+                    ),
+                )
+                .unwrap()]),
+                bundle_id: String::default(),
+            })
+            .collect();
+
+        sender.send(packet_bundles.clone()).unwrap();
+
+        let bundles = deserializer
+            .receive_bundles(Duration::from_millis(100), 5)
+            .unwrap();
+        // this is confusing, but it's sent as one batch
+        assert_eq!(bundles.deserialized_bundles.len(), 10);
+        assert_eq!(bundles.num_dropped_bundles, 0);
+
+        // make sure empty
+        assert_matches!(
+            deserializer.receive_bundles(Duration::from_millis(100), 5),
+            Err(RecvTimeoutError::Timeout)
+        );
+
+        // send 2x 10 size batches. capacity is 5, but will return 10 since that's the batch size
+        sender.send(packet_bundles.clone()).unwrap();
+        sender.send(packet_bundles).unwrap();
+        let bundles = deserializer
+            .receive_bundles(Duration::from_millis(100), 5)
+            .unwrap();
+        assert_eq!(bundles.deserialized_bundles.len(), 10);
+        assert_eq!(bundles.num_dropped_bundles, 0);
+
+        let bundles = deserializer
+            .receive_bundles(Duration::from_millis(100), 5)
+            .unwrap();
+        assert_eq!(bundles.deserialized_bundles.len(), 10);
+        assert_eq!(bundles.num_dropped_bundles, 0);
+
+        assert_matches!(
+            deserializer.receive_bundles(Duration::from_millis(100), 5),
+            Err(RecvTimeoutError::Timeout)
+        );
+    }
+
+    #[test]
+    fn test_receive_bundles_bad_bundles() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair: _,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let (sender, receiver) = unbounded();
+
+        let deserializer = BundlePacketDeserializer::new(receiver, bank_forks, Some(10));
+
+        let packet_bundles: Vec<_> = (0..10)
+            .map(|_| PacketBundle {
+                batch: PacketBatch::new(vec![]),
+                bundle_id: String::default(),
+            })
+            .collect();
+        sender.send(packet_bundles).unwrap();
+
+        let bundles = deserializer
+            .receive_bundles(Duration::from_millis(100), 5)
+            .unwrap();
+        // this is confusing, but it's sent as one batch
+        assert_eq!(bundles.deserialized_bundles.len(), 0);
+        assert_eq!(bundles.num_dropped_bundles, 10);
+    }
+}
diff --git a/core/src/bundle_stage/bundle_packet_receiver.rs b/core/src/bundle_stage/bundle_packet_receiver.rs
new file mode 100644
index 000000000000..c99d9aa02049
--- /dev/null
+++ b/core/src/bundle_stage/bundle_packet_receiver.rs
@@ -0,0 +1,825 @@
+use {
+    super::BundleStageLoopMetrics,
+    crate::{
+        banking_stage::unprocessed_transaction_storage::UnprocessedTransactionStorage,
+        bundle_stage::{
+            bundle_packet_deserializer::{BundlePacketDeserializer, ReceiveBundleResults},
+            bundle_stage_leader_metrics::BundleStageLeaderMetrics,
+        },
+        immutable_deserialized_bundle::ImmutableDeserializedBundle,
+        packet_bundle::PacketBundle,
+    },
+    crossbeam_channel::{Receiver, RecvTimeoutError},
+    solana_measure::{measure::Measure, measure_us},
+    solana_runtime::bank_forks::BankForks,
+    solana_sdk::timing::timestamp,
+    std::{
+        sync::{Arc, RwLock},
+        time::Duration,
+    },
+};
+
+pub struct BundleReceiver {
+    id: u32,
+    bundle_packet_deserializer: BundlePacketDeserializer,
+}
+
+impl BundleReceiver {
+    pub fn new(
+        id: u32,
+        bundle_packet_receiver: Receiver<Vec<PacketBundle>>,
+        bank_forks: Arc<RwLock<BankForks>>,
+        max_packets_per_bundle: Option<usize>,
+    ) -> Self {
+        Self {
+            id,
+            bundle_packet_deserializer: BundlePacketDeserializer::new(
+                bundle_packet_receiver,
+                bank_forks,
+                max_packets_per_bundle,
+            ),
+        }
+    }
+
+    /// Receive incoming packets, push into unprocessed buffer with packet indexes
+    pub fn receive_and_buffer_bundles(
+        &mut self,
+        unprocessed_bundle_storage: &mut UnprocessedTransactionStorage,
+        bundle_stage_metrics: &mut BundleStageLoopMetrics,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) -> Result<(), RecvTimeoutError> {
+        let (result, recv_time_us) = measure_us!({
+            let recv_timeout = Self::get_receive_timeout(unprocessed_bundle_storage);
+            let mut recv_and_buffer_measure = Measure::start("recv_and_buffer");
+            self.bundle_packet_deserializer
+                .receive_bundles(recv_timeout, unprocessed_bundle_storage.max_receive_size())
+                // Consumes results if Ok, otherwise we keep the Err
+                .map(|receive_bundle_results| {
+                    self.buffer_bundles(
+                        receive_bundle_results,
+                        unprocessed_bundle_storage,
+                        bundle_stage_metrics,
+                        // tracer_packet_stats,
+                        bundle_stage_leader_metrics,
+                    );
+                    recv_and_buffer_measure.stop();
+                    bundle_stage_metrics.increment_receive_and_buffer_bundles_elapsed_us(
+                        recv_and_buffer_measure.as_us(),
+                    );
+                })
+        });
+
+        bundle_stage_leader_metrics
+            .leader_slot_metrics_tracker()
+            .increment_receive_and_buffer_packets_us(recv_time_us);
+
+        result
+    }
+
+    fn get_receive_timeout(
+        unprocessed_transaction_storage: &UnprocessedTransactionStorage,
+    ) -> Duration {
+        // Gossip thread will almost always not wait because the transaction storage will most likely not be empty
+        if !unprocessed_transaction_storage.is_empty() {
+            // If there are buffered packets, run the equivalent of try_recv to try reading more
+            // packets. This prevents starving BankingStage::consume_buffered_packets due to
+            // buffered_packet_batches containing transactions that exceed the cost model for
+            // the current bank.
+            Duration::from_millis(0)
+        } else {
+            // BundleStage should pick up a working_bank as fast as possible
+            Duration::from_millis(100)
+        }
+    }
+
+    fn buffer_bundles(
+        &self,
+        ReceiveBundleResults {
+            deserialized_bundles,
+            num_dropped_bundles,
+        }: ReceiveBundleResults,
+        unprocessed_transaction_storage: &mut UnprocessedTransactionStorage,
+        bundle_stage_stats: &mut BundleStageLoopMetrics,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+    ) {
+        let bundle_count = deserialized_bundles.len();
+        let packet_count: usize = deserialized_bundles.iter().map(|b| b.len()).sum();
+
+        bundle_stage_stats.increment_num_bundles_received(bundle_count as u64);
+        bundle_stage_stats.increment_num_packets_received(packet_count as u64);
+        bundle_stage_stats.increment_num_bundles_dropped(num_dropped_bundles as u64);
+        // TODO (LB): fix this
+        // bundle_stage_leader_metrics
+        //     .leader_slot_metrics_tracker()
+        //     .increment_total_new_valid_packets(packet_count as u64);
+
+        debug!(
+            "@{:?} bundles: {} txs: {} id: {}",
+            timestamp(),
+            bundle_count,
+            packet_count,
+            self.id
+        );
+
+        Self::push_unprocessed(
+            unprocessed_transaction_storage,
+            deserialized_bundles,
+            bundle_stage_leader_metrics,
+            bundle_stage_stats,
+        );
+    }
+
+    fn push_unprocessed(
+        unprocessed_transaction_storage: &mut UnprocessedTransactionStorage,
+        deserialized_bundles: Vec<ImmutableDeserializedBundle>,
+        bundle_stage_leader_metrics: &mut BundleStageLeaderMetrics,
+        bundle_stage_stats: &mut BundleStageLoopMetrics,
+    ) {
+        if !deserialized_bundles.is_empty() {
+            let insert_bundles_summary =
+                unprocessed_transaction_storage.insert_bundles(deserialized_bundles);
+
+            bundle_stage_stats.increment_newly_buffered_bundles_count(
+                insert_bundles_summary.num_bundles_inserted as u64,
+            );
+            bundle_stage_stats
+                .increment_num_bundles_dropped(insert_bundles_summary.num_bundles_dropped as u64);
+
+            bundle_stage_leader_metrics
+                .leader_slot_metrics_tracker()
+                .increment_newly_buffered_packets_count(
+                    insert_bundles_summary.num_packets_inserted as u64,
+                );
+
+            bundle_stage_leader_metrics
+                .leader_slot_metrics_tracker()
+                .accumulate_insert_packet_batches_summary(
+                    &insert_bundles_summary.insert_packets_summary,
+                );
+        }
+    }
+}
+
+/// This tests functionality of BundlePacketReceiver and the internals of BundleStorage because
+/// they're tightly intertwined
+#[cfg(test)]
+mod tests {
+    use {
+        super::*,
+        crate::banking_stage::unprocessed_transaction_storage::BundleStorage,
+        crossbeam_channel::unbounded,
+        rand::{thread_rng, RngCore},
+        solana_bundle::{
+            bundle_execution::LoadAndExecuteBundleError, BundleExecutionError, TipError,
+        },
+        solana_ledger::genesis_utils::create_genesis_config,
+        solana_perf::packet::PacketBatch,
+        solana_poh::poh_recorder::PohRecorderError,
+        solana_runtime::{bank::Bank, genesis_utils::GenesisConfigInfo},
+        solana_sdk::{
+            bundle::{derive_bundle_id, SanitizedBundle},
+            hash::Hash,
+            packet::Packet,
+            signature::{Keypair, Signer},
+            system_transaction::transfer,
+            transaction::VersionedTransaction,
+        },
+        std::collections::HashSet,
+    };
+
+    /// Makes `num_bundles` random bundles with `num_packets_per_bundle` packets per bundle.
+    fn make_random_bundles(
+        mint_keypair: &Keypair,
+        num_bundles: usize,
+        num_packets_per_bundle: usize,
+        hash: Hash,
+    ) -> Vec<PacketBundle> {
+        let mut rng = thread_rng();
+
+        (0..num_bundles)
+            .map(|_| {
+                let transfers: Vec<_> = (0..num_packets_per_bundle)
+                    .map(|_| {
+                        VersionedTransaction::from(transfer(
+                            mint_keypair,
+                            &mint_keypair.pubkey(),
+                            rng.next_u64(),
+                            hash,
+                        ))
+                    })
+                    .collect();
+                let bundle_id = derive_bundle_id(&transfers);
+
+                PacketBundle {
+                    batch: PacketBatch::new(
+                        transfers
+                            .iter()
+                            .map(|tx| Packet::from_data(None, tx).unwrap())
+                            .collect(),
+                    ),
+                    bundle_id,
+                }
+            })
+            .collect()
+    }
+
+    fn assert_bundles_same(
+        packet_bundles: &[PacketBundle],
+        bundles_to_process: &[(ImmutableDeserializedBundle, SanitizedBundle)],
+    ) {
+        assert_eq!(packet_bundles.len(), bundles_to_process.len());
+        packet_bundles
+            .iter()
+            .zip(bundles_to_process.iter())
+            .for_each(|(packet_bundle, (_, sanitized_bundle))| {
+                assert_eq!(packet_bundle.bundle_id, sanitized_bundle.bundle_id);
+                assert_eq!(
+                    packet_bundle.batch.len(),
+                    sanitized_bundle.transactions.len()
+                );
+            });
+    }
+
+    #[test]
+    fn test_receive_bundles() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        let bundles = make_random_bundles(&mint_keypair, 10, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 10);
+        assert_eq!(bundle_storage.unprocessed_packets_len(), 20);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_packets_len(), 0);
+        assert_eq!(bundle_storage.max_receive_size(), 990);
+
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+                (0..bundles_to_process.len()).map(|_| Ok(())).collect()
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.unprocessed_packets_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_packets_len(), 0);
+        assert_eq!(bundle_storage.max_receive_size(), 1000);
+    }
+
+    #[test]
+    fn test_receive_more_bundles_than_capacity() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 more than capacity
+        let bundles = make_random_bundles(
+            &mint_keypair,
+            BundleStorage::BUNDLE_STORAGE_CAPACITY + 5,
+            2,
+            genesis_config.hash(),
+        );
+
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+        // 1005 bundles were sent, but the capacity is 1000
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 1000);
+        assert_eq!(bundle_storage.unprocessed_packets_len(), 2000);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_packets_len(), 0);
+
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                // make sure the first 1000 bundles are the ones to process
+                assert_bundles_same(
+                    &bundles[0..BundleStorage::BUNDLE_STORAGE_CAPACITY],
+                    bundles_to_process,
+                );
+                (0..bundles_to_process.len()).map(|_| Ok(())).collect()
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_poh_record_error_rebuffered() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let poh_max_height_reached_index = 3;
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        // make sure poh end of slot reached + the correct bundles are buffered for the next time.
+        // bundles at index 3 + 4 are rebuffered
+        assert!(bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+
+                let mut results = vec![Ok(()); bundles_to_process.len()];
+
+                (poh_max_height_reached_index..bundles_to_process.len()).for_each(|index| {
+                    results[index] = Err(BundleExecutionError::PohRecordError(
+                        PohRecorderError::MaxHeightReached,
+                    ));
+                });
+                results
+            }
+        ));
+
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 2);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles[poh_max_height_reached_index..], bundles_to_process);
+                vec![Ok(()); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_bank_processing_done_rebuffered() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bank_processing_done_index = 3;
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        // bundles at index 3 + 4 are rebuffered
+        assert!(bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+
+                let mut results = vec![Ok(()); bundles_to_process.len()];
+
+                (bank_processing_done_index..bundles_to_process.len()).for_each(|index| {
+                    results[index] = Err(BundleExecutionError::BankProcessingTimeLimitReached);
+                });
+                results
+            }
+        ));
+
+        // 0, 1, 2 processed; 3, 4 buffered
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 2);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles[bank_processing_done_index..], bundles_to_process);
+                vec![Ok(()); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_bank_execution_error_dropped() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+                vec![
+                    Err(BundleExecutionError::TransactionFailure(
+                        LoadAndExecuteBundleError::ProcessingTimeExceeded(Duration::from_secs(1)),
+                    ));
+                    bundles_to_process.len()
+                ]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_tip_error_dropped() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+                vec![
+                    Err(BundleExecutionError::TipError(TipError::LockError));
+                    bundles_to_process.len()
+                ]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_lock_error_dropped() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                vec![Err(BundleExecutionError::LockError); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_cost_model_exceeded_set_aside_and_requeued() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 5 bundles across the queue
+        let bundles = make_random_bundles(&mint_keypair, 5, 2, genesis_config.hash());
+        sender.send(bundles.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+
+        // buffered bundles are moved to cost model side deque
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles, bundles_to_process);
+                vec![Err(BundleExecutionError::ExceedsCostModel); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 5);
+
+        // double check there's no bundles to process
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert!(bundles_to_process.is_empty());
+                vec![Ok(()); bundles_to_process.len()]
+            }
+        ));
+
+        // create a new bank w/ new slot number, cost model buffered packets should move back onto queue
+        // in the same order they were originally
+        let bank = bank_forks.read().unwrap().working_bank();
+        let new_bank = Arc::new(Bank::new_from_parent(
+            bank.clone(),
+            bank.collector_id(),
+            bank.slot() + 1,
+        ));
+        assert!(!bundle_storage.process_bundles(
+            new_bank,
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                // make sure same order as original
+                assert_bundles_same(&bundles, bundles_to_process);
+                vec![Ok(()); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+    }
+
+    #[test]
+    fn test_process_bundles_cost_model_exceeded_buffer_capacity() {
+        solana_logger::setup();
+
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (_, bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let mut unprocessed_storage = UnprocessedTransactionStorage::new_bundle_storage();
+
+        let (sender, receiver) = unbounded();
+        let mut bundle_receiver = BundleReceiver::new(0, receiver, bank_forks.clone(), Some(5));
+
+        // send 500 bundles across the queue
+        let bundles0 = make_random_bundles(
+            &mint_keypair,
+            BundleStorage::BUNDLE_STORAGE_CAPACITY / 2,
+            2,
+            genesis_config.hash(),
+        );
+        sender.send(bundles0.clone()).unwrap();
+
+        let mut bundle_stage_stats = BundleStageLoopMetrics::default();
+        let mut bundle_stage_leader_metrics = BundleStageLeaderMetrics::new(0);
+
+        // receive and buffer bundles to the cost model reserve to test the capacity/dropped bundles there
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+        // buffered bundles are moved to cost model side deque
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles0, bundles_to_process);
+                vec![Err(BundleExecutionError::ExceedsCostModel); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 500);
+
+        let bundles1 = make_random_bundles(
+            &mint_keypair,
+            BundleStorage::BUNDLE_STORAGE_CAPACITY / 2,
+            2,
+            genesis_config.hash(),
+        );
+        sender.send(bundles1.clone()).unwrap();
+        // should get 500 more bundles, cost model buffered length should be 1000
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+        // buffered bundles are moved to cost model side deque
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles1, bundles_to_process);
+                vec![Err(BundleExecutionError::ExceedsCostModel); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 1000); // full now
+
+        // send 10 bundles to go over capacity
+        let bundles2 = make_random_bundles(&mint_keypair, 10, 2, genesis_config.hash());
+        sender.send(bundles2.clone()).unwrap();
+
+        // this set will get dropped from cost model buffered bundles
+        let result = bundle_receiver.receive_and_buffer_bundles(
+            &mut unprocessed_storage,
+            &mut bundle_stage_stats,
+            &mut bundle_stage_leader_metrics,
+        );
+        assert!(result.is_ok());
+
+        let bundle_storage = unprocessed_storage.bundle_storage().unwrap();
+        // buffered bundles are moved to cost model side deque, but its at capacity so stays the same size
+        assert!(!bundle_storage.process_bundles(
+            bank_forks.read().unwrap().working_bank(),
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                assert_bundles_same(&bundles2, bundles_to_process);
+                vec![Err(BundleExecutionError::ExceedsCostModel); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 1000);
+
+        // create new bank then call process_bundles again, expect to see [bundles1,bundles2]
+        let bank = bank_forks.read().unwrap().working_bank();
+        let new_bank = Arc::new(Bank::new_from_parent(
+            bank.clone(),
+            bank.collector_id(),
+            bank.slot() + 1,
+        ));
+        assert!(!bundle_storage.process_bundles(
+            new_bank,
+            &mut bundle_stage_leader_metrics,
+            &HashSet::default(),
+            |bundles_to_process, _stats| {
+                // make sure same order as original
+                let expected_bundles: Vec<_> =
+                    bundles0.iter().chain(bundles1.iter()).cloned().collect();
+                assert_bundles_same(&expected_bundles, bundles_to_process);
+                vec![Ok(()); bundles_to_process.len()]
+            }
+        ));
+        assert_eq!(bundle_storage.unprocessed_bundles_len(), 0);
+        assert_eq!(bundle_storage.cost_model_buffered_bundles_len(), 0);
+    }
+}
diff --git a/core/src/bundle_stage/bundle_reserved_space_manager.rs b/core/src/bundle_stage/bundle_reserved_space_manager.rs
new file mode 100644
index 000000000000..24cca76aa18d
--- /dev/null
+++ b/core/src/bundle_stage/bundle_reserved_space_manager.rs
@@ -0,0 +1,237 @@
+use {solana_runtime::bank::Bank, solana_sdk::clock::Slot, std::sync::Arc};
+
+/// Manager responsible for reserving `bundle_reserved_cost` during the first `reserved_ticks` of a bank
+/// and resetting the block cost limit to `block_cost_limit` after the reserved tick period is over
+pub struct BundleReservedSpaceManager {
+    // the bank's cost limit
+    block_cost_limit: u64,
+    // bundles get this much reserved space for the first reserved_ticks
+    bundle_reserved_cost: u64,
+    // a reduced block_compute_limit is reserved for this many ticks, afterwards it goes back to full cost
+    reserved_ticks: u64,
+    last_slot_updated: Slot,
+}
+
+impl BundleReservedSpaceManager {
+    pub fn new(block_cost_limit: u64, bundle_reserved_cost: u64, reserved_ticks: u64) -> Self {
+        Self {
+            block_cost_limit,
+            bundle_reserved_cost,
+            reserved_ticks,
+            last_slot_updated: u64::MAX,
+        }
+    }
+
+    /// Call this on creation of new bank and periodically while bundle processing
+    /// to manage the block_cost_limits
+    pub fn tick(&mut self, bank: &Arc<Bank>) {
+        if self.last_slot_updated == bank.slot() && !self.is_in_reserved_tick_period(bank) {
+            // new slot logic already ran, need to revert the block cost limit to original if
+            // ticks are past the reserved tick mark
+            debug!(
+                "slot: {} ticks: {}, resetting block_cost_limit to {}",
+                bank.slot(),
+                bank.tick_height(),
+                self.block_cost_limit
+            );
+            bank.write_cost_tracker()
+                .unwrap()
+                .set_block_cost_limit(self.block_cost_limit);
+        } else if self.last_slot_updated != bank.slot() && self.is_in_reserved_tick_period(bank) {
+            // new slot, if in the first max_tick - tick_height slots reserve space
+            // otherwise can leave the current block limit as is
+            let new_block_cost_limit = self.reduced_block_cost_limit();
+            debug!(
+                "slot: {} ticks: {}, reserving block_cost_limit with block_cost_limit of {}",
+                bank.slot(),
+                bank.tick_height(),
+                new_block_cost_limit
+            );
+            bank.write_cost_tracker()
+                .unwrap()
+                .set_block_cost_limit(new_block_cost_limit);
+            self.last_slot_updated = bank.slot();
+        }
+    }
+
+    /// return true if the bank is still in the period where block_cost_limits is reduced
+    pub fn is_in_reserved_tick_period(&self, bank: &Bank) -> bool {
+        bank.tick_height() % bank.ticks_per_slot() < self.reserved_ticks
+    }
+
+    /// return the block_cost_limits as determined by the tick height of the bank
+    pub fn expected_block_cost_limits(&self, bank: &Bank) -> u64 {
+        if self.is_in_reserved_tick_period(bank) {
+            self.reduced_block_cost_limit()
+        } else {
+            self.block_cost_limit()
+        }
+    }
+
+    pub fn reduced_block_cost_limit(&self) -> u64 {
+        self.block_cost_limit
+            .saturating_sub(self.bundle_reserved_cost)
+    }
+
+    pub fn block_cost_limit(&self) -> u64 {
+        self.block_cost_limit
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        crate::bundle_stage::bundle_reserved_space_manager::BundleReservedSpaceManager,
+        solana_ledger::genesis_utils::create_genesis_config, solana_runtime::bank::Bank,
+        solana_sdk::pubkey::Pubkey, std::sync::Arc,
+    };
+
+    #[test]
+    fn test_reserve_block_cost_limits_during_reserved_ticks() {
+        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
+
+        let genesis_config_info = create_genesis_config(100);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));
+
+        let block_cost_limits = bank.read_cost_tracker().unwrap().block_cost_limit();
+
+        let mut reserved_space = BundleReservedSpaceManager::new(
+            block_cost_limits,
+            BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
+            5,
+        );
+        reserved_space.tick(&bank);
+
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            block_cost_limits - BUNDLE_BLOCK_COST_LIMITS_RESERVATION
+        );
+    }
+
+    #[test]
+    fn test_dont_reserve_block_cost_limits_after_reserved_ticks() {
+        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
+
+        let genesis_config_info = create_genesis_config(100);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));
+
+        let block_cost_limits = bank.read_cost_tracker().unwrap().block_cost_limit();
+
+        for _ in 0..5 {
+            bank.register_default_tick_for_test();
+        }
+
+        let mut reserved_space = BundleReservedSpaceManager::new(
+            block_cost_limits,
+            BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
+            5,
+        );
+        reserved_space.tick(&bank);
+
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            block_cost_limits
+        );
+    }
+
+    #[test]
+    fn test_dont_reset_block_cost_limits_during_reserved_ticks() {
+        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
+
+        let genesis_config_info = create_genesis_config(100);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));
+
+        let block_cost_limits = bank.read_cost_tracker().unwrap().block_cost_limit();
+
+        let mut reserved_space = BundleReservedSpaceManager::new(
+            block_cost_limits,
+            BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
+            5,
+        );
+
+        reserved_space.tick(&bank);
+        bank.register_default_tick_for_test();
+        reserved_space.tick(&bank);
+
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            block_cost_limits - BUNDLE_BLOCK_COST_LIMITS_RESERVATION
+        );
+    }
+
+    #[test]
+    fn test_reset_block_cost_limits_after_reserved_ticks() {
+        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
+
+        let genesis_config_info = create_genesis_config(100);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));
+
+        let block_cost_limits = bank.read_cost_tracker().unwrap().block_cost_limit();
+
+        let mut reserved_space = BundleReservedSpaceManager::new(
+            block_cost_limits,
+            BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
+            5,
+        );
+
+        reserved_space.tick(&bank);
+
+        for _ in 0..5 {
+            bank.register_default_tick_for_test();
+        }
+        reserved_space.tick(&bank);
+
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            block_cost_limits
+        );
+    }
+
+    #[test]
+    fn test_block_limits_after_first_slot() {
+        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
+        const RESERVED_TICKS: u64 = 5;
+        let genesis_config_info = create_genesis_config(100);
+        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));
+
+        for _ in 0..genesis_config_info.genesis_config.ticks_per_slot {
+            bank.register_default_tick_for_test();
+        }
+        assert!(bank.is_complete());
+        bank.freeze();
+        assert_eq!(
+            bank.read_cost_tracker().unwrap().block_cost_limit(),
+            solana_cost_model::block_cost_limits::MAX_BLOCK_UNITS,
+        );
+
+        let bank1 = Arc::new(Bank::new_from_parent(bank.clone(), &Pubkey::default(), 1));
+        assert_eq!(bank1.slot(), 1);
+        assert_eq!(bank1.tick_height(), 64);
+        assert_eq!(bank1.max_tick_height(), 128);
+
+        // reserve space
+        let block_cost_limits = bank1.read_cost_tracker().unwrap().block_cost_limit();
+        let mut reserved_space = BundleReservedSpaceManager::new(
+            block_cost_limits,
+            BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
+            RESERVED_TICKS,
+        );
+        reserved_space.tick(&bank1);
+
+        // wait for reservation to be over
+        (0..RESERVED_TICKS).for_each(|_| {
+            bank1.register_default_tick_for_test();
+            assert_eq!(
+                bank1.read_cost_tracker().unwrap().block_cost_limit(),
+                block_cost_limits - BUNDLE_BLOCK_COST_LIMITS_RESERVATION
+            );
+        });
+        reserved_space.tick(&bank1);
+
+        // after reservation, revert back to normal limit
+        assert_eq!(
+            bank1.read_cost_tracker().unwrap().block_cost_limit(),
+            solana_cost_model::block_cost_limits::MAX_BLOCK_UNITS,
+        );
+    }
+}
diff --git a/core/src/bundle_stage/bundle_stage_leader_metrics.rs b/core/src/bundle_stage/bundle_stage_leader_metrics.rs
new file mode 100644
index 000000000000..97bbe7ac2971
--- /dev/null
+++ b/core/src/bundle_stage/bundle_stage_leader_metrics.rs
@@ -0,0 +1,506 @@
+use {
+    crate::{
+        banking_stage::{
+            leader_slot_metrics::{self, LeaderSlotMetricsTracker},
+            unprocessed_transaction_storage::UnprocessedTransactionStorage,
+        },
+        immutable_deserialized_bundle::DeserializedBundleError,
+    },
+    solana_bundle::{bundle_execution::LoadAndExecuteBundleError, BundleExecutionError},
+    solana_poh::poh_recorder::BankStart,
+    solana_sdk::{bundle::SanitizedBundle, clock::Slot, saturating_add_assign},
+};
+
+pub struct BundleStageLeaderMetrics {
+    bundle_stage_metrics_tracker: BundleStageStatsMetricsTracker,
+    leader_slot_metrics_tracker: LeaderSlotMetricsTracker,
+}
+
+pub(crate) enum MetricsTrackerAction {
+    Noop,
+    ReportAndResetTracker,
+    NewTracker(Option<BundleStageStats>),
+    ReportAndNewTracker(Option<BundleStageStats>),
+}
+
+impl BundleStageLeaderMetrics {
+    pub fn new(id: u32) -> Self {
+        Self {
+            bundle_stage_metrics_tracker: BundleStageStatsMetricsTracker::new(id),
+            leader_slot_metrics_tracker: LeaderSlotMetricsTracker::new(id),
+        }
+    }
+
+    pub(crate) fn check_leader_slot_boundary(
+        &mut self,
+        bank_start: Option<&BankStart>,
+        unprocessed_transaction_storage: Option<&UnprocessedTransactionStorage>,
+    ) -> (
+        leader_slot_metrics::MetricsTrackerAction,
+        MetricsTrackerAction,
+    ) {
+        let banking_stage_metrics_action = self
+            .leader_slot_metrics_tracker
+            .check_leader_slot_boundary(bank_start, unprocessed_transaction_storage);
+        let bundle_stage_metrics_action = self
+            .bundle_stage_metrics_tracker
+            .check_leader_slot_boundary(bank_start);
+        (banking_stage_metrics_action, bundle_stage_metrics_action)
+    }
+
+    pub(crate) fn apply_action(
+        &mut self,
+        banking_stage_metrics_action: leader_slot_metrics::MetricsTrackerAction,
+        bundle_stage_metrics_action: MetricsTrackerAction,
+    ) -> Option<Slot> {
+        self.leader_slot_metrics_tracker
+            .apply_action(banking_stage_metrics_action);
+        self.bundle_stage_metrics_tracker
+            .apply_action(bundle_stage_metrics_action)
+    }
+
+    pub fn leader_slot_metrics_tracker(&mut self) -> &mut LeaderSlotMetricsTracker {
+        &mut self.leader_slot_metrics_tracker
+    }
+
+    pub fn bundle_stage_metrics_tracker(&mut self) -> &mut BundleStageStatsMetricsTracker {
+        &mut self.bundle_stage_metrics_tracker
+    }
+}
+
+pub struct BundleStageStatsMetricsTracker {
+    bundle_stage_metrics: Option<BundleStageStats>,
+    id: u32,
+}
+
+impl BundleStageStatsMetricsTracker {
+    pub fn new(id: u32) -> Self {
+        Self {
+            bundle_stage_metrics: None,
+            id,
+        }
+    }
+
+    /// Similar to as LeaderSlotMetricsTracker::check_leader_slot_boundary
+    pub(crate) fn check_leader_slot_boundary(
+        &mut self,
+        bank_start: Option<&BankStart>,
+    ) -> MetricsTrackerAction {
+        match (self.bundle_stage_metrics.as_mut(), bank_start) {
+            (None, None) => MetricsTrackerAction::Noop,
+            (Some(_), None) => MetricsTrackerAction::ReportAndResetTracker,
+            // Our leader slot has begun, time to create a new slot tracker
+            (None, Some(bank_start)) => MetricsTrackerAction::NewTracker(Some(
+                BundleStageStats::new(self.id, bank_start.working_bank.slot()),
+            )),
+            (Some(bundle_stage_metrics), Some(bank_start)) => {
+                if bundle_stage_metrics.slot != bank_start.working_bank.slot() {
+                    // Last slot has ended, new slot has began
+                    MetricsTrackerAction::ReportAndNewTracker(Some(BundleStageStats::new(
+                        self.id,
+                        bank_start.working_bank.slot(),
+                    )))
+                } else {
+                    MetricsTrackerAction::Noop
+                }
+            }
+        }
+    }
+
+    /// Similar to LeaderSlotMetricsTracker::apply_action
+    pub(crate) fn apply_action(&mut self, action: MetricsTrackerAction) -> Option<Slot> {
+        match action {
+            MetricsTrackerAction::Noop => None,
+            MetricsTrackerAction::ReportAndResetTracker => {
+                let mut reported_slot = None;
+                if let Some(bundle_stage_metrics) = self.bundle_stage_metrics.as_mut() {
+                    bundle_stage_metrics.report();
+                    reported_slot = bundle_stage_metrics.reported_slot();
+                }
+                self.bundle_stage_metrics = None;
+                reported_slot
+            }
+            MetricsTrackerAction::NewTracker(new_bundle_stage_metrics) => {
+                self.bundle_stage_metrics = new_bundle_stage_metrics;
+                self.bundle_stage_metrics.as_ref().unwrap().reported_slot()
+            }
+            MetricsTrackerAction::ReportAndNewTracker(new_bundle_stage_metrics) => {
+                let mut reported_slot = None;
+                if let Some(bundle_stage_metrics) = self.bundle_stage_metrics.as_mut() {
+                    bundle_stage_metrics.report();
+                    reported_slot = bundle_stage_metrics.reported_slot();
+                }
+                self.bundle_stage_metrics = new_bundle_stage_metrics;
+                reported_slot
+            }
+        }
+    }
+
+    pub(crate) fn increment_sanitize_transaction_result(
+        &mut self,
+        result: &Result<SanitizedBundle, DeserializedBundleError>,
+    ) {
+        if let Some(bundle_stage_metrics) = self.bundle_stage_metrics.as_mut() {
+            match result {
+                Ok(_) => {
+                    saturating_add_assign!(bundle_stage_metrics.sanitize_transaction_ok, 1);
+                }
+                Err(e) => match e {
+                    DeserializedBundleError::VoteOnlyMode => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_vote_only_mode,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::BlacklistedAccount => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_blacklisted_account,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::FailedToSerializeTransaction => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_to_serialize,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::DuplicateTransaction => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_duplicate_transaction,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::FailedCheckTransactions => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_check,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::FailedToSerializePacket => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_to_serialize,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::EmptyBatch => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_empty_batch,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::TooManyPackets => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_too_many_packets,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::MarkedDiscard => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_marked_discard,
+                            1
+                        );
+                    }
+                    DeserializedBundleError::SignatureVerificationFailure => {
+                        saturating_add_assign!(
+                            bundle_stage_metrics.sanitize_transaction_failed_sig_verify_failed,
+                            1
+                        );
+                    }
+                },
+            }
+        }
+    }
+
+    pub fn increment_bundle_execution_result(&mut self, result: &Result<(), BundleExecutionError>) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            match result {
+                Ok(_) => {
+                    saturating_add_assign!(bundle_stage_metrics.execution_results_ok, 1);
+                }
+                Err(BundleExecutionError::PohRecordError(_))
+                | Err(BundleExecutionError::BankProcessingTimeLimitReached) => {
+                    saturating_add_assign!(
+                        bundle_stage_metrics.execution_results_poh_max_height,
+                        1
+                    );
+                }
+                Err(BundleExecutionError::TransactionFailure(
+                    LoadAndExecuteBundleError::ProcessingTimeExceeded(_),
+                )) => {
+                    saturating_add_assign!(bundle_stage_metrics.num_execution_timeouts, 1);
+                }
+                Err(BundleExecutionError::TransactionFailure(
+                    LoadAndExecuteBundleError::TransactionError { .. },
+                )) => {
+                    saturating_add_assign!(
+                        bundle_stage_metrics.execution_results_transaction_failures,
+                        1
+                    );
+                }
+                Err(BundleExecutionError::TransactionFailure(
+                    LoadAndExecuteBundleError::LockError { .. },
+                ))
+                | Err(BundleExecutionError::LockError) => {
+                    saturating_add_assign!(bundle_stage_metrics.num_lock_errors, 1);
+                }
+                Err(BundleExecutionError::ExceedsCostModel) => {
+                    saturating_add_assign!(
+                        bundle_stage_metrics.execution_results_exceeds_cost_model,
+                        1
+                    );
+                }
+                Err(BundleExecutionError::TipError(_)) => {
+                    saturating_add_assign!(bundle_stage_metrics.execution_results_tip_errors, 1);
+                }
+                Err(BundleExecutionError::TransactionFailure(
+                    LoadAndExecuteBundleError::InvalidPreOrPostAccounts,
+                )) => {
+                    saturating_add_assign!(bundle_stage_metrics.bad_argument, 1);
+                }
+            }
+        }
+    }
+
+    pub(crate) fn increment_sanitize_bundle_elapsed_us(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.sanitize_bundle_elapsed_us, count);
+        }
+    }
+
+    pub(crate) fn increment_locked_bundle_elapsed_us(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.locked_bundle_elapsed_us, count);
+        }
+    }
+
+    pub(crate) fn increment_num_init_tip_account_errors(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.num_init_tip_account_errors, count);
+        }
+    }
+
+    pub(crate) fn increment_num_init_tip_account_ok(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.num_init_tip_account_ok, count);
+        }
+    }
+
+    pub(crate) fn increment_num_change_tip_receiver_errors(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.num_change_tip_receiver_errors, count);
+        }
+    }
+
+    pub(crate) fn increment_num_change_tip_receiver_ok(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.num_change_tip_receiver_ok, count);
+        }
+    }
+
+    pub(crate) fn increment_change_tip_receiver_elapsed_us(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.change_tip_receiver_elapsed_us, count);
+        }
+    }
+
+    pub(crate) fn increment_num_execution_retries(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(bundle_stage_metrics.num_execution_retries, count);
+        }
+    }
+
+    pub(crate) fn increment_execute_locked_bundles_elapsed_us(&mut self, count: u64) {
+        if let Some(bundle_stage_metrics) = &mut self.bundle_stage_metrics {
+            saturating_add_assign!(
+                bundle_stage_metrics.execute_locked_bundles_elapsed_us,
+                count
+            );
+        }
+    }
+}
+
+#[derive(Default)]
+pub struct BundleStageStats {
+    id: u32,
+    slot: u64,
+    is_reported: bool,
+
+    sanitize_transaction_ok: u64,
+    sanitize_transaction_vote_only_mode: u64,
+    sanitize_transaction_blacklisted_account: u64,
+    sanitize_transaction_failed_to_serialize: u64,
+    sanitize_transaction_duplicate_transaction: u64,
+    sanitize_transaction_failed_check: u64,
+    sanitize_bundle_elapsed_us: u64,
+    sanitize_transaction_failed_empty_batch: u64,
+    sanitize_transaction_failed_too_many_packets: u64,
+    sanitize_transaction_failed_marked_discard: u64,
+    sanitize_transaction_failed_sig_verify_failed: u64,
+
+    locked_bundle_elapsed_us: u64,
+
+    num_lock_errors: u64,
+
+    num_init_tip_account_errors: u64,
+    num_init_tip_account_ok: u64,
+
+    num_change_tip_receiver_errors: u64,
+    num_change_tip_receiver_ok: u64,
+    change_tip_receiver_elapsed_us: u64,
+
+    num_execution_timeouts: u64,
+    num_execution_retries: u64,
+
+    execute_locked_bundles_elapsed_us: u64,
+
+    execution_results_ok: u64,
+    execution_results_poh_max_height: u64,
+    execution_results_transaction_failures: u64,
+    execution_results_exceeds_cost_model: u64,
+    execution_results_tip_errors: u64,
+    execution_results_max_retries: u64,
+
+    bad_argument: u64,
+}
+
+impl BundleStageStats {
+    pub fn new(id: u32, slot: Slot) -> BundleStageStats {
+        BundleStageStats {
+            id,
+            slot,
+            is_reported: false,
+            ..BundleStageStats::default()
+        }
+    }
+
+    /// Returns `Some(self.slot)` if the metrics have been reported, otherwise returns None
+    fn reported_slot(&self) -> Option<Slot> {
+        if self.is_reported {
+            Some(self.slot)
+        } else {
+            None
+        }
+    }
+
+    pub fn report(&mut self) {
+        self.is_reported = true;
+
+        datapoint_info!(
+            "bundle_stage-stats",
+            ("id", self.id, i64),
+            ("slot", self.slot, i64),
+            ("num_sanitized_ok", self.sanitize_transaction_ok, i64),
+            (
+                "sanitize_transaction_vote_only_mode",
+                self.sanitize_transaction_vote_only_mode,
+                i64
+            ),
+            (
+                "sanitize_transaction_blacklisted_account",
+                self.sanitize_transaction_blacklisted_account,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_to_serialize",
+                self.sanitize_transaction_failed_to_serialize,
+                i64
+            ),
+            (
+                "sanitize_transaction_duplicate_transaction",
+                self.sanitize_transaction_duplicate_transaction,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_check",
+                self.sanitize_transaction_failed_check,
+                i64
+            ),
+            (
+                "sanitize_bundle_elapsed_us",
+                self.sanitize_bundle_elapsed_us,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_empty_batch",
+                self.sanitize_transaction_failed_empty_batch,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_too_many_packets",
+                self.sanitize_transaction_failed_too_many_packets,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_marked_discard",
+                self.sanitize_transaction_failed_marked_discard,
+                i64
+            ),
+            (
+                "sanitize_transaction_failed_sig_verify_failed",
+                self.sanitize_transaction_failed_sig_verify_failed,
+                i64
+            ),
+            (
+                "locked_bundle_elapsed_us",
+                self.locked_bundle_elapsed_us,
+                i64
+            ),
+            ("num_lock_errors", self.num_lock_errors, i64),
+            (
+                "num_init_tip_account_errors",
+                self.num_init_tip_account_errors,
+                i64
+            ),
+            ("num_init_tip_account_ok", self.num_init_tip_account_ok, i64),
+            (
+                "num_change_tip_receiver_errors",
+                self.num_change_tip_receiver_errors,
+                i64
+            ),
+            (
+                "num_change_tip_receiver_ok",
+                self.num_change_tip_receiver_ok,
+                i64
+            ),
+            (
+                "change_tip_receiver_elapsed_us",
+                self.change_tip_receiver_elapsed_us,
+                i64
+            ),
+            ("num_execution_timeouts", self.num_execution_timeouts, i64),
+            ("num_execution_retries", self.num_execution_retries, i64),
+            (
+                "execute_locked_bundles_elapsed_us",
+                self.execute_locked_bundles_elapsed_us,
+                i64
+            ),
+            ("execution_results_ok", self.execution_results_ok, i64),
+            (
+                "execution_results_poh_max_height",
+                self.execution_results_poh_max_height,
+                i64
+            ),
+            (
+                "execution_results_transaction_failures",
+                self.execution_results_transaction_failures,
+                i64
+            ),
+            (
+                "execution_results_exceeds_cost_model",
+                self.execution_results_exceeds_cost_model,
+                i64
+            ),
+            (
+                "execution_results_tip_errors",
+                self.execution_results_tip_errors,
+                i64
+            ),
+            (
+                "execution_results_max_retries",
+                self.execution_results_max_retries,
+                i64
+            ),
+            ("bad_argument", self.bad_argument, i64)
+        );
+    }
+}
diff --git a/core/src/bundle_stage/committer.rs b/core/src/bundle_stage/committer.rs
new file mode 100644
index 000000000000..03db5694a435
--- /dev/null
+++ b/core/src/bundle_stage/committer.rs
@@ -0,0 +1,227 @@
+use {
+    crate::banking_stage::{
+        committer::CommitTransactionDetails,
+        leader_slot_timing_metrics::LeaderExecuteAndCommitTimings,
+    },
+    solana_bundle::bundle_execution::LoadAndExecuteBundleOutput,
+    solana_ledger::blockstore_processor::TransactionStatusSender,
+    solana_measure::measure_us,
+    solana_runtime::{
+        bank::{Bank, ExecutedTransactionCounts, TransactionBalances, TransactionBalancesSet},
+        bank_utils,
+        prioritization_fee_cache::PrioritizationFeeCache,
+        vote_sender_types::ReplayVoteSender,
+    },
+    solana_sdk::{hash::Hash, saturating_add_assign, transaction::SanitizedTransaction},
+    solana_svm::transaction_results::TransactionResults,
+    solana_transaction_status::{
+        token_balances::{TransactionTokenBalances, TransactionTokenBalancesSet},
+        PreBalanceInfo,
+    },
+    std::sync::Arc,
+};
+
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
+pub struct CommitBundleDetails {
+    pub commit_transaction_details: Vec<Vec<CommitTransactionDetails>>,
+}
+
+pub struct Committer {
+    transaction_status_sender: Option<TransactionStatusSender>,
+    replay_vote_sender: ReplayVoteSender,
+    prioritization_fee_cache: Arc<PrioritizationFeeCache>,
+}
+
+impl Committer {
+    pub fn new(
+        transaction_status_sender: Option<TransactionStatusSender>,
+        replay_vote_sender: ReplayVoteSender,
+        prioritization_fee_cache: Arc<PrioritizationFeeCache>,
+    ) -> Self {
+        Self {
+            transaction_status_sender,
+            replay_vote_sender,
+            prioritization_fee_cache,
+        }
+    }
+
+    pub(crate) fn transaction_status_sender_enabled(&self) -> bool {
+        self.transaction_status_sender.is_some()
+    }
+
+    /// Very similar to Committer::commit_transactions, but works with bundles.
+    /// The main difference is there's multiple non-parallelizable transaction vectors to commit
+    /// and post-balances are collected after execution instead of from the bank in Self::collect_balances_and_send_status_batch.
+    #[allow(clippy::too_many_arguments)]
+    pub(crate) fn commit_bundle<'a>(
+        &self,
+        bundle_execution_output: &'a mut LoadAndExecuteBundleOutput<'a>,
+        last_blockhash: Hash,
+        lamports_per_signature: u64,
+        mut starting_transaction_index: Option<usize>,
+        bank: &Arc<Bank>,
+        execute_and_commit_timings: &mut LeaderExecuteAndCommitTimings,
+    ) -> (u64, CommitBundleDetails) {
+        let transaction_output = bundle_execution_output.bundle_transaction_results_mut();
+
+        let (commit_transaction_details, commit_times): (Vec<_>, Vec<_>) = transaction_output
+            .iter_mut()
+            .map(|bundle_results| {
+                let executed_transactions_count = bundle_results
+                    .load_and_execute_transactions_output()
+                    .executed_transactions_count
+                    as u64;
+
+                let executed_non_vote_transactions_count = bundle_results
+                    .load_and_execute_transactions_output()
+                    .executed_non_vote_transactions_count
+                    as u64;
+
+                let executed_with_failure_result_count = bundle_results
+                    .load_and_execute_transactions_output()
+                    .executed_transactions_count
+                    .saturating_sub(
+                        bundle_results
+                            .load_and_execute_transactions_output()
+                            .executed_with_successful_result_count,
+                    ) as u64;
+
+                let signature_count = bundle_results
+                    .load_and_execute_transactions_output()
+                    .signature_count;
+
+                let sanitized_transactions = bundle_results.transactions().to_vec();
+                let execution_results = bundle_results.execution_results().to_vec();
+
+                let loaded_transactions = bundle_results.loaded_transactions_mut();
+                debug!("loaded_transactions: {:?}", loaded_transactions);
+
+                let (tx_results, commit_time_us) = measure_us!(bank.commit_transactions(
+                    &sanitized_transactions,
+                    loaded_transactions,
+                    execution_results,
+                    last_blockhash,
+                    lamports_per_signature,
+                    ExecutedTransactionCounts {
+                        executed_transactions_count,
+                        executed_non_vote_transactions_count,
+                        executed_with_failure_result_count,
+                        signature_count,
+                    },
+                    &mut execute_and_commit_timings.execute_timings,
+                ));
+
+                let commit_transaction_statuses: Vec<_> = tx_results
+                    .execution_results
+                    .iter()
+                    .zip(tx_results.loaded_accounts_stats.iter())
+                    .map(|(execution_result, loaded_accounts_stats)| {
+                        match execution_result.details() {
+                            // reports actual execution CUs, and actual loaded accounts size for
+                            // transaction committed to block. qos_service uses these information to adjust
+                            // reserved block space.
+                            Some(details) => CommitTransactionDetails::Committed {
+                                compute_units: details.executed_units,
+                                loaded_accounts_data_size: loaded_accounts_stats
+                                    .as_ref()
+                                    .map_or(0, |stats| stats.loaded_accounts_data_size),
+                            },
+                            None => CommitTransactionDetails::NotCommitted,
+                        }
+                    })
+                    .collect();
+
+                let ((), find_and_send_votes_us) = measure_us!({
+                    bank_utils::find_and_send_votes(
+                        &sanitized_transactions,
+                        &tx_results,
+                        Some(&self.replay_vote_sender),
+                    );
+
+                    let post_balance_info = bundle_results.post_balance_info().clone();
+                    let pre_balance_info = bundle_results.pre_balance_info();
+
+                    let num_committed = tx_results
+                        .execution_results
+                        .iter()
+                        .filter(|r| r.was_executed())
+                        .count();
+
+                    self.collect_balances_and_send_status_batch(
+                        tx_results,
+                        bank,
+                        sanitized_transactions,
+                        pre_balance_info,
+                        post_balance_info,
+                        starting_transaction_index,
+                    );
+
+                    // NOTE: we're doing batched records, so we need to increment the poh starting_transaction_index
+                    // by number committed so the next batch will have the correct starting_transaction_index
+                    starting_transaction_index =
+                        starting_transaction_index.map(|starting_transaction_index| {
+                            starting_transaction_index.saturating_add(num_committed)
+                        });
+
+                    self.prioritization_fee_cache
+                        .update(bank, bundle_results.executed_transactions().into_iter());
+                });
+                saturating_add_assign!(
+                    execute_and_commit_timings.find_and_send_votes_us,
+                    find_and_send_votes_us
+                );
+
+                (commit_transaction_statuses, commit_time_us)
+            })
+            .unzip();
+
+        (
+            commit_times.iter().sum(),
+            CommitBundleDetails {
+                commit_transaction_details,
+            },
+        )
+    }
+
+    fn collect_balances_and_send_status_batch(
+        &self,
+        tx_results: TransactionResults,
+        bank: &Arc<Bank>,
+        sanitized_transactions: Vec<SanitizedTransaction>,
+        pre_balance_info: &mut PreBalanceInfo,
+        (post_balances, post_token_balances): (TransactionBalances, TransactionTokenBalances),
+        starting_transaction_index: Option<usize>,
+    ) {
+        if let Some(transaction_status_sender) = &self.transaction_status_sender {
+            let mut transaction_index = starting_transaction_index.unwrap_or_default();
+            let batch_transaction_indexes: Vec<_> = tx_results
+                .execution_results
+                .iter()
+                .map(|result| {
+                    if result.was_executed() {
+                        let this_transaction_index = transaction_index;
+                        saturating_add_assign!(transaction_index, 1);
+                        this_transaction_index
+                    } else {
+                        0
+                    }
+                })
+                .collect();
+            transaction_status_sender.send_transaction_status_batch(
+                bank.clone(),
+                sanitized_transactions,
+                tx_results.execution_results,
+                TransactionBalancesSet::new(
+                    std::mem::take(&mut pre_balance_info.native),
+                    post_balances,
+                ),
+                TransactionTokenBalancesSet::new(
+                    std::mem::take(&mut pre_balance_info.token),
+                    post_token_balances,
+                ),
+                tx_results.rent_debits,
+                batch_transaction_indexes,
+            );
+        }
+    }
+}
diff --git a/core/src/bundle_stage/result.rs b/core/src/bundle_stage/result.rs
new file mode 100644
index 000000000000..3370251791f6
--- /dev/null
+++ b/core/src/bundle_stage/result.rs
@@ -0,0 +1,41 @@
+use {
+    crate::{
+        bundle_stage::bundle_account_locker::BundleAccountLockerError, tip_manager::TipPaymentError,
+    },
+    anchor_lang::error::Error,
+    solana_bundle::bundle_execution::LoadAndExecuteBundleError,
+    solana_poh::poh_recorder::PohRecorderError,
+    thiserror::Error,
+};
+
+pub type BundleExecutionResult<T> = Result<T, BundleExecutionError>;
+
+#[derive(Error, Debug, Clone)]
+pub enum BundleExecutionError {
+    #[error("PoH record error: {0}")]
+    PohRecordError(#[from] PohRecorderError),
+
+    #[error("Bank is done processing")]
+    BankProcessingDone,
+
+    #[error("Execution error: {0}")]
+    ExecutionError(#[from] LoadAndExecuteBundleError),
+
+    #[error("The bundle exceeds the cost model")]
+    ExceedsCostModel,
+
+    #[error("Tip error {0}")]
+    TipError(#[from] TipPaymentError),
+
+    #[error("Error locking bundle")]
+    LockError(#[from] BundleAccountLockerError),
+}
+
+impl From<anchor_lang::error::Error> for TipPaymentError {
+    fn from(anchor_err: Error) -> Self {
+        match anchor_err {
+            Error::AnchorError(e) => Self::AnchorError(e.error_msg),
+            Error::ProgramError(e) => Self::AnchorError(e.to_string()),
+        }
+    }
+}
diff --git a/core/src/consensus_cache_updater.rs b/core/src/consensus_cache_updater.rs
new file mode 100644
index 000000000000..e1dc137ba0ed
--- /dev/null
+++ b/core/src/consensus_cache_updater.rs
@@ -0,0 +1,52 @@
+use {
+    solana_runtime::bank::Bank,
+    solana_sdk::{clock::Epoch, pubkey::Pubkey},
+    std::collections::HashSet,
+};
+
+#[derive(Default)]
+pub(crate) struct ConsensusCacheUpdater {
+    last_epoch_updated: Epoch,
+    consensus_accounts_cache: HashSet<Pubkey>,
+}
+
+impl ConsensusCacheUpdater {
+    pub(crate) fn consensus_accounts_cache(&self) -> &HashSet<Pubkey> {
+        &self.consensus_accounts_cache
+    }
+
+    /// Builds a HashSet of all consensus related accounts for the Bank's epoch
+    fn get_consensus_accounts(bank: &Bank) -> HashSet<Pubkey> {
+        let mut consensus_accounts: HashSet<Pubkey> = HashSet::new();
+        if let Some(epoch_stakes) = bank.epoch_stakes(bank.epoch()) {
+            // votes use the following accounts:
+            // - vote_account pubkey: writeable
+            // - authorized_voter_pubkey: read-only
+            // - node_keypair pubkey: payer (writeable)
+            let node_id_vote_accounts = epoch_stakes.node_id_to_vote_accounts();
+
+            let vote_accounts = node_id_vote_accounts
+                .values()
+                .flat_map(|v| v.vote_accounts.clone());
+
+            // vote_account
+            consensus_accounts.extend(vote_accounts);
+            // authorized_voter_pubkey
+            consensus_accounts.extend(epoch_stakes.epoch_authorized_voters().keys());
+            // node_keypair
+            consensus_accounts.extend(epoch_stakes.node_id_to_vote_accounts().keys());
+        }
+        consensus_accounts
+    }
+
+    /// Updates consensus-related accounts on epoch boundaries
+    pub(crate) fn maybe_update(&mut self, bank: &Bank) -> bool {
+        if bank.epoch() > self.last_epoch_updated {
+            self.consensus_accounts_cache = Self::get_consensus_accounts(bank);
+            self.last_epoch_updated = bank.epoch();
+            true
+        } else {
+            false
+        }
+    }
+}
diff --git a/core/src/immutable_deserialized_bundle.rs b/core/src/immutable_deserialized_bundle.rs
new file mode 100644
index 000000000000..aa1c395f249e
--- /dev/null
+++ b/core/src/immutable_deserialized_bundle.rs
@@ -0,0 +1,488 @@
+use {
+    crate::{
+        banking_stage::immutable_deserialized_packet::ImmutableDeserializedPacket,
+        packet_bundle::PacketBundle,
+    },
+    solana_perf::sigverify::verify_packet,
+    solana_runtime::bank::Bank,
+    solana_sdk::{
+        bundle::SanitizedBundle, clock::MAX_PROCESSING_AGE, pubkey::Pubkey, signature::Signature,
+        transaction::SanitizedTransaction,
+    },
+    solana_svm::transaction_error_metrics::TransactionErrorMetrics,
+    std::{
+        collections::{hash_map::RandomState, HashSet},
+        iter::repeat,
+    },
+    thiserror::Error,
+};
+
+#[derive(Debug, Error, Eq, PartialEq)]
+pub enum DeserializedBundleError {
+    #[error("FailedToSerializePacket")]
+    FailedToSerializePacket,
+
+    #[error("EmptyBatch")]
+    EmptyBatch,
+
+    #[error("TooManyPackets")]
+    TooManyPackets,
+
+    #[error("MarkedDiscard")]
+    MarkedDiscard,
+
+    #[error("SignatureVerificationFailure")]
+    SignatureVerificationFailure,
+
+    #[error("Bank is in vote-only mode")]
+    VoteOnlyMode,
+
+    #[error("Bundle mentions blacklisted account")]
+    BlacklistedAccount,
+
+    #[error("Bundle contains a transaction that failed to serialize")]
+    FailedToSerializeTransaction,
+
+    #[error("Bundle contains a duplicate transaction")]
+    DuplicateTransaction,
+
+    #[error("Bundle failed check_transactions")]
+    FailedCheckTransactions,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub struct ImmutableDeserializedBundle {
+    bundle_id: String,
+    packets: Vec<ImmutableDeserializedPacket>,
+}
+
+impl ImmutableDeserializedBundle {
+    pub fn new(
+        bundle: &mut PacketBundle,
+        max_len: Option<usize>,
+    ) -> Result<Self, DeserializedBundleError> {
+        // Checks: non-zero, less than some length, marked for discard, signature verification failed, failed to sanitize to
+        // ImmutableDeserializedPacket
+        if bundle.batch.is_empty() {
+            return Err(DeserializedBundleError::EmptyBatch);
+        }
+        if max_len
+            .map(|max_len| bundle.batch.len() > max_len)
+            .unwrap_or(false)
+        {
+            return Err(DeserializedBundleError::TooManyPackets);
+        }
+        if bundle.batch.iter().any(|p| p.meta().discard()) {
+            return Err(DeserializedBundleError::MarkedDiscard);
+        }
+        if bundle.batch.iter_mut().any(|p| !verify_packet(p, false)) {
+            return Err(DeserializedBundleError::SignatureVerificationFailure);
+        }
+
+        let immutable_packets: Vec<_> = bundle
+            .batch
+            .iter()
+            .filter_map(|p| ImmutableDeserializedPacket::new(p.clone()).ok())
+            .collect();
+
+        if bundle.batch.len() != immutable_packets.len() {
+            return Err(DeserializedBundleError::FailedToSerializePacket);
+        }
+
+        Ok(Self {
+            bundle_id: bundle.bundle_id.clone(),
+            packets: immutable_packets,
+        })
+    }
+
+    #[allow(clippy::len_without_is_empty)]
+    pub fn len(&self) -> usize {
+        self.packets.len()
+    }
+
+    pub fn bundle_id(&self) -> &str {
+        &self.bundle_id
+    }
+
+    /// A bundle has the following requirements:
+    /// - all transactions must be sanitiz-able
+    /// - no duplicate signatures
+    /// - must not contain a blacklisted account
+    /// - can't already be processed or contain a bad blockhash
+    pub fn build_sanitized_bundle(
+        &self,
+        bank: &Bank,
+        blacklisted_accounts: &HashSet<Pubkey>,
+        transaction_error_metrics: &mut TransactionErrorMetrics,
+    ) -> Result<SanitizedBundle, DeserializedBundleError> {
+        if bank.vote_only_bank() {
+            return Err(DeserializedBundleError::VoteOnlyMode);
+        }
+
+        let transactions: Vec<SanitizedTransaction> = self
+            .packets
+            .iter()
+            .filter_map(|p| {
+                p.build_sanitized_transaction(
+                    bank.vote_only_bank(),
+                    bank,
+                    bank.get_reserved_account_keys(),
+                )
+            })
+            .collect();
+
+        if self.packets.len() != transactions.len() {
+            return Err(DeserializedBundleError::FailedToSerializeTransaction);
+        }
+
+        let unique_signatures: HashSet<&Signature, RandomState> =
+            HashSet::from_iter(transactions.iter().map(|tx| tx.signature()));
+        if unique_signatures.len() != transactions.len() {
+            return Err(DeserializedBundleError::DuplicateTransaction);
+        }
+
+        let contains_blacklisted_account = transactions.iter().any(|tx| {
+            tx.message()
+                .account_keys()
+                .iter()
+                .any(|acc| blacklisted_accounts.contains(acc))
+        });
+
+        if contains_blacklisted_account {
+            return Err(DeserializedBundleError::BlacklistedAccount);
+        }
+
+        // assume everything locks okay to check for already-processed transaction or expired/invalid blockhash
+        let lock_results: Vec<_> = repeat(Ok(())).take(transactions.len()).collect();
+        let check_results = bank.check_transactions(
+            &transactions,
+            &lock_results,
+            MAX_PROCESSING_AGE,
+            transaction_error_metrics,
+        );
+
+        if check_results.iter().any(|r| r.is_err()) {
+            return Err(DeserializedBundleError::FailedCheckTransactions);
+        }
+
+        Ok(SanitizedBundle {
+            transactions,
+            bundle_id: self.bundle_id.clone(),
+        })
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        crate::{
+            immutable_deserialized_bundle::{DeserializedBundleError, ImmutableDeserializedBundle},
+            packet_bundle::PacketBundle,
+        },
+        solana_client::rpc_client::SerializableTransaction,
+        solana_ledger::genesis_utils::create_genesis_config,
+        solana_perf::packet::PacketBatch,
+        solana_runtime::{
+            bank::{Bank, NewBankOptions},
+            genesis_utils::GenesisConfigInfo,
+        },
+        solana_sdk::{
+            hash::Hash,
+            packet::Packet,
+            pubkey::Pubkey,
+            signature::{Keypair, Signer},
+            system_transaction::transfer,
+        },
+        solana_svm::transaction_error_metrics::TransactionErrorMetrics,
+        std::{collections::HashSet, sync::Arc},
+    };
+    /// Happy case
+    #[test]
+    fn test_simple_get_sanitized_bundle() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (bank, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, genesis_config.hash());
+
+        let tx1 = transfer(&mint_keypair, &kp.pubkey(), 501, genesis_config.hash());
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![
+                    Packet::from_data(None, &tx0).unwrap(),
+                    Packet::from_data(None, &tx1).unwrap(),
+                ]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        let sanitized_bundle = bundle
+            .build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors)
+            .unwrap();
+        assert_eq!(sanitized_bundle.transactions.len(), 2);
+        assert_eq!(
+            sanitized_bundle.transactions[0].signature(),
+            tx0.get_signature()
+        );
+        assert_eq!(
+            sanitized_bundle.transactions[1].signature(),
+            tx1.get_signature()
+        );
+    }
+
+    #[test]
+    fn test_empty_batch_fails_to_init() {
+        assert_eq!(
+            ImmutableDeserializedBundle::new(
+                &mut PacketBundle {
+                    batch: PacketBatch::new(vec![]),
+                    bundle_id: String::default(),
+                },
+                None,
+            ),
+            Err(DeserializedBundleError::EmptyBatch)
+        );
+    }
+
+    #[test]
+    fn test_too_many_packets_fails_to_init() {
+        let kp = Keypair::new();
+
+        assert_eq!(
+            ImmutableDeserializedBundle::new(
+                &mut PacketBundle {
+                    batch: PacketBatch::new(
+                        (0..10)
+                            .map(|i| {
+                                Packet::from_data(
+                                    None,
+                                    transfer(&kp, &kp.pubkey(), i, Hash::default()),
+                                )
+                                .unwrap()
+                            })
+                            .collect()
+                    ),
+                    bundle_id: String::default(),
+                },
+                Some(5),
+            ),
+            Err(DeserializedBundleError::TooManyPackets)
+        );
+    }
+
+    #[test]
+    fn test_packets_marked_discard_fails_to_init() {
+        let kp = Keypair::new();
+
+        let mut packet =
+            Packet::from_data(None, transfer(&kp, &kp.pubkey(), 100, Hash::default())).unwrap();
+        packet.meta_mut().set_discard(true);
+
+        assert_eq!(
+            ImmutableDeserializedBundle::new(
+                &mut PacketBundle {
+                    batch: PacketBatch::new(vec![packet]),
+                    bundle_id: String::default(),
+                },
+                Some(5),
+            ),
+            Err(DeserializedBundleError::MarkedDiscard)
+        );
+    }
+
+    #[test]
+    fn test_bad_signature_fails_to_init() {
+        let kp0 = Keypair::new();
+        let kp1 = Keypair::new();
+
+        let mut tx0 = transfer(&kp0, &kp0.pubkey(), 100, Hash::default());
+        let tx1 = transfer(&kp1, &kp0.pubkey(), 100, Hash::default());
+        tx0.signatures = tx1.signatures;
+
+        assert_eq!(
+            ImmutableDeserializedBundle::new(
+                &mut PacketBundle {
+                    batch: PacketBatch::new(vec![Packet::from_data(None, tx0).unwrap()]),
+                    bundle_id: String::default(),
+                },
+                None
+            ),
+            Err(DeserializedBundleError::SignatureVerificationFailure)
+        );
+    }
+
+    #[test]
+    fn test_vote_only_bank_fails_to_build() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (parent, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+        let vote_only_bank = Arc::new(Bank::new_from_parent_with_options(
+            parent,
+            &Pubkey::new_unique(),
+            1,
+            NewBankOptions {
+                vote_only_bank: true,
+            },
+        ));
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, genesis_config.hash());
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![Packet::from_data(None, tx0).unwrap()]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        assert_matches!(
+            bundle.build_sanitized_bundle(
+                &vote_only_bank,
+                &HashSet::default(),
+                &mut transaction_errors
+            ),
+            Err(DeserializedBundleError::VoteOnlyMode)
+        );
+    }
+
+    #[test]
+    fn test_duplicate_signature_fails_to_build() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (bank, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, genesis_config.hash());
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![
+                    Packet::from_data(None, &tx0).unwrap(),
+                    Packet::from_data(None, &tx0).unwrap(),
+                ]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        assert_matches!(
+            bundle.build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors),
+            Err(DeserializedBundleError::DuplicateTransaction)
+        );
+    }
+
+    #[test]
+    fn test_blacklisted_account_fails_to_build() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (bank, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, genesis_config.hash());
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![Packet::from_data(None, tx0).unwrap()]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        assert_matches!(
+            bundle.build_sanitized_bundle(
+                &bank,
+                &HashSet::from([kp.pubkey()]),
+                &mut transaction_errors
+            ),
+            Err(DeserializedBundleError::BlacklistedAccount)
+        );
+    }
+
+    #[test]
+    fn test_already_processed_tx_fails_to_build() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (bank, _bank_forks) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, genesis_config.hash());
+
+        bank.process_transaction(&tx0).unwrap();
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![Packet::from_data(None, tx0).unwrap()]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        assert_matches!(
+            bundle.build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors),
+            Err(DeserializedBundleError::FailedCheckTransactions)
+        );
+    }
+
+    #[test]
+    fn test_bad_blockhash_fails_to_build() {
+        let GenesisConfigInfo {
+            genesis_config,
+            mint_keypair,
+            ..
+        } = create_genesis_config(10_000);
+        let (bank, _) = Bank::new_no_wallclock_throttle_for_tests(&genesis_config);
+
+        let kp = Keypair::new();
+
+        let tx0 = transfer(&mint_keypair, &kp.pubkey(), 500, Hash::default());
+
+        let bundle = ImmutableDeserializedBundle::new(
+            &mut PacketBundle {
+                batch: PacketBatch::new(vec![Packet::from_data(None, tx0).unwrap()]),
+                bundle_id: String::default(),
+            },
+            None,
+        )
+        .unwrap();
+
+        let mut transaction_errors = TransactionErrorMetrics::default();
+        assert_matches!(
+            bundle.build_sanitized_bundle(&bank, &HashSet::default(), &mut transaction_errors),
+            Err(DeserializedBundleError::FailedCheckTransactions)
+        );
+    }
+}
diff --git a/core/src/lib.rs b/core/src/lib.rs
index c6ab7b7e9c8b..5c4aa8652313 100644
--- a/core/src/lib.rs
+++ b/core/src/lib.rs
@@ -12,20 +12,25 @@ pub mod accounts_hash_verifier;
 pub mod admin_rpc_post_init;
 pub mod banking_stage;
 pub mod banking_trace;
+pub mod bundle_stage;
 pub mod cache_block_meta_service;
 pub mod cluster_info_vote_listener;
 pub mod cluster_slots_service;
 pub mod commitment_service;
 pub mod completed_data_sets_service;
 pub mod consensus;
+pub mod consensus_cache_updater;
 pub mod cost_update_service;
 pub mod drop_bank_service;
 pub mod fetch_stage;
 pub mod gen_keys;
+pub mod immutable_deserialized_bundle;
 pub mod next_leader;
 pub mod optimistic_confirmation_verifier;
+pub mod packet_bundle;
 pub mod poh_timing_report_service;
 pub mod poh_timing_reporter;
+pub mod proxy;
 pub mod repair;
 pub mod replay_stage;
 mod result;
@@ -38,6 +43,7 @@ pub mod snapshot_packager_service;
 pub mod staked_nodes_updater_service;
 pub mod stats_reporter_service;
 pub mod system_monitor_service;
+pub mod tip_manager;
 pub mod tpu;
 mod tpu_entry_notifier;
 pub mod tracer_packet_stats;
@@ -66,3 +72,41 @@ extern crate solana_frozen_abi_macro;
 #[cfg(test)]
 #[macro_use]
 extern crate assert_matches;
+
+use {
+    solana_sdk::packet::{Meta, Packet, PacketFlags, PACKET_DATA_SIZE},
+    std::{
+        cmp::min,
+        net::{IpAddr, Ipv4Addr},
+    },
+};
+
+const UNKNOWN_IP: IpAddr = IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0));
+
+// NOTE: last profiled at around 180ns
+pub fn proto_packet_to_packet(p: jito_protos::proto::packet::Packet) -> Packet {
+    let mut data = [0; PACKET_DATA_SIZE];
+    let copy_len = min(data.len(), p.data.len());
+    data[..copy_len].copy_from_slice(&p.data[..copy_len]);
+    let mut packet = Packet::new(data, Meta::default());
+    if let Some(meta) = p.meta {
+        packet.meta_mut().size = meta.size as usize;
+        packet.meta_mut().addr = meta.addr.parse().unwrap_or(UNKNOWN_IP);
+        packet.meta_mut().port = meta.port as u16;
+        if let Some(flags) = meta.flags {
+            if flags.simple_vote_tx {
+                packet.meta_mut().flags.insert(PacketFlags::SIMPLE_VOTE_TX);
+            }
+            if flags.forwarded {
+                packet.meta_mut().flags.insert(PacketFlags::FORWARDED);
+            }
+            if flags.tracer_packet {
+                packet.meta_mut().flags.insert(PacketFlags::TRACER_PACKET);
+            }
+            if flags.repair {
+                packet.meta_mut().flags.insert(PacketFlags::REPAIR);
+            }
+        }
+    }
+    packet
+}
diff --git a/core/src/packet_bundle.rs b/core/src/packet_bundle.rs
new file mode 100644
index 000000000000..2158f374145a
--- /dev/null
+++ b/core/src/packet_bundle.rs
@@ -0,0 +1,7 @@
+use solana_perf::packet::PacketBatch;
+
+#[derive(Clone, Debug)]
+pub struct PacketBundle {
+    pub batch: PacketBatch,
+    pub bundle_id: String,
+}
diff --git a/core/src/proxy/auth.rs b/core/src/proxy/auth.rs
new file mode 100644
index 000000000000..39821e12ef13
--- /dev/null
+++ b/core/src/proxy/auth.rs
@@ -0,0 +1,185 @@
+use {
+    crate::proxy::ProxyError,
+    chrono::Utc,
+    jito_protos::proto::auth::{
+        auth_service_client::AuthServiceClient, GenerateAuthChallengeRequest,
+        GenerateAuthTokensRequest, RefreshAccessTokenRequest, Role, Token,
+    },
+    solana_gossip::cluster_info::ClusterInfo,
+    solana_sdk::signature::{Keypair, Signer},
+    std::{
+        sync::{Arc, Mutex},
+        time::Duration,
+    },
+    tokio::time::timeout,
+    tonic::{service::Interceptor, transport::Channel, Code, Request, Status},
+};
+
+/// Interceptor responsible for adding the access token to request headers.
+pub(crate) struct AuthInterceptor {
+    /// The token added to each request header.
+    access_token: Arc<Mutex<Token>>,
+}
+
+impl AuthInterceptor {
+    pub(crate) fn new(access_token: Arc<Mutex<Token>>) -> Self {
+        Self { access_token }
+    }
+}
+
+impl Interceptor for AuthInterceptor {
+    fn call(&mut self, mut request: Request<()>) -> Result<Request<()>, Status> {
+        request.metadata_mut().insert(
+            "authorization",
+            format!("Bearer {}", self.access_token.lock().unwrap().value)
+                .parse()
+                .unwrap(),
+        );
+
+        Ok(request)
+    }
+}
+
+/// Generates an auth challenge then generates and returns validated auth tokens.
+pub async fn generate_auth_tokens(
+    auth_service_client: &mut AuthServiceClient<Channel>,
+    // used to sign challenges
+    keypair: &Keypair,
+) -> crate::proxy::Result<(
+    Token, /* access_token */
+    Token, /* refresh_token */
+)> {
+    debug!("generate_auth_challenge");
+    let challenge_response = auth_service_client
+        .generate_auth_challenge(GenerateAuthChallengeRequest {
+            role: Role::Validator as i32,
+            pubkey: keypair.pubkey().as_ref().to_vec(),
+        })
+        .await
+        .map_err(|e: Status| {
+            if e.code() == Code::PermissionDenied {
+                ProxyError::AuthenticationPermissionDenied
+            } else {
+                ProxyError::AuthenticationError(e.to_string())
+            }
+        })?;
+
+    let formatted_challenge = format!(
+        "{}-{}",
+        keypair.pubkey(),
+        challenge_response.into_inner().challenge
+    );
+
+    let signed_challenge = keypair
+        .sign_message(formatted_challenge.as_bytes())
+        .as_ref()
+        .to_vec();
+
+    debug!(
+        "formatted_challenge: {} signed_challenge: {:?}",
+        formatted_challenge, signed_challenge
+    );
+
+    debug!("generate_auth_tokens");
+    let auth_tokens = auth_service_client
+        .generate_auth_tokens(GenerateAuthTokensRequest {
+            challenge: formatted_challenge,
+            client_pubkey: keypair.pubkey().as_ref().to_vec(),
+            signed_challenge,
+        })
+        .await
+        .map_err(|e| ProxyError::AuthenticationError(e.to_string()))?;
+
+    let inner = auth_tokens.into_inner();
+    let access_token = get_validated_token(inner.access_token)?;
+    let refresh_token = get_validated_token(inner.refresh_token)?;
+
+    Ok((access_token, refresh_token))
+}
+
+/// Tries to refresh the access token or run full-reauth if needed.
+pub async fn maybe_refresh_auth_tokens(
+    auth_service_client: &mut AuthServiceClient<Channel>,
+    access_token: &Arc<Mutex<Token>>,
+    refresh_token: &Token,
+    cluster_info: &Arc<ClusterInfo>,
+    connection_timeout: &Duration,
+    refresh_within_s: u64,
+) -> crate::proxy::Result<(
+    Option<Token>, // access token
+    Option<Token>, // refresh token
+)> {
+    let access_token_expiry: u64 = access_token
+        .lock()
+        .unwrap()
+        .expires_at_utc
+        .as_ref()
+        .map(|ts| ts.seconds as u64)
+        .unwrap_or_default();
+    let refresh_token_expiry: u64 = refresh_token
+        .expires_at_utc
+        .as_ref()
+        .map(|ts| ts.seconds as u64)
+        .unwrap_or_default();
+
+    let now = Utc::now().timestamp() as u64;
+
+    let should_refresh_access =
+        access_token_expiry.checked_sub(now).unwrap_or_default() <= refresh_within_s;
+    let should_generate_new_tokens =
+        refresh_token_expiry.checked_sub(now).unwrap_or_default() <= refresh_within_s;
+
+    if should_generate_new_tokens {
+        let kp = cluster_info.keypair().clone();
+
+        let (new_access_token, new_refresh_token) = timeout(
+            *connection_timeout,
+            generate_auth_tokens(auth_service_client, kp.as_ref()),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("generate_auth_tokens".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?;
+
+        return Ok((Some(new_access_token), Some(new_refresh_token)));
+    } else if should_refresh_access {
+        let new_access_token = timeout(
+            *connection_timeout,
+            refresh_access_token(auth_service_client, refresh_token),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("refresh_access_token".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?;
+
+        return Ok((Some(new_access_token), None));
+    }
+
+    Ok((None, None))
+}
+
+pub async fn refresh_access_token(
+    auth_service_client: &mut AuthServiceClient<Channel>,
+    refresh_token: &Token,
+) -> crate::proxy::Result<Token> {
+    let response = auth_service_client
+        .refresh_access_token(RefreshAccessTokenRequest {
+            refresh_token: refresh_token.value.clone(),
+        })
+        .await
+        .map_err(|e| ProxyError::AuthenticationError(e.to_string()))?;
+    get_validated_token(response.into_inner().access_token)
+}
+
+/// An invalid token is one where any of its fields are None or the token itself is None.
+/// Performs the necessary validations on the auth tokens before returning,
+/// i.e. it is safe to call .unwrap() on the token fields from the call-site.
+fn get_validated_token(maybe_token: Option<Token>) -> crate::proxy::Result<Token> {
+    let token = maybe_token
+        .ok_or_else(|| ProxyError::BadAuthenticationToken("received a null token".to_string()))?;
+    if token.expires_at_utc.is_none() {
+        Err(ProxyError::BadAuthenticationToken(
+            "expires_at_utc field is null".to_string(),
+        ))
+    } else {
+        Ok(token)
+    }
+}
diff --git a/core/src/proxy/block_engine_stage.rs b/core/src/proxy/block_engine_stage.rs
new file mode 100644
index 000000000000..caf45ac0d968
--- /dev/null
+++ b/core/src/proxy/block_engine_stage.rs
@@ -0,0 +1,571 @@
+//! Maintains a connection to the Block Engine.
+//!
+//! The Block Engine is responsible for the following:
+//! - Acts as a system that sends high profit bundles and transactions to a validator.
+//! - Sends transactions and bundles to the validator.
+use {
+    crate::{
+        banking_trace::BankingPacketSender,
+        packet_bundle::PacketBundle,
+        proto_packet_to_packet,
+        proxy::{
+            auth::{generate_auth_tokens, maybe_refresh_auth_tokens, AuthInterceptor},
+            ProxyError,
+        },
+    },
+    crossbeam_channel::Sender,
+    jito_protos::proto::{
+        auth::{auth_service_client::AuthServiceClient, Token},
+        block_engine::{
+            self, block_engine_validator_client::BlockEngineValidatorClient,
+            BlockBuilderFeeInfoRequest,
+        },
+    },
+    solana_gossip::cluster_info::ClusterInfo,
+    solana_perf::packet::PacketBatch,
+    solana_sdk::{
+        pubkey::Pubkey, saturating_add_assign, signature::Signer, signer::keypair::Keypair,
+    },
+    std::{
+        str::FromStr,
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc, Mutex,
+        },
+        thread::{self, Builder, JoinHandle},
+        time::Duration,
+    },
+    tokio::{
+        task,
+        time::{interval, sleep, timeout},
+    },
+    tonic::{
+        codegen::InterceptedService,
+        transport::{Channel, Endpoint},
+        Status, Streaming,
+    },
+};
+
+const CONNECTION_TIMEOUT_S: u64 = 10;
+const CONNECTION_BACKOFF_S: u64 = 5;
+
+#[derive(Default)]
+struct BlockEngineStageStats {
+    num_bundles: u64,
+    num_bundle_packets: u64,
+    num_packets: u64,
+    num_empty_packets: u64,
+}
+
+impl BlockEngineStageStats {
+    pub(crate) fn report(&self) {
+        datapoint_info!(
+            "block_engine_stage-stats",
+            ("num_bundles", self.num_bundles, i64),
+            ("num_bundle_packets", self.num_bundle_packets, i64),
+            ("num_packets", self.num_packets, i64),
+            ("num_empty_packets", self.num_empty_packets, i64)
+        );
+    }
+}
+
+pub struct BlockBuilderFeeInfo {
+    pub block_builder: Pubkey,
+    pub block_builder_commission: u64,
+}
+
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
+pub struct BlockEngineConfig {
+    /// Block Engine URL
+    pub block_engine_url: String,
+
+    /// If set then it will be assumed the backend verified packets so signature verification will be bypassed in the validator.
+    pub trust_packets: bool,
+}
+
+pub struct BlockEngineStage {
+    t_hdls: Vec<JoinHandle<()>>,
+}
+
+impl BlockEngineStage {
+    pub fn new(
+        block_engine_config: Arc<Mutex<BlockEngineConfig>>,
+        // Channel that bundles get piped through.
+        bundle_tx: Sender<Vec<PacketBundle>>,
+        // The keypair stored here is used to sign auth challenges.
+        cluster_info: Arc<ClusterInfo>,
+        // Channel that non-trusted packets get piped through.
+        packet_tx: Sender<PacketBatch>,
+        // Channel that trusted packets get piped through.
+        banking_packet_sender: BankingPacketSender,
+        exit: Arc<AtomicBool>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+    ) -> Self {
+        let block_builder_fee_info = block_builder_fee_info.clone();
+
+        let thread = Builder::new()
+            .name("block-engine-stage".to_string())
+            .spawn(move || {
+                let rt = tokio::runtime::Builder::new_multi_thread()
+                    .enable_all()
+                    .build()
+                    .unwrap();
+                rt.block_on(Self::start(
+                    block_engine_config,
+                    cluster_info,
+                    bundle_tx,
+                    packet_tx,
+                    banking_packet_sender,
+                    exit,
+                    block_builder_fee_info,
+                ));
+            })
+            .unwrap();
+
+        Self {
+            t_hdls: vec![thread],
+        }
+    }
+
+    pub fn join(self) -> thread::Result<()> {
+        for t in self.t_hdls {
+            t.join()?;
+        }
+        Ok(())
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn start(
+        block_engine_config: Arc<Mutex<BlockEngineConfig>>,
+        cluster_info: Arc<ClusterInfo>,
+        bundle_tx: Sender<Vec<PacketBundle>>,
+        packet_tx: Sender<PacketBatch>,
+        banking_packet_sender: BankingPacketSender,
+        exit: Arc<AtomicBool>,
+        block_builder_fee_info: Arc<Mutex<BlockBuilderFeeInfo>>,
+    ) {
+        const CONNECTION_TIMEOUT: Duration = Duration::from_secs(CONNECTION_TIMEOUT_S);
+        const CONNECTION_BACKOFF: Duration = Duration::from_secs(CONNECTION_BACKOFF_S);
+        let mut error_count: u64 = 0;
+
+        while !exit.load(Ordering::Relaxed) {
+            // Wait until a valid config is supplied (either initially or by admin rpc)
+            // Use if!/else here to avoid extra CONNECTION_BACKOFF wait on successful termination
+            let local_block_engine_config = {
+                let block_engine_config = block_engine_config.clone();
+                task::spawn_blocking(move || block_engine_config.lock().unwrap().clone())
+                    .await
+                    .unwrap()
+            };
+            if !Self::is_valid_block_engine_config(&local_block_engine_config) {
+                sleep(CONNECTION_BACKOFF).await;
+            } else if let Err(e) = Self::connect_auth_and_stream(
+                &local_block_engine_config,
+                &block_engine_config,
+                &cluster_info,
+                &bundle_tx,
+                &packet_tx,
+                &banking_packet_sender,
+                &exit,
+                &block_builder_fee_info,
+                &CONNECTION_TIMEOUT,
+            )
+            .await
+            {
+                match e {
+                    // This error is frequent on hot spares, and the parsed string does not work
+                    // with datapoints (incorrect escaping).
+                    ProxyError::AuthenticationPermissionDenied => {
+                        warn!("block engine permission denied. not on leader schedule. ignore if hot-spare.")
+                    }
+                    e => {
+                        error_count += 1;
+                        datapoint_warn!(
+                            "block_engine_stage-proxy_error",
+                            ("count", error_count, i64),
+                            ("error", e.to_string(), String),
+                        );
+                    }
+                }
+                sleep(CONNECTION_BACKOFF).await;
+            }
+        }
+    }
+
+    async fn connect_auth_and_stream(
+        local_block_engine_config: &BlockEngineConfig,
+        global_block_engine_config: &Arc<Mutex<BlockEngineConfig>>,
+        cluster_info: &Arc<ClusterInfo>,
+        bundle_tx: &Sender<Vec<PacketBundle>>,
+        packet_tx: &Sender<PacketBatch>,
+        banking_packet_sender: &BankingPacketSender,
+        exit: &Arc<AtomicBool>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        connection_timeout: &Duration,
+    ) -> crate::proxy::Result<()> {
+        // Get a copy of configs here in case they have changed at runtime
+        let keypair = cluster_info.keypair().clone();
+
+        let mut backend_endpoint =
+            Endpoint::from_shared(local_block_engine_config.block_engine_url.clone())
+                .map_err(|_| {
+                    ProxyError::BlockEngineConnectionError(format!(
+                        "invalid block engine url value: {}",
+                        local_block_engine_config.block_engine_url
+                    ))
+                })?
+                .tcp_keepalive(Some(Duration::from_secs(60)));
+        if local_block_engine_config
+            .block_engine_url
+            .starts_with("https")
+        {
+            backend_endpoint = backend_endpoint
+                .tls_config(tonic::transport::ClientTlsConfig::new())
+                .map_err(|_| {
+                    ProxyError::BlockEngineConnectionError(
+                        "failed to set tls_config for block engine service".to_string(),
+                    )
+                })?;
+        }
+
+        debug!(
+            "connecting to auth: {}",
+            local_block_engine_config.block_engine_url
+        );
+        let auth_channel = timeout(*connection_timeout, backend_endpoint.connect())
+            .await
+            .map_err(|_| ProxyError::AuthenticationConnectionTimeout)?
+            .map_err(|e| ProxyError::AuthenticationConnectionError(e.to_string()))?;
+
+        let mut auth_client = AuthServiceClient::new(auth_channel);
+
+        debug!("generating authentication token");
+        let (access_token, refresh_token) = timeout(
+            *connection_timeout,
+            generate_auth_tokens(&mut auth_client, &keypair),
+        )
+        .await
+        .map_err(|_| ProxyError::AuthenticationTimeout)??;
+
+        datapoint_info!(
+            "block_engine_stage-tokens_generated",
+            ("url", local_block_engine_config.block_engine_url, String),
+            ("count", 1, i64),
+        );
+
+        debug!(
+            "connecting to block engine: {}",
+            local_block_engine_config.block_engine_url
+        );
+        let block_engine_channel = timeout(*connection_timeout, backend_endpoint.connect())
+            .await
+            .map_err(|_| ProxyError::BlockEngineConnectionTimeout)?
+            .map_err(|e| ProxyError::BlockEngineConnectionError(e.to_string()))?;
+
+        let access_token = Arc::new(Mutex::new(access_token));
+        let block_engine_client = BlockEngineValidatorClient::with_interceptor(
+            block_engine_channel,
+            AuthInterceptor::new(access_token.clone()),
+        );
+
+        Self::start_consuming_block_engine_bundles_and_packets(
+            bundle_tx,
+            block_engine_client,
+            packet_tx,
+            local_block_engine_config,
+            global_block_engine_config,
+            banking_packet_sender,
+            exit,
+            block_builder_fee_info,
+            auth_client,
+            access_token,
+            refresh_token,
+            connection_timeout,
+            keypair,
+            cluster_info,
+        )
+        .await
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn start_consuming_block_engine_bundles_and_packets(
+        bundle_tx: &Sender<Vec<PacketBundle>>,
+        mut client: BlockEngineValidatorClient<InterceptedService<Channel, AuthInterceptor>>,
+        packet_tx: &Sender<PacketBatch>,
+        local_config: &BlockEngineConfig, // local copy of config with current connections
+        global_config: &Arc<Mutex<BlockEngineConfig>>, // guarded reference for detecting run-time updates
+        banking_packet_sender: &BankingPacketSender,
+        exit: &Arc<AtomicBool>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        auth_client: AuthServiceClient<Channel>,
+        access_token: Arc<Mutex<Token>>,
+        refresh_token: Token,
+        connection_timeout: &Duration,
+        keypair: Arc<Keypair>,
+        cluster_info: &Arc<ClusterInfo>,
+    ) -> crate::proxy::Result<()> {
+        let subscribe_packets_stream = timeout(
+            *connection_timeout,
+            client.subscribe_packets(block_engine::SubscribePacketsRequest {}),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("block_engine_subscribe_packets".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?
+        .into_inner();
+
+        let subscribe_bundles_stream = timeout(
+            *connection_timeout,
+            client.subscribe_bundles(block_engine::SubscribeBundlesRequest {}),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("subscribe_bundles".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?
+        .into_inner();
+
+        let block_builder_info = timeout(
+            *connection_timeout,
+            client.get_block_builder_fee_info(BlockBuilderFeeInfoRequest {}),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("get_block_builder_fee_info".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?
+        .into_inner();
+
+        {
+            let block_builder_fee_info = block_builder_fee_info.clone();
+            task::spawn_blocking(move || {
+                let mut bb_fee = block_builder_fee_info.lock().unwrap();
+                bb_fee.block_builder_commission = block_builder_info.commission;
+                if let Ok(pk) = Pubkey::from_str(&block_builder_info.pubkey) {
+                    bb_fee.block_builder = pk
+                }
+            })
+            .await
+            .unwrap();
+        }
+
+        Self::consume_bundle_and_packet_stream(
+            client,
+            (subscribe_bundles_stream, subscribe_packets_stream),
+            bundle_tx,
+            packet_tx,
+            local_config,
+            global_config,
+            banking_packet_sender,
+            exit,
+            block_builder_fee_info,
+            auth_client,
+            access_token,
+            refresh_token,
+            keypair,
+            cluster_info,
+            connection_timeout,
+        )
+        .await
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn consume_bundle_and_packet_stream(
+        mut client: BlockEngineValidatorClient<InterceptedService<Channel, AuthInterceptor>>,
+        (mut bundle_stream, mut packet_stream): (
+            Streaming<block_engine::SubscribeBundlesResponse>,
+            Streaming<block_engine::SubscribePacketsResponse>,
+        ),
+        bundle_tx: &Sender<Vec<PacketBundle>>,
+        packet_tx: &Sender<PacketBatch>,
+        local_config: &BlockEngineConfig, // local copy of config with current connections
+        global_config: &Arc<Mutex<BlockEngineConfig>>, // guarded reference for detecting run-time updates
+        banking_packet_sender: &BankingPacketSender,
+        exit: &Arc<AtomicBool>,
+        block_builder_fee_info: &Arc<Mutex<BlockBuilderFeeInfo>>,
+        mut auth_client: AuthServiceClient<Channel>,
+        access_token: Arc<Mutex<Token>>,
+        mut refresh_token: Token,
+        keypair: Arc<Keypair>,
+        cluster_info: &Arc<ClusterInfo>,
+        connection_timeout: &Duration,
+    ) -> crate::proxy::Result<()> {
+        const METRICS_TICK: Duration = Duration::from_secs(1);
+        const MAINTENANCE_TICK: Duration = Duration::from_secs(10 * 60);
+        let refresh_within_s: u64 = METRICS_TICK.as_secs().saturating_mul(3).saturating_div(2);
+
+        let mut num_full_refreshes: u64 = 1;
+        let mut num_refresh_access_token: u64 = 0;
+        let mut block_engine_stats = BlockEngineStageStats::default();
+        let mut metrics_and_auth_tick = interval(METRICS_TICK);
+        let mut maintenance_tick = interval(MAINTENANCE_TICK);
+
+        info!("connected to packet and bundle stream");
+
+        while !exit.load(Ordering::Relaxed) {
+            tokio::select! {
+                maybe_msg = packet_stream.message() => {
+                    let resp = maybe_msg?.ok_or(ProxyError::GrpcStreamDisconnected)?;
+                    Self::handle_block_engine_packets(resp, packet_tx, banking_packet_sender, local_config.trust_packets, &mut block_engine_stats)?;
+                }
+                maybe_bundles = bundle_stream.message() => {
+                    Self::handle_block_engine_maybe_bundles(maybe_bundles, bundle_tx, &mut block_engine_stats)?;
+                }
+                _ = metrics_and_auth_tick.tick() => {
+                    block_engine_stats.report();
+                    block_engine_stats = BlockEngineStageStats::default();
+
+                    if cluster_info.id() != keypair.pubkey() {
+                        return Err(ProxyError::AuthenticationConnectionError("validator identity changed".to_string()));
+                    }
+
+                    let global_config = global_config.clone();
+                    if *local_config != task::spawn_blocking(move || global_config.lock().unwrap().clone())
+                        .await
+                        .unwrap() {
+                        return Err(ProxyError::AuthenticationConnectionError("block engine config changed".to_string()));
+                    }
+
+                    let (maybe_new_access, maybe_new_refresh) = maybe_refresh_auth_tokens(&mut auth_client,
+                        &access_token,
+                        &refresh_token,
+                        cluster_info,
+                        connection_timeout,
+                        refresh_within_s,
+                    ).await?;
+
+                    if let Some(new_token) = maybe_new_access {
+                        num_refresh_access_token += 1;
+                        datapoint_info!(
+                            "block_engine_stage-refresh_access_token",
+                            ("url", &local_config.block_engine_url, String),
+                            ("count", num_refresh_access_token, i64),
+                        );
+
+                        let access_token = access_token.clone();
+                        task::spawn_blocking(move || *access_token.lock().unwrap() = new_token)
+                            .await
+                            .unwrap();
+                    }
+                    if let Some(new_token) = maybe_new_refresh {
+                        num_full_refreshes += 1;
+                        datapoint_info!(
+                            "block_engine_stage-tokens_generated",
+                            ("url", &local_config.block_engine_url, String),
+                            ("count", num_full_refreshes, i64),
+                        );
+                        refresh_token = new_token;
+                    }
+                }
+                _ = maintenance_tick.tick() => {
+                    let block_builder_info = timeout(
+                        *connection_timeout,
+                        client.get_block_builder_fee_info(BlockBuilderFeeInfoRequest{})
+                    )
+                    .await
+                    .map_err(|_| ProxyError::MethodTimeout("get_block_builder_fee_info".to_string()))?
+                    .map_err(|e| ProxyError::MethodError(e.to_string()))?
+                    .into_inner();
+
+                    let block_builder_fee_info = block_builder_fee_info.clone();
+                    task::spawn_blocking(move || {
+                        let mut bb_fee = block_builder_fee_info.lock().unwrap();
+                        bb_fee.block_builder_commission = block_builder_info.commission;
+                        if let Ok(pk) = Pubkey::from_str(&block_builder_info.pubkey) {
+                            bb_fee.block_builder = pk
+                        }
+                    })
+                    .await
+                    .unwrap();
+                }
+            }
+        }
+
+        Ok(())
+    }
+
+    fn handle_block_engine_maybe_bundles(
+        maybe_bundles_response: Result<Option<block_engine::SubscribeBundlesResponse>, Status>,
+        bundle_sender: &Sender<Vec<PacketBundle>>,
+        block_engine_stats: &mut BlockEngineStageStats,
+    ) -> crate::proxy::Result<()> {
+        let bundles_response = maybe_bundles_response?.ok_or(ProxyError::GrpcStreamDisconnected)?;
+        let bundles: Vec<PacketBundle> = bundles_response
+            .bundles
+            .into_iter()
+            .filter_map(|bundle| {
+                Some(PacketBundle {
+                    batch: PacketBatch::new(
+                        bundle
+                            .bundle?
+                            .packets
+                            .into_iter()
+                            .map(proto_packet_to_packet)
+                            .collect(),
+                    ),
+                    bundle_id: bundle.uuid,
+                })
+            })
+            .collect();
+
+        saturating_add_assign!(block_engine_stats.num_bundles, bundles.len() as u64);
+        saturating_add_assign!(
+            block_engine_stats.num_bundle_packets,
+            bundles.iter().map(|bundle| bundle.batch.len() as u64).sum()
+        );
+
+        // NOTE: bundles are sanitized in bundle_sanitizer module
+        bundle_sender
+            .send(bundles)
+            .map_err(|_| ProxyError::PacketForwardError)
+    }
+
+    fn handle_block_engine_packets(
+        resp: block_engine::SubscribePacketsResponse,
+        packet_tx: &Sender<PacketBatch>,
+        banking_packet_sender: &BankingPacketSender,
+        trust_packets: bool,
+        block_engine_stats: &mut BlockEngineStageStats,
+    ) -> crate::proxy::Result<()> {
+        if let Some(batch) = resp.batch {
+            if batch.packets.is_empty() {
+                saturating_add_assign!(block_engine_stats.num_empty_packets, 1);
+                return Ok(());
+            }
+
+            let packet_batch = PacketBatch::new(
+                batch
+                    .packets
+                    .into_iter()
+                    .map(proto_packet_to_packet)
+                    .collect(),
+            );
+
+            saturating_add_assign!(block_engine_stats.num_packets, packet_batch.len() as u64);
+
+            if trust_packets {
+                banking_packet_sender
+                    .send(Arc::new((vec![packet_batch], None)))
+                    .map_err(|_| ProxyError::PacketForwardError)?;
+            } else {
+                packet_tx
+                    .send(packet_batch)
+                    .map_err(|_| ProxyError::PacketForwardError)?;
+            }
+        } else {
+            saturating_add_assign!(block_engine_stats.num_empty_packets, 1);
+        }
+
+        Ok(())
+    }
+
+    pub fn is_valid_block_engine_config(config: &BlockEngineConfig) -> bool {
+        if config.block_engine_url.is_empty() {
+            warn!("can't connect to block_engine. missing block_engine_url.");
+            return false;
+        }
+        if let Err(e) = Endpoint::from_str(&config.block_engine_url) {
+            error!(
+                "can't connect to block engine. error creating block engine endpoint - {}",
+                e.to_string()
+            );
+            return false;
+        }
+        true
+    }
+}
diff --git a/core/src/proxy/fetch_stage_manager.rs b/core/src/proxy/fetch_stage_manager.rs
new file mode 100644
index 000000000000..0d26c001a767
--- /dev/null
+++ b/core/src/proxy/fetch_stage_manager.rs
@@ -0,0 +1,170 @@
+use {
+    crate::proxy::{HeartbeatEvent, ProxyError},
+    crossbeam_channel::{select, tick, Receiver, Sender},
+    solana_client::connection_cache::Protocol,
+    solana_gossip::{cluster_info::ClusterInfo, contact_info},
+    solana_perf::packet::PacketBatch,
+    std::{
+        net::SocketAddr,
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc,
+        },
+        thread::{self, Builder, JoinHandle},
+        time::{Duration, Instant},
+    },
+};
+
+const HEARTBEAT_TIMEOUT: Duration = Duration::from_millis(1500); // Empirically determined from load testing
+const DISCONNECT_DELAY: Duration = Duration::from_secs(60);
+const METRICS_CADENCE: Duration = Duration::from_secs(1);
+
+/// Manages switching between the validator's tpu ports and that of the proxy's.
+/// Switch-overs are triggered by late and missed heartbeats.    
+pub struct FetchStageManager {
+    t_hdl: JoinHandle<()>,
+}
+
+impl FetchStageManager {
+    pub fn new(
+        // ClusterInfo is used to switch between advertising the proxy's TPU ports and that of this validator's.
+        cluster_info: Arc<ClusterInfo>,
+        // Channel that heartbeats are received from. Entirely responsible for triggering switch-overs.
+        heartbeat_rx: Receiver<HeartbeatEvent>,
+        // Channel that packets from FetchStage are intercepted from.
+        packet_intercept_rx: Receiver<PacketBatch>,
+        // Intercepted packets get piped through here.
+        packet_tx: Sender<PacketBatch>,
+        exit: Arc<AtomicBool>,
+    ) -> Self {
+        let t_hdl = Self::start(
+            cluster_info,
+            heartbeat_rx,
+            packet_intercept_rx,
+            packet_tx,
+            exit,
+        );
+
+        Self { t_hdl }
+    }
+
+    /// Disconnect fetch behaviour
+    /// Starts connected
+    /// When connected and a packet is received, forward it
+    /// When disconnected, packet is dropped
+    /// When receiving heartbeat while connected and not pending disconnect
+    ///      Sets pending_disconnect to true and records time
+    /// When receiving heartbeat while connected, and pending for > DISCONNECT_DELAY_SEC
+    ///      Sets fetch_connected to false, pending_disconnect to false
+    ///      Advertises TPU ports sent in heartbeat
+    /// When tick is received without heartbeat_received
+    ///      Sets fetch_connected to true, pending_disconnect to false
+    ///      Advertises saved contact info
+    fn start(
+        cluster_info: Arc<ClusterInfo>,
+        heartbeat_rx: Receiver<HeartbeatEvent>,
+        packet_intercept_rx: Receiver<PacketBatch>,
+        packet_tx: Sender<PacketBatch>,
+        exit: Arc<AtomicBool>,
+    ) -> JoinHandle<()> {
+        Builder::new().name("fetch-stage-manager".into()).spawn(move || {
+            let my_fallback_contact_info = cluster_info.my_contact_info();
+
+            let mut fetch_connected = true;
+            let mut heartbeat_received = false;
+            let mut pending_disconnect = false;
+
+            let mut pending_disconnect_ts = Instant::now();
+
+            let heartbeat_tick = tick(HEARTBEAT_TIMEOUT);
+            let metrics_tick = tick(METRICS_CADENCE);
+            let mut packets_forwarded = 0;
+            let mut heartbeats_received = 0;
+            loop {
+                select! {
+                    recv(packet_intercept_rx) -> pkt => {
+                        match pkt {
+                            Ok(pkt) => {
+                                if fetch_connected {
+                                    if packet_tx.send(pkt).is_err() {
+                                        error!("{:?}", ProxyError::PacketForwardError);
+                                        return;
+                                    }
+                                    packets_forwarded += 1;
+                                }
+                            }
+                            Err(_) => {
+                                warn!("packet intercept receiver disconnected, shutting down");
+                                return;
+                            }
+                        }
+                    }
+                    recv(heartbeat_tick) -> _ => {
+                        if exit.load(Ordering::Relaxed) {
+                            break;
+                        }
+                        if !heartbeat_received && (!fetch_connected || pending_disconnect) {
+                            warn!("heartbeat late, reconnecting fetch stage");
+                            fetch_connected = true;
+                            pending_disconnect = false;
+
+                            // yes, using UDP here is extremely confusing for the validator
+                            // since the entire network is running QUIC. However, it's correct.
+                            if let Err(e) = Self::set_tpu_addresses(&cluster_info, my_fallback_contact_info.tpu(Protocol::UDP).unwrap(), my_fallback_contact_info.tpu_forwards(Protocol::UDP).unwrap()) {
+                                error!("error setting tpu or tpu_fwd to ({:?}, {:?}), error: {:?}", my_fallback_contact_info.tpu(Protocol::UDP).unwrap(), my_fallback_contact_info.tpu_forwards(Protocol::UDP).unwrap(), e);
+                            }
+                            heartbeats_received = 0;
+                        }
+                        heartbeat_received = false;
+                    }
+                    recv(heartbeat_rx) -> tpu_info => {
+                        if let Ok((tpu_addr, tpu_forward_addr)) = tpu_info {
+                            heartbeats_received += 1;
+                            heartbeat_received = true;
+                            if fetch_connected && !pending_disconnect {
+                                info!("received heartbeat while fetch stage connected, pending disconnect after delay");
+                                pending_disconnect_ts = Instant::now();
+                                pending_disconnect = true;
+                            }
+                            if fetch_connected && pending_disconnect && pending_disconnect_ts.elapsed() > DISCONNECT_DELAY {
+                                info!("disconnecting fetch stage");
+                                fetch_connected = false;
+                                pending_disconnect = false;
+                                if let Err(e) = Self::set_tpu_addresses(&cluster_info, tpu_addr, tpu_forward_addr) {
+                                    error!("error setting tpu or tpu_fwd to ({:?}, {:?}), error: {:?}", tpu_addr, tpu_forward_addr, e);
+                                }
+                            }
+                        } else {
+                            {
+                                warn!("relayer heartbeat receiver disconnected, shutting down");
+                                return;
+                            }
+                        }
+                    }
+                    recv(metrics_tick) -> _ => {
+                        datapoint_info!(
+                            "relayer-heartbeat",
+                            ("fetch_stage_packets_forwarded", packets_forwarded, i64),
+                            ("heartbeats_received", heartbeats_received, i64),
+                        );
+
+                    }
+                }
+            }
+        }).unwrap()
+    }
+
+    fn set_tpu_addresses(
+        cluster_info: &Arc<ClusterInfo>,
+        tpu_address: SocketAddr,
+        tpu_forward_address: SocketAddr,
+    ) -> Result<(), contact_info::Error> {
+        cluster_info.set_tpu(tpu_address)?;
+        cluster_info.set_tpu_forwards(tpu_forward_address)?;
+        Ok(())
+    }
+
+    pub fn join(self) -> thread::Result<()> {
+        self.t_hdl.join()
+    }
+}
diff --git a/core/src/proxy/mod.rs b/core/src/proxy/mod.rs
new file mode 100644
index 000000000000..86d48482aaa8
--- /dev/null
+++ b/core/src/proxy/mod.rs
@@ -0,0 +1,100 @@
+//! This module contains logic for connecting to an external Relayer and Block Engine.
+//! The Relayer acts as an external TPU and TPU Forward socket while the Block Engine
+//! is tasked with streaming high value bundles to the validator. The validator can run
+//! in one of 3 modes:
+//!     1. Connected to Relayer and Block Engine.
+//!         - This is the ideal mode as it increases the probability of building the most profitable blocks.
+//!     2. Connected only to Relayer.
+//!         - A validator may choose to run in this mode if the main concern is to offload ingress traffic deduplication and sig-verification.
+//!     3. Connected only to Block Engine.
+//!         - Running in this mode means pending transactions are not exposed to external actors. This mode is ideal if the validator wishes
+//!           to accept bundles while maintaining some level of privacy for in-flight transactions.
+
+mod auth;
+pub mod block_engine_stage;
+pub mod fetch_stage_manager;
+pub mod relayer_stage;
+
+use {
+    std::{
+        net::{AddrParseError, SocketAddr},
+        result,
+    },
+    thiserror::Error,
+    tonic::Status,
+};
+
+type Result<T> = result::Result<T, ProxyError>;
+type HeartbeatEvent = (SocketAddr, SocketAddr);
+
+#[derive(Error, Debug)]
+pub enum ProxyError {
+    #[error("grpc error: {0}")]
+    GrpcError(#[from] Status),
+
+    #[error("stream disconnected")]
+    GrpcStreamDisconnected,
+
+    #[error("heartbeat error")]
+    HeartbeatChannelError,
+
+    #[error("heartbeat expired")]
+    HeartbeatExpired,
+
+    #[error("error forwarding packet to banking stage")]
+    PacketForwardError,
+
+    #[error("missing tpu config: {0:?}")]
+    MissingTpuSocket(String),
+
+    #[error("invalid socket address: {0:?}")]
+    InvalidSocketAddress(#[from] AddrParseError),
+
+    #[error("invalid gRPC data: {0:?}")]
+    InvalidData(String),
+
+    #[error("timeout: {0:?}")]
+    ConnectionError(#[from] tonic::transport::Error),
+
+    #[error("AuthenticationConnectionTimeout")]
+    AuthenticationConnectionTimeout,
+
+    #[error("AuthenticationTimeout")]
+    AuthenticationTimeout,
+
+    #[error("AuthenticationConnectionError: {0:?}")]
+    AuthenticationConnectionError(String),
+
+    #[error("BlockEngineConnectionTimeout")]
+    BlockEngineConnectionTimeout,
+
+    #[error("BlockEngineTimeout")]
+    BlockEngineTimeout,
+
+    #[error("BlockEngineConnectionError: {0:?}")]
+    BlockEngineConnectionError(String),
+
+    #[error("RelayerConnectionTimeout")]
+    RelayerConnectionTimeout,
+
+    #[error("RelayerTimeout")]
+    RelayerEngineTimeout,
+
+    #[error("RelayerConnectionError: {0:?}")]
+    RelayerConnectionError(String),
+
+    #[error("AuthenticationError: {0:?}")]
+    AuthenticationError(String),
+
+    #[error("AuthenticationPermissionDenied")]
+    AuthenticationPermissionDenied,
+
+    #[error("BadAuthenticationToken: {0:?}")]
+    BadAuthenticationToken(String),
+
+    #[error("MethodTimeout: {0:?}")]
+    MethodTimeout(String),
+
+    #[error("MethodError: {0:?}")]
+    MethodError(String),
+}
diff --git a/core/src/proxy/relayer_stage.rs b/core/src/proxy/relayer_stage.rs
new file mode 100644
index 000000000000..0c8ce22877ee
--- /dev/null
+++ b/core/src/proxy/relayer_stage.rs
@@ -0,0 +1,515 @@
+//! Maintains a connection to the Relayer.
+//!
+//! The external Relayer is responsible for the following:
+//! - Acts as a TPU proxy.
+//! - Sends transactions to the validator.
+//! - Does not bundles to avoid DOS vector.
+//! - When validator connects, it changes its TPU and TPU forward address to the relayer.
+//! - Expected to send heartbeat to validator as watchdog. If watchdog times out, the validator
+//!   disconnects and reverts the TPU and TPU forward settings.
+
+use {
+    crate::{
+        banking_trace::BankingPacketSender,
+        proto_packet_to_packet,
+        proxy::{
+            auth::{generate_auth_tokens, maybe_refresh_auth_tokens, AuthInterceptor},
+            HeartbeatEvent, ProxyError,
+        },
+    },
+    crossbeam_channel::Sender,
+    jito_protos::proto::{
+        auth::{auth_service_client::AuthServiceClient, Token},
+        relayer::{self, relayer_client::RelayerClient},
+    },
+    solana_gossip::cluster_info::ClusterInfo,
+    solana_perf::packet::PacketBatch,
+    solana_sdk::{
+        saturating_add_assign,
+        signature::{Keypair, Signer},
+    },
+    std::{
+        net::{IpAddr, Ipv4Addr, SocketAddr},
+        str::FromStr,
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc, Mutex,
+        },
+        thread::{self, Builder, JoinHandle},
+        time::{Duration, Instant},
+    },
+    tokio::{
+        task,
+        time::{interval, sleep, timeout},
+    },
+    tonic::{
+        codegen::InterceptedService,
+        transport::{Channel, Endpoint},
+        Streaming,
+    },
+};
+
+const CONNECTION_TIMEOUT_S: u64 = 10;
+const CONNECTION_BACKOFF_S: u64 = 5;
+
+#[derive(Default)]
+struct RelayerStageStats {
+    num_empty_messages: u64,
+    num_packets: u64,
+    num_heartbeats: u64,
+}
+
+impl RelayerStageStats {
+    pub(crate) fn report(&self) {
+        datapoint_info!(
+            "relayer_stage-stats",
+            ("num_empty_messages", self.num_empty_messages, i64),
+            ("num_packets", self.num_packets, i64),
+            ("num_heartbeats", self.num_heartbeats, i64),
+        );
+    }
+}
+
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
+pub struct RelayerConfig {
+    /// Relayer URL
+    pub relayer_url: String,
+
+    /// Interval at which heartbeats are expected.
+    pub expected_heartbeat_interval: Duration,
+
+    /// The max tolerable age of the last heartbeat.
+    pub oldest_allowed_heartbeat: Duration,
+
+    /// If set then it will be assumed the backend verified packets so signature verification will be bypassed in the validator.
+    pub trust_packets: bool,
+}
+
+pub struct RelayerStage {
+    t_hdls: Vec<JoinHandle<()>>,
+}
+
+impl RelayerStage {
+    pub fn new(
+        relayer_config: Arc<Mutex<RelayerConfig>>,
+        // The keypair stored here is used to sign auth challenges.
+        cluster_info: Arc<ClusterInfo>,
+        // Channel that server-sent heartbeats are piped through.
+        heartbeat_tx: Sender<HeartbeatEvent>,
+        // Channel that non-trusted streamed packets are piped through.
+        packet_tx: Sender<PacketBatch>,
+        // Channel that trusted streamed packets are piped through.
+        banking_packet_sender: BankingPacketSender,
+        exit: Arc<AtomicBool>,
+    ) -> Self {
+        let thread = Builder::new()
+            .name("relayer-stage".to_string())
+            .spawn(move || {
+                let rt = tokio::runtime::Builder::new_multi_thread()
+                    .enable_all()
+                    .build()
+                    .unwrap();
+
+                rt.block_on(Self::start(
+                    relayer_config,
+                    cluster_info,
+                    heartbeat_tx,
+                    packet_tx,
+                    banking_packet_sender,
+                    exit,
+                ));
+            })
+            .unwrap();
+
+        Self {
+            t_hdls: vec![thread],
+        }
+    }
+
+    pub fn join(self) -> thread::Result<()> {
+        for t in self.t_hdls {
+            t.join()?;
+        }
+        Ok(())
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn start(
+        relayer_config: Arc<Mutex<RelayerConfig>>,
+        cluster_info: Arc<ClusterInfo>,
+        heartbeat_tx: Sender<HeartbeatEvent>,
+        packet_tx: Sender<PacketBatch>,
+        banking_packet_sender: BankingPacketSender,
+        exit: Arc<AtomicBool>,
+    ) {
+        const CONNECTION_TIMEOUT: Duration = Duration::from_secs(CONNECTION_TIMEOUT_S);
+        const CONNECTION_BACKOFF: Duration = Duration::from_secs(CONNECTION_BACKOFF_S);
+
+        let mut error_count: u64 = 0;
+
+        while !exit.load(Ordering::Relaxed) {
+            // Wait until a valid config is supplied (either initially or by admin rpc)
+            // Use if!/else here to avoid extra CONNECTION_BACKOFF wait on successful termination
+            let local_relayer_config = {
+                let relayer_config = relayer_config.clone();
+                task::spawn_blocking(move || relayer_config.lock().unwrap().clone())
+                    .await
+                    .expect("Failed to get execute tokio task.")
+            };
+            if !Self::is_valid_relayer_config(&local_relayer_config) {
+                sleep(CONNECTION_BACKOFF).await;
+            } else if let Err(e) = Self::connect_auth_and_stream(
+                &local_relayer_config,
+                &relayer_config,
+                &cluster_info,
+                &heartbeat_tx,
+                &packet_tx,
+                &banking_packet_sender,
+                &exit,
+                &CONNECTION_TIMEOUT,
+            )
+            .await
+            {
+                match e {
+                    // This error is frequent on hot spares, and the parsed string does not work
+                    // with datapoints (incorrect escaping).
+                    ProxyError::AuthenticationPermissionDenied => {
+                        warn!("relayer permission denied. not on leader schedule. ignore if hot-spare.")
+                    }
+                    e => {
+                        error_count += 1;
+                        datapoint_warn!(
+                            "relayer_stage-proxy_error",
+                            ("count", error_count, i64),
+                            ("error", e.to_string(), String),
+                        );
+                    }
+                }
+                sleep(CONNECTION_BACKOFF).await;
+            }
+        }
+    }
+
+    async fn connect_auth_and_stream(
+        local_relayer_config: &RelayerConfig,
+        global_relayer_config: &Arc<Mutex<RelayerConfig>>,
+        cluster_info: &Arc<ClusterInfo>,
+        heartbeat_tx: &Sender<HeartbeatEvent>,
+        packet_tx: &Sender<PacketBatch>,
+        banking_packet_sender: &BankingPacketSender,
+        exit: &Arc<AtomicBool>,
+        connection_timeout: &Duration,
+    ) -> crate::proxy::Result<()> {
+        // Get a copy of configs here in case they have changed at runtime
+        let keypair = cluster_info.keypair().clone();
+
+        let mut backend_endpoint = Endpoint::from_shared(local_relayer_config.relayer_url.clone())
+            .map_err(|_| {
+                ProxyError::RelayerConnectionError(format!(
+                    "invalid relayer url value: {}",
+                    local_relayer_config.relayer_url
+                ))
+            })?
+            .tcp_keepalive(Some(Duration::from_secs(60)));
+        if local_relayer_config.relayer_url.starts_with("https") {
+            backend_endpoint = backend_endpoint
+                .tls_config(tonic::transport::ClientTlsConfig::new())
+                .map_err(|_| {
+                    ProxyError::RelayerConnectionError(
+                        "failed to set tls_config for relayer service".to_string(),
+                    )
+                })?;
+        }
+
+        debug!("connecting to auth: {}", local_relayer_config.relayer_url);
+        let auth_channel = timeout(*connection_timeout, backend_endpoint.connect())
+            .await
+            .map_err(|_| ProxyError::AuthenticationConnectionTimeout)?
+            .map_err(|e| ProxyError::AuthenticationConnectionError(e.to_string()))?;
+
+        let mut auth_client = AuthServiceClient::new(auth_channel);
+
+        debug!("generating authentication token");
+        let (access_token, refresh_token) = timeout(
+            *connection_timeout,
+            generate_auth_tokens(&mut auth_client, &keypair),
+        )
+        .await
+        .map_err(|_| ProxyError::AuthenticationTimeout)??;
+
+        datapoint_info!(
+            "relayer_stage-tokens_generated",
+            ("url", local_relayer_config.relayer_url, String),
+            ("count", 1, i64),
+        );
+
+        debug!(
+            "connecting to relayer: {}",
+            local_relayer_config.relayer_url
+        );
+        let relayer_channel = timeout(*connection_timeout, backend_endpoint.connect())
+            .await
+            .map_err(|_| ProxyError::RelayerConnectionTimeout)?
+            .map_err(|e| ProxyError::RelayerConnectionError(e.to_string()))?;
+
+        let access_token = Arc::new(Mutex::new(access_token));
+        let relayer_client = RelayerClient::with_interceptor(
+            relayer_channel,
+            AuthInterceptor::new(access_token.clone()),
+        );
+
+        Self::start_consuming_relayer_packets(
+            relayer_client,
+            heartbeat_tx,
+            packet_tx,
+            banking_packet_sender,
+            local_relayer_config,
+            global_relayer_config,
+            exit,
+            auth_client,
+            access_token,
+            refresh_token,
+            keypair,
+            cluster_info,
+            connection_timeout,
+        )
+        .await
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn start_consuming_relayer_packets(
+        mut client: RelayerClient<InterceptedService<Channel, AuthInterceptor>>,
+        heartbeat_tx: &Sender<HeartbeatEvent>,
+        packet_tx: &Sender<PacketBatch>,
+        banking_packet_sender: &BankingPacketSender,
+        local_config: &RelayerConfig, // local copy of config with current connections
+        global_config: &Arc<Mutex<RelayerConfig>>, // guarded reference for detecting run-time updates
+        exit: &Arc<AtomicBool>,
+        auth_client: AuthServiceClient<Channel>,
+        access_token: Arc<Mutex<Token>>,
+        refresh_token: Token,
+        keypair: Arc<Keypair>,
+        cluster_info: &Arc<ClusterInfo>,
+        connection_timeout: &Duration,
+    ) -> crate::proxy::Result<()> {
+        let heartbeat_event: HeartbeatEvent = {
+            let tpu_config = timeout(
+                *connection_timeout,
+                client.get_tpu_configs(relayer::GetTpuConfigsRequest {}),
+            )
+            .await
+            .map_err(|_| ProxyError::MethodTimeout("relayer_get_tpu_configs".to_string()))?
+            .map_err(|e| ProxyError::MethodError(e.to_string()))?
+            .into_inner();
+
+            let tpu_addr = tpu_config
+                .tpu
+                .ok_or_else(|| ProxyError::MissingTpuSocket("tpu".to_string()))?;
+            let tpu_forward_addr = tpu_config
+                .tpu_forward
+                .ok_or_else(|| ProxyError::MissingTpuSocket("tpu_fwd".to_string()))?;
+
+            let tpu_ip = IpAddr::from(tpu_addr.ip.parse::<Ipv4Addr>()?);
+            let tpu_forward_ip = IpAddr::from(tpu_forward_addr.ip.parse::<Ipv4Addr>()?);
+
+            let tpu_socket = SocketAddr::new(tpu_ip, tpu_addr.port as u16);
+            let tpu_forward_socket = SocketAddr::new(tpu_forward_ip, tpu_forward_addr.port as u16);
+            (tpu_socket, tpu_forward_socket)
+        };
+
+        let packet_stream = timeout(
+            *connection_timeout,
+            client.subscribe_packets(relayer::SubscribePacketsRequest {}),
+        )
+        .await
+        .map_err(|_| ProxyError::MethodTimeout("relayer_subscribe_packets".to_string()))?
+        .map_err(|e| ProxyError::MethodError(e.to_string()))?
+        .into_inner();
+
+        Self::consume_packet_stream(
+            heartbeat_event,
+            heartbeat_tx,
+            packet_stream,
+            packet_tx,
+            local_config,
+            global_config,
+            banking_packet_sender,
+            exit,
+            auth_client,
+            access_token,
+            refresh_token,
+            keypair,
+            cluster_info,
+            connection_timeout,
+        )
+        .await
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    async fn consume_packet_stream(
+        heartbeat_event: HeartbeatEvent,
+        heartbeat_tx: &Sender<HeartbeatEvent>,
+        mut packet_stream: Streaming<relayer::SubscribePacketsResponse>,
+        packet_tx: &Sender<PacketBatch>,
+        local_config: &RelayerConfig, // local copy of config with current connections
+        global_config: &Arc<Mutex<RelayerConfig>>, // guarded reference for detecting run-time updates
+        banking_packet_sender: &BankingPacketSender,
+        exit: &Arc<AtomicBool>,
+        mut auth_client: AuthServiceClient<Channel>,
+        access_token: Arc<Mutex<Token>>,
+        mut refresh_token: Token,
+        keypair: Arc<Keypair>,
+        cluster_info: &Arc<ClusterInfo>,
+        connection_timeout: &Duration,
+    ) -> crate::proxy::Result<()> {
+        const METRICS_TICK: Duration = Duration::from_secs(1);
+        let refresh_within_s: u64 = METRICS_TICK.as_secs().saturating_mul(3).saturating_div(2);
+
+        let mut relayer_stats = RelayerStageStats::default();
+        let mut metrics_and_auth_tick = interval(METRICS_TICK);
+
+        let mut num_full_refreshes: u64 = 1;
+        let mut num_refresh_access_token: u64 = 0;
+
+        let mut heartbeat_check_interval = interval(local_config.expected_heartbeat_interval);
+        let mut last_heartbeat_ts = Instant::now();
+
+        info!("connected to packet stream");
+
+        while !exit.load(Ordering::Relaxed) {
+            tokio::select! {
+                maybe_msg = packet_stream.message() => {
+                    let resp = maybe_msg?.ok_or(ProxyError::GrpcStreamDisconnected)?;
+                    Self::handle_relayer_packets(resp, heartbeat_event, heartbeat_tx, &mut last_heartbeat_ts, packet_tx, local_config.trust_packets, banking_packet_sender, &mut relayer_stats)?;
+                }
+                _ = heartbeat_check_interval.tick() => {
+                    if last_heartbeat_ts.elapsed() > local_config.oldest_allowed_heartbeat {
+                        return Err(ProxyError::HeartbeatExpired);
+                    }
+                }
+                _ = metrics_and_auth_tick.tick() => {
+                    relayer_stats.report();
+                    relayer_stats = RelayerStageStats::default();
+
+                    if cluster_info.id() != keypair.pubkey() {
+                        return Err(ProxyError::AuthenticationConnectionError("validator identity changed".to_string()));
+                    }
+
+                    let global_config = global_config.clone();
+                    if *local_config != task::spawn_blocking(move || global_config.lock().unwrap().clone())
+                        .await
+                        .unwrap() {
+                        return Err(ProxyError::AuthenticationConnectionError("relayer config changed".to_string()));
+                    }
+
+                    let (maybe_new_access, maybe_new_refresh) = maybe_refresh_auth_tokens(&mut auth_client,
+                        &access_token,
+                        &refresh_token,
+                        cluster_info,
+                        connection_timeout,
+                        refresh_within_s,
+                    ).await?;
+
+                    if let Some(new_token) = maybe_new_access {
+                        num_refresh_access_token += 1;
+                        datapoint_info!(
+                            "relayer_stage-refresh_access_token",
+                            ("url", &local_config.relayer_url, String),
+                            ("count", num_refresh_access_token, i64),
+                        );
+
+                        let access_token = access_token.clone();
+                        task::spawn_blocking(move || *access_token.lock().unwrap() = new_token)
+                            .await
+                            .unwrap();
+                    }
+                    if let Some(new_token) = maybe_new_refresh {
+                        num_full_refreshes += 1;
+                        datapoint_info!(
+                            "relayer_stage-tokens_generated",
+                            ("url", &local_config.relayer_url, String),
+                            ("count", num_full_refreshes, i64),
+                        );
+                        refresh_token = new_token;
+                    }
+                }
+            }
+        }
+        Ok(())
+    }
+
+    fn handle_relayer_packets(
+        subscribe_packets_resp: relayer::SubscribePacketsResponse,
+        heartbeat_event: HeartbeatEvent,
+        heartbeat_tx: &Sender<HeartbeatEvent>,
+        last_heartbeat_ts: &mut Instant,
+        packet_tx: &Sender<PacketBatch>,
+        trust_packets: bool,
+        banking_packet_sender: &BankingPacketSender,
+        relayer_stats: &mut RelayerStageStats,
+    ) -> crate::proxy::Result<()> {
+        match subscribe_packets_resp.msg {
+            None => {
+                saturating_add_assign!(relayer_stats.num_empty_messages, 1);
+            }
+            Some(relayer::subscribe_packets_response::Msg::Batch(proto_batch)) => {
+                if proto_batch.packets.is_empty() {
+                    saturating_add_assign!(relayer_stats.num_empty_messages, 1);
+                    return Ok(());
+                }
+
+                let packet_batch = PacketBatch::new(
+                    proto_batch
+                        .packets
+                        .into_iter()
+                        .map(proto_packet_to_packet)
+                        .collect(),
+                );
+
+                saturating_add_assign!(relayer_stats.num_packets, packet_batch.len() as u64);
+
+                if trust_packets {
+                    banking_packet_sender
+                        .send(Arc::new((vec![packet_batch], None)))
+                        .map_err(|_| ProxyError::PacketForwardError)?;
+                } else {
+                    packet_tx
+                        .send(packet_batch)
+                        .map_err(|_| ProxyError::PacketForwardError)?;
+                }
+            }
+            Some(relayer::subscribe_packets_response::Msg::Heartbeat(_)) => {
+                saturating_add_assign!(relayer_stats.num_heartbeats, 1);
+
+                *last_heartbeat_ts = Instant::now();
+                heartbeat_tx
+                    .send(heartbeat_event)
+                    .map_err(|_| ProxyError::HeartbeatChannelError)?;
+            }
+        }
+        Ok(())
+    }
+
+    pub fn is_valid_relayer_config(config: &RelayerConfig) -> bool {
+        if config.relayer_url.is_empty() {
+            warn!("can't connect to relayer. missing relayer_url.");
+            return false;
+        }
+        if config.oldest_allowed_heartbeat.is_zero() {
+            error!("can't connect to relayer. oldest allowed heartbeat must be greater than 0.");
+            return false;
+        }
+        if config.expected_heartbeat_interval.is_zero() {
+            error!("can't connect to relayer. expected heartbeat interval must be greater than 0.");
+            return false;
+        }
+        if let Err(e) = Endpoint::from_str(&config.relayer_url) {
+            error!(
+                "can't connect to relayer. error creating relayer endpoint - {}",
+                e.to_string()
+            );
+            return false;
+        }
+        true
+    }
+}
diff --git a/core/src/tip_manager.rs b/core/src/tip_manager.rs
new file mode 100644
index 000000000000..397dfffea1c4
--- /dev/null
+++ b/core/src/tip_manager.rs
@@ -0,0 +1,588 @@
+use {
+    crate::proxy::block_engine_stage::BlockBuilderFeeInfo,
+    anchor_lang::{AccountDeserialize, InstructionData, ToAccountMetas},
+    jito_tip_distribution::sdk::{
+        derive_config_account_address, derive_tip_distribution_account_address,
+        instruction::{
+            initialize_ix, initialize_tip_distribution_account_ix, InitializeAccounts,
+            InitializeArgs, InitializeTipDistributionAccountAccounts,
+            InitializeTipDistributionAccountArgs,
+        },
+    },
+    jito_tip_payment::{
+        Config, InitBumps, TipPaymentAccount, CONFIG_ACCOUNT_SEED, TIP_ACCOUNT_SEED_0,
+        TIP_ACCOUNT_SEED_1, TIP_ACCOUNT_SEED_2, TIP_ACCOUNT_SEED_3, TIP_ACCOUNT_SEED_4,
+        TIP_ACCOUNT_SEED_5, TIP_ACCOUNT_SEED_6, TIP_ACCOUNT_SEED_7,
+    },
+    log::warn,
+    solana_bundle::TipError,
+    solana_runtime::bank::Bank,
+    solana_sdk::{
+        account::ReadableAccount,
+        bundle::{derive_bundle_id_from_sanitized_transactions, SanitizedBundle},
+        instruction::Instruction,
+        pubkey::Pubkey,
+        signature::Keypair,
+        signer::Signer,
+        stake_history::Epoch,
+        system_program,
+        transaction::{SanitizedTransaction, Transaction},
+    },
+    std::{collections::HashSet, sync::Arc},
+};
+
+pub type Result<T> = std::result::Result<T, TipError>;
+
+#[derive(Debug, Clone)]
+struct TipPaymentProgramInfo {
+    program_id: Pubkey,
+
+    config_pda_bump: (Pubkey, u8),
+    tip_pda_0: (Pubkey, u8),
+    tip_pda_1: (Pubkey, u8),
+    tip_pda_2: (Pubkey, u8),
+    tip_pda_3: (Pubkey, u8),
+    tip_pda_4: (Pubkey, u8),
+    tip_pda_5: (Pubkey, u8),
+    tip_pda_6: (Pubkey, u8),
+    tip_pda_7: (Pubkey, u8),
+}
+
+/// Contains metadata regarding the tip-distribution account.
+/// The PDAs contained in this struct are presumed to be owned by the program.
+#[derive(Debug, Clone)]
+struct TipDistributionProgramInfo {
+    /// The tip-distribution program_id.
+    program_id: Pubkey,
+
+    /// Singleton [Config] PDA and bump tuple.
+    config_pda_and_bump: (Pubkey, u8),
+}
+
+/// This config is used on each invocation to the `initialize_tip_distribution_account` instruction.
+#[derive(Debug, Clone)]
+pub struct TipDistributionAccountConfig {
+    /// The account with authority to upload merkle-roots to this validator's [TipDistributionAccount].
+    pub merkle_root_upload_authority: Pubkey,
+
+    /// This validator's vote account.
+    pub vote_account: Pubkey,
+
+    /// This validator's commission rate BPS for tips in the [TipDistributionAccount].
+    pub commission_bps: u16,
+}
+
+impl Default for TipDistributionAccountConfig {
+    fn default() -> Self {
+        Self {
+            merkle_root_upload_authority: Pubkey::new_unique(),
+            vote_account: Pubkey::new_unique(),
+            commission_bps: 0,
+        }
+    }
+}
+
+#[derive(Debug, Clone)]
+pub struct TipManager {
+    tip_payment_program_info: TipPaymentProgramInfo,
+    tip_distribution_program_info: TipDistributionProgramInfo,
+    tip_distribution_account_config: TipDistributionAccountConfig,
+}
+
+#[derive(Clone)]
+pub struct TipManagerConfig {
+    pub tip_payment_program_id: Pubkey,
+    pub tip_distribution_program_id: Pubkey,
+    pub tip_distribution_account_config: TipDistributionAccountConfig,
+}
+
+impl Default for TipManagerConfig {
+    fn default() -> Self {
+        TipManagerConfig {
+            tip_payment_program_id: Pubkey::new_unique(),
+            tip_distribution_program_id: Pubkey::new_unique(),
+            tip_distribution_account_config: TipDistributionAccountConfig::default(),
+        }
+    }
+}
+
+impl TipManager {
+    pub fn new(config: TipManagerConfig) -> TipManager {
+        let TipManagerConfig {
+            tip_payment_program_id,
+            tip_distribution_program_id,
+            tip_distribution_account_config,
+        } = config;
+
+        let config_pda_bump =
+            Pubkey::find_program_address(&[CONFIG_ACCOUNT_SEED], &tip_payment_program_id);
+
+        let tip_pda_0 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_0], &tip_payment_program_id);
+        let tip_pda_1 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_1], &tip_payment_program_id);
+        let tip_pda_2 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_2], &tip_payment_program_id);
+        let tip_pda_3 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_3], &tip_payment_program_id);
+        let tip_pda_4 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_4], &tip_payment_program_id);
+        let tip_pda_5 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_5], &tip_payment_program_id);
+        let tip_pda_6 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_6], &tip_payment_program_id);
+        let tip_pda_7 =
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_7], &tip_payment_program_id);
+
+        let config_pda_and_bump = derive_config_account_address(&tip_distribution_program_id);
+
+        TipManager {
+            tip_payment_program_info: TipPaymentProgramInfo {
+                program_id: tip_payment_program_id,
+                config_pda_bump,
+                tip_pda_0,
+                tip_pda_1,
+                tip_pda_2,
+                tip_pda_3,
+                tip_pda_4,
+                tip_pda_5,
+                tip_pda_6,
+                tip_pda_7,
+            },
+            tip_distribution_program_info: TipDistributionProgramInfo {
+                program_id: tip_distribution_program_id,
+                config_pda_and_bump,
+            },
+            tip_distribution_account_config,
+        }
+    }
+
+    pub fn tip_payment_program_id(&self) -> Pubkey {
+        self.tip_payment_program_info.program_id
+    }
+
+    pub fn tip_distribution_program_id(&self) -> Pubkey {
+        self.tip_distribution_program_info.program_id
+    }
+
+    /// Returns the [Config] account owned by the tip-payment program.
+    pub fn tip_payment_config_pubkey(&self) -> Pubkey {
+        self.tip_payment_program_info.config_pda_bump.0
+    }
+
+    /// Returns the [Config] account owned by the tip-distribution program.
+    pub fn tip_distribution_config_pubkey(&self) -> Pubkey {
+        self.tip_distribution_program_info.config_pda_and_bump.0
+    }
+
+    /// Given a bank, returns the current `tip_receiver` configured with the tip-payment program.
+    pub fn get_configured_tip_receiver(&self, bank: &Bank) -> Result<Pubkey> {
+        Ok(self.get_tip_payment_config_account(bank)?.tip_receiver)
+    }
+
+    pub fn get_tip_accounts(&self) -> HashSet<Pubkey> {
+        HashSet::from([
+            self.tip_payment_program_info.tip_pda_0.0,
+            self.tip_payment_program_info.tip_pda_1.0,
+            self.tip_payment_program_info.tip_pda_2.0,
+            self.tip_payment_program_info.tip_pda_3.0,
+            self.tip_payment_program_info.tip_pda_4.0,
+            self.tip_payment_program_info.tip_pda_5.0,
+            self.tip_payment_program_info.tip_pda_6.0,
+            self.tip_payment_program_info.tip_pda_7.0,
+        ])
+    }
+
+    pub fn get_tip_payment_config_account(&self, bank: &Bank) -> Result<Config> {
+        let config_data = bank
+            .get_account(&self.tip_payment_program_info.config_pda_bump.0)
+            .ok_or(TipError::AccountMissing(
+                self.tip_payment_program_info.config_pda_bump.0,
+            ))?;
+
+        Ok(Config::try_deserialize(&mut config_data.data())?)
+    }
+
+    /// Only called once during contract creation.
+    pub fn initialize_tip_payment_program_tx(
+        &self,
+        bank: &Bank,
+        keypair: &Keypair,
+    ) -> SanitizedTransaction {
+        let init_ix = Instruction {
+            program_id: self.tip_payment_program_info.program_id,
+            data: jito_tip_payment::instruction::Initialize {
+                _bumps: InitBumps {
+                    config: self.tip_payment_program_info.config_pda_bump.1,
+                    tip_payment_account_0: self.tip_payment_program_info.tip_pda_0.1,
+                    tip_payment_account_1: self.tip_payment_program_info.tip_pda_1.1,
+                    tip_payment_account_2: self.tip_payment_program_info.tip_pda_2.1,
+                    tip_payment_account_3: self.tip_payment_program_info.tip_pda_3.1,
+                    tip_payment_account_4: self.tip_payment_program_info.tip_pda_4.1,
+                    tip_payment_account_5: self.tip_payment_program_info.tip_pda_5.1,
+                    tip_payment_account_6: self.tip_payment_program_info.tip_pda_6.1,
+                    tip_payment_account_7: self.tip_payment_program_info.tip_pda_7.1,
+                },
+            }
+            .data(),
+            accounts: jito_tip_payment::accounts::Initialize {
+                config: self.tip_payment_program_info.config_pda_bump.0,
+                tip_payment_account_0: self.tip_payment_program_info.tip_pda_0.0,
+                tip_payment_account_1: self.tip_payment_program_info.tip_pda_1.0,
+                tip_payment_account_2: self.tip_payment_program_info.tip_pda_2.0,
+                tip_payment_account_3: self.tip_payment_program_info.tip_pda_3.0,
+                tip_payment_account_4: self.tip_payment_program_info.tip_pda_4.0,
+                tip_payment_account_5: self.tip_payment_program_info.tip_pda_5.0,
+                tip_payment_account_6: self.tip_payment_program_info.tip_pda_6.0,
+                tip_payment_account_7: self.tip_payment_program_info.tip_pda_7.0,
+                system_program: system_program::id(),
+                payer: keypair.pubkey(),
+            }
+            .to_account_metas(None),
+        };
+        SanitizedTransaction::try_from_legacy_transaction(
+            Transaction::new_signed_with_payer(
+                &[init_ix],
+                Some(&keypair.pubkey()),
+                &[keypair],
+                bank.last_blockhash(),
+            ),
+            bank.get_reserved_account_keys(),
+        )
+        .unwrap()
+    }
+
+    /// Returns this validator's [TipDistributionAccount] PDA derived from the provided epoch.
+    pub fn get_my_tip_distribution_pda(&self, epoch: Epoch) -> Pubkey {
+        derive_tip_distribution_account_address(
+            &self.tip_distribution_program_info.program_id,
+            &self.tip_distribution_account_config.vote_account,
+            epoch,
+        )
+        .0
+    }
+
+    /// Returns whether or not the tip-payment program should be initialized.
+    pub fn should_initialize_tip_payment_program(&self, bank: &Bank) -> bool {
+        match bank.get_account(&self.tip_payment_config_pubkey()) {
+            None => true,
+            Some(account) => account.owner() != &self.tip_payment_program_info.program_id,
+        }
+    }
+
+    /// Returns whether or not the tip-distribution program's [Config] PDA should be initialized.
+    pub fn should_initialize_tip_distribution_config(&self, bank: &Bank) -> bool {
+        match bank.get_account(&self.tip_distribution_config_pubkey()) {
+            None => true,
+            Some(account) => account.owner() != &self.tip_distribution_program_info.program_id,
+        }
+    }
+
+    /// Returns whether or not the current [TipDistributionAccount] PDA should be initialized for this epoch.
+    pub fn should_init_tip_distribution_account(&self, bank: &Bank) -> bool {
+        let pda = derive_tip_distribution_account_address(
+            &self.tip_distribution_program_info.program_id,
+            &self.tip_distribution_account_config.vote_account,
+            bank.epoch(),
+        )
+        .0;
+        match bank.get_account(&pda) {
+            None => true,
+            // Since anyone can derive the PDA and send it lamports we must also check the owner is the program.
+            Some(account) => account.owner() != &self.tip_distribution_program_info.program_id,
+        }
+    }
+
+    /// Creates an [Initialize] transaction object.
+    pub fn initialize_tip_distribution_config_tx(
+        &self,
+        bank: &Bank,
+        kp: &Keypair,
+    ) -> SanitizedTransaction {
+        let ix = initialize_ix(
+            self.tip_distribution_program_info.program_id,
+            InitializeArgs {
+                authority: kp.pubkey(),
+                expired_funds_account: kp.pubkey(),
+                num_epochs_valid: 10,
+                max_validator_commission_bps: 10_000,
+                bump: self.tip_distribution_program_info.config_pda_and_bump.1,
+            },
+            InitializeAccounts {
+                config: self.tip_distribution_program_info.config_pda_and_bump.0,
+                system_program: system_program::id(),
+                initializer: kp.pubkey(),
+            },
+        );
+
+        SanitizedTransaction::try_from_legacy_transaction(
+            Transaction::new_signed_with_payer(
+                &[ix],
+                Some(&kp.pubkey()),
+                &[kp],
+                bank.last_blockhash(),
+            ),
+            bank.get_reserved_account_keys(),
+        )
+        .unwrap()
+    }
+
+    /// Creates an [InitializeTipDistributionAccount] transaction object using the provided Epoch.
+    pub fn initialize_tip_distribution_account_tx(
+        &self,
+        bank: &Bank,
+        keypair: &Keypair,
+    ) -> SanitizedTransaction {
+        let (tip_distribution_account, bump) = derive_tip_distribution_account_address(
+            &self.tip_distribution_program_info.program_id,
+            &self.tip_distribution_account_config.vote_account,
+            bank.epoch(),
+        );
+
+        let ix = initialize_tip_distribution_account_ix(
+            self.tip_distribution_program_info.program_id,
+            InitializeTipDistributionAccountArgs {
+                merkle_root_upload_authority: self
+                    .tip_distribution_account_config
+                    .merkle_root_upload_authority,
+                validator_commission_bps: self.tip_distribution_account_config.commission_bps,
+                bump,
+            },
+            InitializeTipDistributionAccountAccounts {
+                config: self.tip_distribution_program_info.config_pda_and_bump.0,
+                tip_distribution_account,
+                system_program: system_program::id(),
+                signer: keypair.pubkey(),
+                validator_vote_account: self.tip_distribution_account_config.vote_account,
+            },
+        );
+
+        SanitizedTransaction::try_from_legacy_transaction(
+            Transaction::new_signed_with_payer(
+                &[ix],
+                Some(&keypair.pubkey()),
+                &[keypair],
+                bank.last_blockhash(),
+            ),
+            bank.get_reserved_account_keys(),
+        )
+        .unwrap()
+    }
+
+    /// Builds a transaction that changes the current tip receiver to new_tip_receiver.
+    /// The on-chain program will transfer tips sitting in the tip accounts to the tip receiver
+    /// before changing ownership.
+    pub fn change_tip_receiver_and_block_builder_tx(
+        &self,
+        new_tip_receiver: &Pubkey,
+        bank: &Bank,
+        keypair: &Keypair,
+        block_builder: &Pubkey,
+        block_builder_commission: u64,
+    ) -> Result<SanitizedTransaction> {
+        let config = self.get_tip_payment_config_account(bank)?;
+        Ok(self.build_change_tip_receiver_and_block_builder_tx(
+            &config.tip_receiver,
+            new_tip_receiver,
+            bank,
+            keypair,
+            &config.block_builder,
+            block_builder,
+            block_builder_commission,
+        ))
+    }
+
+    pub fn build_change_tip_receiver_and_block_builder_tx(
+        &self,
+        old_tip_receiver: &Pubkey,
+        new_tip_receiver: &Pubkey,
+        bank: &Bank,
+        keypair: &Keypair,
+        old_block_builder: &Pubkey,
+        block_builder: &Pubkey,
+        block_builder_commission: u64,
+    ) -> SanitizedTransaction {
+        let change_tip_ix = Instruction {
+            program_id: self.tip_payment_program_info.program_id,
+            data: jito_tip_payment::instruction::ChangeTipReceiver {}.data(),
+            accounts: jito_tip_payment::accounts::ChangeTipReceiver {
+                config: self.tip_payment_program_info.config_pda_bump.0,
+                old_tip_receiver: *old_tip_receiver,
+                new_tip_receiver: *new_tip_receiver,
+                block_builder: *old_block_builder,
+                tip_payment_account_0: self.tip_payment_program_info.tip_pda_0.0,
+                tip_payment_account_1: self.tip_payment_program_info.tip_pda_1.0,
+                tip_payment_account_2: self.tip_payment_program_info.tip_pda_2.0,
+                tip_payment_account_3: self.tip_payment_program_info.tip_pda_3.0,
+                tip_payment_account_4: self.tip_payment_program_info.tip_pda_4.0,
+                tip_payment_account_5: self.tip_payment_program_info.tip_pda_5.0,
+                tip_payment_account_6: self.tip_payment_program_info.tip_pda_6.0,
+                tip_payment_account_7: self.tip_payment_program_info.tip_pda_7.0,
+                signer: keypair.pubkey(),
+            }
+            .to_account_metas(None),
+        };
+        let change_block_builder_ix = Instruction {
+            program_id: self.tip_payment_program_info.program_id,
+            data: jito_tip_payment::instruction::ChangeBlockBuilder {
+                block_builder_commission,
+            }
+            .data(),
+            accounts: jito_tip_payment::accounts::ChangeBlockBuilder {
+                config: self.tip_payment_program_info.config_pda_bump.0,
+                tip_receiver: *new_tip_receiver, // tip receiver will have just changed in previous ix
+                old_block_builder: *old_block_builder,
+                new_block_builder: *block_builder,
+                tip_payment_account_0: self.tip_payment_program_info.tip_pda_0.0,
+                tip_payment_account_1: self.tip_payment_program_info.tip_pda_1.0,
+                tip_payment_account_2: self.tip_payment_program_info.tip_pda_2.0,
+                tip_payment_account_3: self.tip_payment_program_info.tip_pda_3.0,
+                tip_payment_account_4: self.tip_payment_program_info.tip_pda_4.0,
+                tip_payment_account_5: self.tip_payment_program_info.tip_pda_5.0,
+                tip_payment_account_6: self.tip_payment_program_info.tip_pda_6.0,
+                tip_payment_account_7: self.tip_payment_program_info.tip_pda_7.0,
+                signer: keypair.pubkey(),
+            }
+            .to_account_metas(None),
+        };
+        SanitizedTransaction::try_from_legacy_transaction(
+            Transaction::new_signed_with_payer(
+                &[change_tip_ix, change_block_builder_ix],
+                Some(&keypair.pubkey()),
+                &[keypair],
+                bank.last_blockhash(),
+            ),
+            bank.get_reserved_account_keys(),
+        )
+        .unwrap()
+    }
+
+    /// Returns the balance of all the MEV tip accounts
+    pub fn get_tip_account_balances(&self, bank: &Arc<Bank>) -> Vec<(Pubkey, u64)> {
+        let accounts = self.get_tip_accounts();
+        accounts
+            .into_iter()
+            .map(|account| {
+                let balance = bank.get_balance(&account);
+                (account, balance)
+            })
+            .collect()
+    }
+
+    /// Returns the balance of all the MEV tip accounts above the rent-exempt amount.
+    /// NOTE: the on-chain program has rent_exempt = force
+    pub fn get_tip_account_balances_above_rent_exempt(
+        &self,
+        bank: &Arc<Bank>,
+    ) -> Vec<(Pubkey, u64)> {
+        let accounts = self.get_tip_accounts();
+        accounts
+            .into_iter()
+            .map(|account| {
+                let account_data = bank.get_account(&account).unwrap_or_default();
+                let balance = bank.get_balance(&account);
+                let rent_exempt =
+                    bank.get_minimum_balance_for_rent_exemption(account_data.data().len());
+                // NOTE: don't unwrap here in case bug in on-chain program, don't want all validators to crash
+                // if program gets stuck in bad state
+                (account, balance.checked_sub(rent_exempt).unwrap_or_else(|| {
+                    warn!("balance is below rent exempt amount. balance: {} rent_exempt: {} acc size: {}", balance, rent_exempt, TipPaymentAccount::SIZE);
+                    0
+                }))
+            })
+            .collect()
+    }
+
+    /// Return a bundle that is capable of calling the initialize instructions on the two tip payment programs
+    /// This is mainly helpful for local development and shouldn't run on testnet and mainnet, assuming the
+    /// correct TipManager configuration is set.
+    pub fn get_initialize_tip_programs_bundle(
+        &self,
+        bank: &Bank,
+        keypair: &Keypair,
+    ) -> Option<SanitizedBundle> {
+        let maybe_init_tip_payment_config_tx = if self.should_initialize_tip_payment_program(bank) {
+            debug!("should_initialize_tip_payment_program=true");
+            Some(self.initialize_tip_payment_program_tx(bank, keypair))
+        } else {
+            None
+        };
+
+        let maybe_init_tip_distro_config_tx =
+            if self.should_initialize_tip_distribution_config(bank) {
+                debug!("should_initialize_tip_distribution_config=true");
+                Some(self.initialize_tip_distribution_config_tx(bank, keypair))
+            } else {
+                None
+            };
+
+        let transactions = [
+            maybe_init_tip_payment_config_tx,
+            maybe_init_tip_distro_config_tx,
+        ]
+        .into_iter()
+        .flatten()
+        .collect::<Vec<SanitizedTransaction>>();
+
+        if transactions.is_empty() {
+            None
+        } else {
+            let bundle_id = derive_bundle_id_from_sanitized_transactions(&transactions);
+            Some(SanitizedBundle {
+                transactions,
+                bundle_id,
+            })
+        }
+    }
+
+    pub fn get_tip_programs_crank_bundle(
+        &self,
+        bank: &Bank,
+        keypair: &Keypair,
+        block_builder_fee_info: &BlockBuilderFeeInfo,
+    ) -> Result<Option<SanitizedBundle>> {
+        let maybe_init_tip_distro_account_tx = if self.should_init_tip_distribution_account(bank) {
+            debug!("should_init_tip_distribution_account=true");
+            Some(self.initialize_tip_distribution_account_tx(bank, keypair))
+        } else {
+            None
+        };
+
+        let configured_tip_receiver = self.get_configured_tip_receiver(bank)?;
+        let my_tip_receiver = self.get_my_tip_distribution_pda(bank.epoch());
+        let maybe_change_tip_receiver_tx = if configured_tip_receiver != my_tip_receiver {
+            debug!("change_tip_receiver=true");
+            Some(self.change_tip_receiver_and_block_builder_tx(
+                &my_tip_receiver,
+                bank,
+                keypair,
+                &block_builder_fee_info.block_builder,
+                block_builder_fee_info.block_builder_commission,
+            )?)
+        } else {
+            None
+        };
+        debug!(
+            "maybe_change_tip_receiver_tx: {:?}",
+            maybe_change_tip_receiver_tx
+        );
+
+        let transactions = [
+            maybe_init_tip_distro_account_tx,
+            maybe_change_tip_receiver_tx,
+        ]
+        .into_iter()
+        .flatten()
+        .collect::<Vec<SanitizedTransaction>>();
+
+        if transactions.is_empty() {
+            Ok(None)
+        } else {
+            let bundle_id = derive_bundle_id_from_sanitized_transactions(&transactions);
+            Ok(Some(SanitizedBundle {
+                transactions,
+                bundle_id,
+            }))
+        }
+    }
+}
diff --git a/core/src/tpu.rs b/core/src/tpu.rs
index 3719404582de..956da042a8c0 100644
--- a/core/src/tpu.rs
+++ b/core/src/tpu.rs
@@ -6,14 +6,21 @@ use {
     crate::{
         banking_stage::BankingStage,
         banking_trace::{BankingTracer, TracerThread},
+        bundle_stage::{bundle_account_locker::BundleAccountLocker, BundleStage},
         cluster_info_vote_listener::{
             ClusterInfoVoteListener, DuplicateConfirmedSlotsSender, GossipVerifiedVoteHashSender,
             VerifiedVoteSender, VoteTracker,
         },
         fetch_stage::FetchStage,
+        proxy::{
+            block_engine_stage::{BlockBuilderFeeInfo, BlockEngineConfig, BlockEngineStage},
+            fetch_stage_manager::FetchStageManager,
+            relayer_stage::{RelayerConfig, RelayerStage},
+        },
         sigverify::TransactionSigVerifier,
         sigverify_stage::SigVerifyStage,
         staked_nodes_updater_service::StakedNodesUpdaterService,
+        tip_manager::{TipManager, TipManagerConfig},
         tpu_entry_notifier::TpuEntryNotifier,
         validator::{BlockProductionMethod, GeneratorConfig},
     },
@@ -35,7 +42,12 @@ use {
         prioritization_fee_cache::PrioritizationFeeCache,
         vote_sender_types::{ReplayVoteReceiver, ReplayVoteSender},
     },
-    solana_sdk::{clock::Slot, pubkey::Pubkey, quic::NotifyKeyUpdate, signature::Keypair},
+    solana_sdk::{
+        clock::Slot,
+        pubkey::Pubkey,
+        quic::NotifyKeyUpdate,
+        signature::{Keypair, Signer},
+    },
     solana_streamer::{
         nonblocking::quic::{DEFAULT_MAX_STREAMS_PER_MS, DEFAULT_WAIT_FOR_CHUNK_TIMEOUT},
         quic::{spawn_server, SpawnServerResult, MAX_STAKED_CONNECTIONS, MAX_UNSTAKED_CONNECTIONS},
@@ -43,9 +55,9 @@ use {
     },
     solana_turbine::broadcast_stage::{BroadcastStage, BroadcastStageType},
     std::{
-        collections::HashMap,
+        collections::{HashMap, HashSet},
         net::{SocketAddr, UdpSocket},
-        sync::{atomic::AtomicBool, Arc, RwLock},
+        sync::{atomic::AtomicBool, Arc, Mutex, RwLock},
         thread,
         time::Duration,
     },
@@ -76,6 +88,10 @@ pub struct Tpu {
     tpu_entry_notifier: Option<TpuEntryNotifier>,
     staked_nodes_updater_service: StakedNodesUpdaterService,
     tracer_thread_hdl: TracerThread,
+    relayer_stage: RelayerStage,
+    block_engine_stage: BlockEngineStage,
+    fetch_stage_manager: FetchStageManager,
+    bundle_stage: BundleStage,
 }
 
 impl Tpu {
@@ -116,6 +132,11 @@ impl Tpu {
         block_production_method: BlockProductionMethod,
         enable_block_production_forwarding: bool,
         _generator_config: Option<GeneratorConfig>, /* vestigial code for replay invalidator */
+        block_engine_config: Arc<Mutex<BlockEngineConfig>>,
+        relayer_config: Arc<Mutex<RelayerConfig>>,
+        tip_manager_config: TipManagerConfig,
+        shred_receiver_address: Arc<RwLock<Option<SocketAddr>>>,
+        preallocated_bundle_cost: u64,
     ) -> (Self, Vec<Arc<dyn NotifyKeyUpdate + Sync + Send>>) {
         let TpuSockets {
             transactions: transactions_sockets,
@@ -126,7 +147,10 @@ impl Tpu {
             transactions_forwards_quic: transactions_forwards_quic_sockets,
         } = sockets;
 
-        let (packet_sender, packet_receiver) = unbounded();
+        // Packets from fetch stage and quic server are intercepted and sent through fetch_stage_manager
+        // If relayer is connected, packets are dropped. If not, packets are forwarded on to packet_sender
+        let (packet_intercept_sender, packet_intercept_receiver) = unbounded();
+
         let (vote_packet_sender, vote_packet_receiver) = unbounded();
         let (forwarded_packet_sender, forwarded_packet_receiver) = unbounded();
         let fetch_stage = FetchStage::new_with_sender(
@@ -134,7 +158,7 @@ impl Tpu {
             tpu_forwards_sockets,
             tpu_vote_sockets,
             exit.clone(),
-            &packet_sender,
+            &packet_intercept_sender,
             &vote_packet_sender,
             &forwarded_packet_sender,
             forwarded_packet_receiver,
@@ -162,7 +186,7 @@ impl Tpu {
             "quic_streamer_tpu",
             transactions_quic_sockets,
             keypair,
-            packet_sender,
+            packet_intercept_sender,
             exit.clone(),
             MAX_QUIC_CONNECTIONS_PER_PEER,
             staked_nodes.clone(),
@@ -197,8 +221,10 @@ impl Tpu {
         )
         .unwrap();
 
+        let (packet_sender, packet_receiver) = unbounded();
+
         let sigverify_stage = {
-            let verifier = TransactionSigVerifier::new(non_vote_sender);
+            let verifier = TransactionSigVerifier::new(non_vote_sender.clone());
             SigVerifyStage::new(packet_receiver, verifier, "solSigVerTpu", "tpu-verifier")
         };
 
@@ -216,6 +242,41 @@ impl Tpu {
 
         let (gossip_vote_sender, gossip_vote_receiver) =
             banking_tracer.create_channel_gossip_vote();
+
+        let block_builder_fee_info = Arc::new(Mutex::new(BlockBuilderFeeInfo {
+            block_builder: cluster_info.keypair().pubkey(),
+            block_builder_commission: 0,
+        }));
+
+        let (bundle_sender, bundle_receiver) = unbounded();
+        let block_engine_stage = BlockEngineStage::new(
+            block_engine_config,
+            bundle_sender,
+            cluster_info.clone(),
+            packet_sender.clone(),
+            non_vote_sender.clone(),
+            exit.clone(),
+            &block_builder_fee_info,
+        );
+
+        let (heartbeat_tx, heartbeat_rx) = unbounded();
+        let fetch_stage_manager = FetchStageManager::new(
+            cluster_info.clone(),
+            heartbeat_rx,
+            packet_intercept_receiver,
+            packet_sender.clone(),
+            exit.clone(),
+        );
+
+        let relayer_stage = RelayerStage::new(
+            relayer_config,
+            cluster_info.clone(),
+            heartbeat_tx,
+            packet_sender,
+            non_vote_sender,
+            exit.clone(),
+        );
+
         let cluster_info_vote_listener = ClusterInfoVoteListener::new(
             exit.clone(),
             cluster_info.clone(),
@@ -232,6 +293,15 @@ impl Tpu {
             duplicate_confirmed_slot_sender,
         );
 
+        let tip_manager = TipManager::new(tip_manager_config);
+
+        let bundle_account_locker = BundleAccountLocker::default();
+
+        // tip accounts can't be used in BankingStage to avoid someone from stealing tips mid-slot.
+        // it also helps reduce surface area for potential account contention
+        let mut blacklisted_accounts = HashSet::new();
+        blacklisted_accounts.insert(tip_manager.tip_payment_config_pubkey());
+        blacklisted_accounts.extend(tip_manager.get_tip_accounts());
         let banking_stage = BankingStage::new(
             block_production_method,
             cluster_info,
@@ -239,13 +309,31 @@ impl Tpu {
             non_vote_receiver,
             tpu_vote_receiver,
             gossip_vote_receiver,
-            transaction_status_sender,
-            replay_vote_sender,
+            transaction_status_sender.clone(),
+            replay_vote_sender.clone(),
             log_messages_bytes_limit,
             connection_cache.clone(),
             bank_forks.clone(),
             prioritization_fee_cache,
             enable_block_production_forwarding,
+            blacklisted_accounts,
+            bundle_account_locker.clone(),
+        );
+
+        let bundle_stage = BundleStage::new(
+            cluster_info,
+            poh_recorder,
+            bundle_receiver,
+            transaction_status_sender,
+            replay_vote_sender,
+            log_messages_bytes_limit,
+            exit.clone(),
+            tip_manager,
+            bundle_account_locker,
+            &block_builder_fee_info,
+            preallocated_bundle_cost,
+            bank_forks.clone(),
+            prioritization_fee_cache,
         );
 
         let (entry_receiver, tpu_entry_notifier) =
@@ -272,6 +360,7 @@ impl Tpu {
             bank_forks,
             shred_version,
             turbine_quic_endpoint_sender,
+            shred_receiver_address,
         );
 
         (
@@ -287,6 +376,10 @@ impl Tpu {
                 tpu_entry_notifier,
                 staked_nodes_updater_service,
                 tracer_thread_hdl,
+                block_engine_stage,
+                relayer_stage,
+                fetch_stage_manager,
+                bundle_stage,
             },
             vec![key_updater, forwards_key_updater],
         )
@@ -302,6 +395,10 @@ impl Tpu {
             self.staked_nodes_updater_service.join(),
             self.tpu_quic_t.join(),
             self.tpu_forwards_quic_t.join(),
+            self.bundle_stage.join(),
+            self.relayer_stage.join(),
+            self.block_engine_stage.join(),
+            self.fetch_stage_manager.join(),
         ];
         let broadcast_result = self.broadcast_stage.join();
         for result in results {
diff --git a/core/src/tpu_entry_notifier.rs b/core/src/tpu_entry_notifier.rs
index 22994455e888..e226b0ef1fab 100644
--- a/core/src/tpu_entry_notifier.rs
+++ b/core/src/tpu_entry_notifier.rs
@@ -61,43 +61,57 @@ impl TpuEntryNotifier {
         current_index: &mut usize,
         current_transaction_index: &mut usize,
     ) -> Result<(), RecvTimeoutError> {
-        let (bank, (entry, tick_height)) = entry_receiver.recv_timeout(Duration::from_secs(1))?;
+        let WorkingBankEntry {
+            bank,
+            entries_ticks,
+        } = entry_receiver.recv_timeout(Duration::from_secs(1))?;
         let slot = bank.slot();
-        let index = if slot != *current_slot {
-            *current_index = 0;
-            *current_transaction_index = 0;
-            *current_slot = slot;
-            0
-        } else {
-            *current_index += 1;
-            *current_index
-        };
+        let mut indices_sent = vec![];
 
-        let entry_summary = EntrySummary {
-            num_hashes: entry.num_hashes,
-            hash: entry.hash,
-            num_transactions: entry.transactions.len() as u64,
-        };
-        if let Err(err) = entry_notification_sender.send(EntryNotification {
-            slot,
-            index,
-            entry: entry_summary,
-            starting_transaction_index: *current_transaction_index,
-        }) {
-            warn!(
+        entries_ticks.iter().for_each(|(entry, _)| {
+            let index = if slot != *current_slot {
+                *current_index = 0;
+                *current_transaction_index = 0;
+                *current_slot = slot;
+                0
+            } else {
+                *current_index += 1;
+                *current_index
+            };
+
+            let entry_summary = EntrySummary {
+                num_hashes: entry.num_hashes,
+                hash: entry.hash,
+                num_transactions: entry.transactions.len() as u64,
+            };
+            if let Err(err) = entry_notification_sender.send(EntryNotification {
+                slot,
+                index,
+                entry: entry_summary,
+                starting_transaction_index: *current_transaction_index
+            }) {
+                warn!(
                 "Failed to send slot {slot:?} entry {index:?} from Tpu to EntryNotifierService, error {err:?}",
             );
-        }
-        *current_transaction_index += entry.transactions.len();
+            }
 
-        if let Err(err) = broadcast_entry_sender.send((bank, (entry, tick_height))) {
+            *current_transaction_index += entry.transactions.len();
+
+            indices_sent.push(index);
+        });
+
+        if let Err(err) = broadcast_entry_sender.send(WorkingBankEntry {
+            bank,
+            entries_ticks,
+        }) {
             warn!(
-                "Failed to send slot {slot:?} entry {index:?} from Tpu to BroadcastStage, error {err:?}",
+                "Failed to send slot {slot:?} entries {indices_sent:?} from Tpu to BroadcastStage, error {err:?}",
             );
             // If the BroadcastStage channel is closed, the validator has halted. Try to exit
             // gracefully.
             exit.store(true, Ordering::Relaxed);
         }
+
         Ok(())
     }
 
diff --git a/core/src/tvu.rs b/core/src/tvu.rs
index 4dcd7bbfa3e5..9e39bf390ef0 100644
--- a/core/src/tvu.rs
+++ b/core/src/tvu.rs
@@ -159,6 +159,7 @@ impl Tvu {
         outstanding_repair_requests: Arc<RwLock<OutstandingShredRepairs>>,
         cluster_slots: Arc<ClusterSlots>,
         wen_restart_repair_slots: Option<Arc<RwLock<Vec<Slot>>>>,
+        shred_receiver_addr: Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<Self, String> {
         let TvuSockets {
             repair: repair_socket,
@@ -207,6 +208,7 @@ impl Tvu {
             retransmit_receiver,
             max_slots.clone(),
             Some(rpc_subscriptions.clone()),
+            shred_receiver_addr,
         );
 
         let (ancestor_duplicate_slots_sender, ancestor_duplicate_slots_receiver) = unbounded();
@@ -521,6 +523,7 @@ pub mod tests {
             outstanding_repair_requests,
             cluster_slots,
             None,
+            Arc::new(RwLock::new(None)),
         )
         .expect("assume success");
         exit.store(true, Ordering::Relaxed);
diff --git a/core/src/validator.rs b/core/src/validator.rs
index d89520c0c831..7977b9aff804 100644
--- a/core/src/validator.rs
+++ b/core/src/validator.rs
@@ -15,6 +15,7 @@ use {
             ExternalRootSource, Tower,
         },
         poh_timing_report_service::PohTimingReportService,
+        proxy::{block_engine_stage::BlockEngineConfig, relayer_stage::RelayerConfig},
         repair::{self, serve_repair::ServeRepair, serve_repair_service::ServeRepairService},
         rewards_recorder_service::{RewardsRecorderSender, RewardsRecorderService},
         sample_performance_service::SamplePerformanceService,
@@ -24,6 +25,7 @@ use {
         system_monitor_service::{
             verify_net_stats_access, SystemMonitorService, SystemMonitorStatsReportConfig,
         },
+        tip_manager::TipManagerConfig,
         tpu::{Tpu, TpuSockets, DEFAULT_TPU_COALESCE},
         tvu::{Tvu, TvuConfig, TvuSockets},
     },
@@ -105,6 +107,10 @@ use {
         snapshot_hash::StartingSnapshotHashes,
         snapshot_utils::{self, clean_orphaned_account_snapshot_dirs},
     },
+    solana_runtime_plugin::{
+        runtime_plugin_admin_rpc_service::RuntimePluginManagerRpcRequest,
+        runtime_plugin_service::RuntimePluginService,
+    },
     solana_sdk::{
         clock::Slot,
         epoch_schedule::MAX_LEADER_SCHEDULE_EPOCH_OFFSET,
@@ -129,7 +135,7 @@ use {
         path::{Path, PathBuf},
         sync::{
             atomic::{AtomicBool, AtomicU64, Ordering},
-            Arc, RwLock,
+            Arc, Mutex, RwLock,
         },
         thread::{sleep, Builder, JoinHandle},
         time::{Duration, Instant},
@@ -215,7 +221,8 @@ pub struct ValidatorConfig {
     pub rpc_config: JsonRpcConfig,
     /// Specifies which plugins to start up with
     pub on_start_geyser_plugin_config_files: Option<Vec<PathBuf>>,
-    pub rpc_addrs: Option<(SocketAddr, SocketAddr)>, // (JsonRpc, JsonRpcPubSub)
+    pub rpc_addrs: Option<(SocketAddr, SocketAddr)>,
+    // (JsonRpc, JsonRpcPubSub)
     pub pubsub_config: PubSubConfig,
     pub snapshot_config: SnapshotConfig,
     pub max_ledger_shreds: Option<u64>,
@@ -225,10 +232,14 @@ pub struct ValidatorConfig {
     pub fixed_leader_schedule: Option<FixedSchedule>,
     pub wait_for_supermajority: Option<Slot>,
     pub new_hard_forks: Option<Vec<Slot>>,
-    pub known_validators: Option<HashSet<Pubkey>>, // None = trust all
-    pub repair_validators: Option<HashSet<Pubkey>>, // None = repair from all
-    pub repair_whitelist: Arc<RwLock<HashSet<Pubkey>>>, // Empty = repair with all
-    pub gossip_validators: Option<HashSet<Pubkey>>, // None = gossip with all
+    pub known_validators: Option<HashSet<Pubkey>>,
+    // None = trust all
+    pub repair_validators: Option<HashSet<Pubkey>>,
+    // None = repair from all
+    pub repair_whitelist: Arc<RwLock<HashSet<Pubkey>>>,
+    // Empty = repair with all
+    pub gossip_validators: Option<HashSet<Pubkey>>,
+    // None = gossip with all
     pub accounts_hash_interval_slots: u64,
     pub max_genesis_archive_unpacked_size: u64,
     pub wal_recovery_mode: Option<BlockstoreRecoveryMode>,
@@ -275,6 +286,12 @@ pub struct ValidatorConfig {
     pub replay_forks_threads: NonZeroUsize,
     pub replay_transactions_threads: NonZeroUsize,
     pub delay_leader_block_for_pending_fork: bool,
+    pub relayer_config: Arc<Mutex<RelayerConfig>>,
+    pub block_engine_config: Arc<Mutex<BlockEngineConfig>>,
+    // Using Option inside RwLock is ugly, but only convenient way to allow toggle on/off
+    pub shred_receiver_address: Arc<RwLock<Option<SocketAddr>>>,
+    pub tip_manager_config: TipManagerConfig,
+    pub preallocated_bundle_cost: u64,
 }
 
 impl Default for ValidatorConfig {
@@ -347,6 +364,11 @@ impl Default for ValidatorConfig {
             replay_forks_threads: NonZeroUsize::new(1).expect("1 is non-zero"),
             replay_transactions_threads: NonZeroUsize::new(1).expect("1 is non-zero"),
             delay_leader_block_for_pending_fork: false,
+            relayer_config: Arc::new(Mutex::new(RelayerConfig::default())),
+            block_engine_config: Arc::new(Mutex::new(BlockEngineConfig::default())),
+            shred_receiver_address: Arc::new(RwLock::new(None)),
+            tip_manager_config: TipManagerConfig::default(),
+            preallocated_bundle_cost: u64::default(),
         }
     }
 }
@@ -385,7 +407,8 @@ impl ValidatorConfig {
 // having to watch log messages.
 #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
 pub enum ValidatorStartProgress {
-    Initializing, // Catch all, default state
+    Initializing,
+    // Catch all, default state
     SearchingForRpcService,
     DownloadingSnapshot {
         slot: Slot,
@@ -399,7 +422,8 @@ pub enum ValidatorStartProgress {
         max_slot: Slot,
     },
     StartingServices,
-    Halted, // Validator halted due to `--dev-halt-at-slot` argument
+    Halted,
+    // Validator halted due to `--dev-halt-at-slot` argument
     WaitingForSupermajority {
         slot: Slot,
         gossip_stake_percent: u64,
@@ -516,6 +540,10 @@ impl Validator {
         tpu_enable_udp: bool,
         tpu_max_connections_per_ipaddr_per_minute: u64,
         admin_rpc_service_post_init: Arc<RwLock<Option<AdminRpcRequestMetadataPostInit>>>,
+        runtime_plugin_configs_and_request_rx: Option<(
+            Vec<PathBuf>,
+            Receiver<RuntimePluginManagerRpcRequest>,
+        )>,
     ) -> Result<Self, String> {
         let start_time = Instant::now();
 
@@ -929,6 +957,17 @@ impl Validator {
             None,
         ));
 
+        if let Some((runtime_plugin_configs, request_rx)) = runtime_plugin_configs_and_request_rx {
+            RuntimePluginService::start(
+                &runtime_plugin_configs,
+                request_rx,
+                bank_forks.clone(),
+                block_commitment_cache.clone(),
+                exit.clone(),
+            )
+            .map_err(|e| format!("Failed to start runtime plugin service: {e:?}"))?;
+        }
+
         let max_slots = Arc::new(MaxSlots::default());
 
         let startup_verification_complete;
@@ -1369,6 +1408,7 @@ impl Validator {
             outstanding_repair_requests.clone(),
             cluster_slots.clone(),
             wen_restart_repair_slots.clone(),
+            config.shred_receiver_address.clone(),
         )?;
 
         if in_wen_restart {
@@ -1437,6 +1477,11 @@ impl Validator {
             config.block_production_method.clone(),
             config.enable_block_production_forwarding,
             config.generator_config.clone(),
+            config.block_engine_config.clone(),
+            config.relayer_config.clone(),
+            config.tip_manager_config.clone(),
+            config.shred_receiver_address.clone(),
+            config.preallocated_bundle_cost,
         );
 
         datapoint_info!(
@@ -1461,6 +1506,9 @@ impl Validator {
             repair_socket: Arc::new(node.sockets.repair),
             outstanding_repair_requests,
             cluster_slots,
+            block_engine_config: config.block_engine_config.clone(),
+            relayer_config: config.relayer_config.clone(),
+            shred_receiver_address: config.shred_receiver_address.clone(),
         });
 
         Ok(Self {
@@ -1927,6 +1975,7 @@ fn load_blockstore(
                 .map(|service| service.sender()),
             accounts_update_notifier,
             exit,
+            true,
         )
         .map_err(|err| err.to_string())?;
 
@@ -2618,6 +2667,7 @@ mod tests {
             DEFAULT_TPU_ENABLE_UDP,
             32, // max connections per IpAddr per minute for test
             Arc::new(RwLock::new(None)),
+            None,
         )
         .expect("assume successful validator start");
         assert_eq!(
@@ -2695,7 +2745,7 @@ mod tests {
                     Arc::new(RwLock::new(vec![Arc::new(vote_account_keypair)])),
                     vec![leader_node.info.clone()],
                     &config,
-                    true, // should_check_duplicate_instance.
+                    true, // should_check_duplicate_instance
                     None, // rpc_to_plugin_manager_receiver
                     Arc::new(RwLock::new(ValidatorStartProgress::default())),
                     SocketAddrSpace::Unspecified,
@@ -2704,6 +2754,7 @@ mod tests {
                     DEFAULT_TPU_ENABLE_UDP,
                     32, // max connections per IpAddr per minute for test
                     Arc::new(RwLock::new(None)),
+                    None,
                 )
                 .expect("assume successful validator start")
             })
@@ -2820,7 +2871,7 @@ mod tests {
 
         assert!(is_snapshot_config_valid(
             &new_snapshot_config(300, 200),
-            100
+            100,
         ));
 
         let default_accounts_hash_interval =
@@ -2828,62 +2879,62 @@ mod tests {
         assert!(is_snapshot_config_valid(
             &new_snapshot_config(
                 snapshot_bank_utils::DEFAULT_FULL_SNAPSHOT_ARCHIVE_INTERVAL_SLOTS,
-                snapshot_bank_utils::DEFAULT_INCREMENTAL_SNAPSHOT_ARCHIVE_INTERVAL_SLOTS
+                snapshot_bank_utils::DEFAULT_INCREMENTAL_SNAPSHOT_ARCHIVE_INTERVAL_SLOTS,
             ),
             default_accounts_hash_interval,
         ));
         assert!(is_snapshot_config_valid(
             &new_snapshot_config(
                 snapshot_bank_utils::DEFAULT_FULL_SNAPSHOT_ARCHIVE_INTERVAL_SLOTS,
-                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL
+                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL,
             ),
-            default_accounts_hash_interval
+            default_accounts_hash_interval,
         ));
         assert!(is_snapshot_config_valid(
             &new_snapshot_config(
                 snapshot_bank_utils::DEFAULT_INCREMENTAL_SNAPSHOT_ARCHIVE_INTERVAL_SLOTS,
-                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL
+                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL,
             ),
-            default_accounts_hash_interval
+            default_accounts_hash_interval,
         ));
         assert!(is_snapshot_config_valid(
             &new_snapshot_config(
                 DISABLED_SNAPSHOT_ARCHIVE_INTERVAL,
-                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL
+                DISABLED_SNAPSHOT_ARCHIVE_INTERVAL,
             ),
-            Slot::MAX
+            Slot::MAX,
         ));
 
         assert!(!is_snapshot_config_valid(&new_snapshot_config(0, 100), 100));
         assert!(!is_snapshot_config_valid(&new_snapshot_config(100, 0), 100));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(42, 100),
-            100
+            100,
         ));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(100, 42),
-            100
+            100,
         ));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(100, 100),
-            100
+            100,
         ));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(100, 200),
-            100
+            100,
         ));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(444, 200),
-            100
+            100,
         ));
         assert!(!is_snapshot_config_valid(
             &new_snapshot_config(400, 222),
-            100
+            100,
         ));
 
         assert!(is_snapshot_config_valid(
             &SnapshotConfig::new_load_only(),
-            100
+            100,
         ));
         assert!(is_snapshot_config_valid(
             &SnapshotConfig {
@@ -2891,7 +2942,7 @@ mod tests {
                 incremental_snapshot_archive_interval_slots: 37,
                 ..SnapshotConfig::new_load_only()
             },
-            100
+            100,
         ));
         assert!(is_snapshot_config_valid(
             &SnapshotConfig {
@@ -2899,7 +2950,7 @@ mod tests {
                 incremental_snapshot_archive_interval_slots: DISABLED_SNAPSHOT_ARCHIVE_INTERVAL,
                 ..SnapshotConfig::new_load_only()
             },
-            100
+            100,
         ));
     }
 
diff --git a/core/tests/epoch_accounts_hash.rs b/core/tests/epoch_accounts_hash.rs
index 7ec41c673fd7..c516f195f3d7 100755
--- a/core/tests/epoch_accounts_hash.rs
+++ b/core/tests/epoch_accounts_hash.rs
@@ -439,6 +439,7 @@ fn test_snapshots_have_expected_epoch_accounts_hash() {
                 if let Some(full_snapshot_archive_info) =
                     snapshot_utils::get_highest_full_snapshot_archive_info(
                         &snapshot_config.full_snapshot_archives_dir,
+                        None,
                     )
                 {
                     if full_snapshot_archive_info.slot() == bank.slot() {
@@ -562,6 +563,7 @@ fn test_background_services_request_handling_for_epoch_accounts_hash() {
             info!("Taking full snapshot...");
             while snapshot_utils::get_highest_full_snapshot_archive_slot(
                 &snapshot_config.full_snapshot_archives_dir,
+                None,
             ) != Some(bank.slot())
             {
                 trace!("waiting for full snapshot...");
diff --git a/core/tests/snapshots.rs b/core/tests/snapshots.rs
index 4268e48260d4..ec302c4ca076 100644
--- a/core/tests/snapshots.rs
+++ b/core/tests/snapshots.rs
@@ -780,6 +780,7 @@ fn test_snapshots_with_background_services(
                 &snapshot_test_config
                     .snapshot_config
                     .full_snapshot_archives_dir,
+                None,
             ) != Some(slot)
             {
                 assert!(
@@ -798,6 +799,7 @@ fn test_snapshots_with_background_services(
                     .snapshot_config
                     .incremental_snapshot_archives_dir,
                 last_full_snapshot_slot.unwrap(),
+                None,
             ) != Some(slot)
             {
                 assert!(
diff --git a/cost-model/src/cost_tracker.rs b/cost-model/src/cost_tracker.rs
index 0c731f946ec3..e0487ace866d 100644
--- a/cost-model/src/cost_tracker.rs
+++ b/cost-model/src/cost_tracker.rs
@@ -130,6 +130,10 @@ impl CostTracker {
         self.vote_cost_limit = vote_cost_limit;
     }
 
+    pub fn set_block_cost_limit(&mut self, block_cost_limit: u64) {
+        self.block_cost_limit = block_cost_limit;
+    }
+
     pub fn in_flight_transaction_count(&self) -> usize {
         self.in_flight_transaction_count
     }
@@ -192,6 +196,10 @@ impl CostTracker {
         self.block_cost
     }
 
+    pub fn block_cost_limit(&self) -> u64 {
+        self.block_cost_limit
+    }
+
     pub fn transaction_count(&self) -> u64 {
         self.transaction_count
     }
diff --git a/deploy_programs b/deploy_programs
new file mode 100755
index 000000000000..cbdf837e924b
--- /dev/null
+++ b/deploy_programs
@@ -0,0 +1,17 @@
+#!/usr/bin/env sh
+# Deploys the tip payment and tip distribution programs on local validator at predetermined address
+set -eux
+
+WALLET_LOCATION=~/.config/solana/id.json
+
+# build this solana binary to ensure we're using a version compatible with the validator
+cargo b --release --bin solana
+
+./target/release/solana airdrop -ul 1000 $WALLET_LOCATION
+
+(cd jito-programs/tip-payment && anchor build)
+
+# NOTE: make sure the declare_id! is set correctly in the programs
+# Also, || true to make sure if fails the first time around, tip_payment can still be deployed
+RUST_INFO=trace ./target/release/solana deploy --keypair $WALLET_LOCATION -ul ./jito-programs/tip-payment/target/deploy/tip_distribution.so ./jito-programs/tip-payment/dev/dev_tip_distribution.json || true
+RUST_INFO=trace ./target/release/solana deploy --keypair $WALLET_LOCATION -ul ./jito-programs/tip-payment/target/deploy/tip_payment.so  ./jito-programs/tip-payment/dev/dev_tip_payment.json
diff --git a/dev/Dockerfile b/dev/Dockerfile
new file mode 100644
index 000000000000..bab9a1c02fa4
--- /dev/null
+++ b/dev/Dockerfile
@@ -0,0 +1,48 @@
+FROM rust:1.64-slim-bullseye as builder
+
+# Add Google Protocol Buffers for Libra's metrics library.
+ENV PROTOC_VERSION 3.8.0
+ENV PROTOC_ZIP protoc-$PROTOC_VERSION-linux-x86_64.zip
+
+RUN set -x \
+ && apt update \
+ && apt install -y \
+      clang \
+      cmake \
+      libudev-dev \
+      make \
+      unzip \
+      libssl-dev \
+      pkg-config \
+      zlib1g-dev \
+      curl \
+ && rustup component add rustfmt \
+ && rustup component add clippy \
+ && rustc --version \
+ && cargo --version \
+ && curl -OL https://github.com/google/protobuf/releases/download/v$PROTOC_VERSION/$PROTOC_ZIP \
+ && unzip -o $PROTOC_ZIP -d /usr/local bin/protoc \
+ && unzip -o $PROTOC_ZIP -d /usr/local include/* \
+ && rm -f $PROTOC_ZIP
+
+
+WORKDIR /solana
+COPY . .
+RUN mkdir -p docker-output
+
+ARG ci_commit
+# NOTE: Keep this here before build since variable is referenced during CI build step.
+ENV CI_COMMIT=$ci_commit
+
+ARG debug
+
+# Uses docker buildkit to cache the image.
+# /usr/local/cargo/git needed for crossbeam patch
+RUN --mount=type=cache,mode=0777,target=/solana/target \
+    --mount=type=cache,mode=0777,target=/usr/local/cargo/registry \
+    --mount=type=cache,mode=0777,target=/usr/local/cargo/git \
+    if [ "$debug" = "false" ] ; then \
+      ./cargo stable build --release && cp target/release/solana* ./docker-output; \
+    else \
+      RUSTFLAGS='-g -C force-frame-pointers=yes' ./cargo stable build --release && cp target/release/solana* ./docker-output; \
+    fi
diff --git a/docs/src/cli/install.md b/docs/src/cli/install.md
index c9a5c682d405..d4be9638a485 100644
--- a/docs/src/cli/install.md
+++ b/docs/src/cli/install.md
@@ -20,11 +20,11 @@ on your preferred workflow:
 - Open your favorite Terminal application
 
 - Install the Agave release
-  [LATEST_AGAVE_RELEASE_VERSION](https://github.com/anza-xyz/agave/releases/tag/LATEST_AGAVE_RELEASE_VERSION)
+  [LATEST_AGAVE_RELEASE_VERSION](https://github.com/jito-foundation/jito-solana/releases/tag/LATEST_AGAVE_RELEASE_VERSION)
   on your machine by running:
 
 ```bash
-sh -c "$(curl -sSfL https://release.anza.xyz/LATEST_AGAVE_RELEASE_VERSION/install)"
+sh -c "$(curl -sSfL https://release.jito.wtf/LATEST_AGAVE_RELEASE_VERSION/install)"
 ```
 
 - You can replace `LATEST_AGAVE_RELEASE_VERSION` with the release tag matching
@@ -38,7 +38,7 @@ downloading LATEST_AGAVE_RELEASE_VERSION installer
 Configuration: /home/solana/.config/solana/install/config.yml
 Active release directory: /home/solana/.local/share/solana/install/active_release
 * Release version: LATEST_AGAVE_RELEASE_VERSION
-* Release URL: https://github.com/anza-xyz/agave/releases/download/LATEST_AGAVE_RELEASE_VERSION/solana-release-x86_64-unknown-linux-gnu.tar.bz2
+* Release URL: https://github.com/jito-foundation/jito-solana/releases/download/LATEST_AGAVE_RELEASE_VERSION/solana-release-x86_64-unknown-linux-gnu.tar.bz2
 Update successful
 ```
 
@@ -65,16 +65,16 @@ solana --version
 
 - Open a Command Prompt (`cmd.exe`) as an Administrator
 
-  - Search for Command Prompt in the Windows search bar. When the Command Prompt
-    app appears, right-click and select Open as Administrator. If you are
-    prompted by a pop-up window asking Do you want to allow this app to make
-    changes to your device?, click Yes.
+    - Search for Command Prompt in the Windows search bar. When the Command Prompt
+      app appears, right-click and select Open as Administrator. If you are
+      prompted by a pop-up window asking Do you want to allow this app to make
+      changes to your device?, click Yes.
 
 - Copy and paste the following command, then press Enter to download the Solana
   installer into a temporary directory:
 
 ```bash
-cmd /c "curl https://release.anza.xyz/LATEST_AGAVE_RELEASE_VERSION/agave-install-init-x86_64-pc-windows-msvc.exe --output C:\agave-install-tmp\agave-install-init.exe --create-dirs"
+cmd /c "curl https://release.jito.wtf/LATEST_AGAVE_RELEASE_VERSION/agave-install-init-x86_64-pc-windows-msvc.exe --output C:\agave-install-tmp\agave-install-init.exe --create-dirs"
 ```
 
 - Copy and paste the following command, then press Enter to install the latest
@@ -89,8 +89,8 @@ C:\agave-install-tmp\agave-install-init.exe LATEST_AGAVE_RELEASE_VERSION
 
 - Close the command prompt window and re-open a new command prompt window as a
   normal user
-  - Search for "Command Prompt" in the search bar, then left click on the
-    Command Prompt app icon, no need to run as Administrator)
+    - Search for "Command Prompt" in the search bar, then left click on the
+      Command Prompt app icon, no need to run as Administrator)
 - Confirm you have the desired version of `solana` installed by entering:
 
 ```bash
@@ -108,9 +108,7 @@ manually download and install the binaries.
 ### Linux
 
 Download the binaries by navigating to
-[https://github.com/anza-xyz/agave/releases/latest](https://github.com/anza-xyz/agave/releases/latest),
-download **solana-release-x86_64-unknown-linux-gnu.tar.bz2**, then extract the
-archive:
+[https://github.com/jito-foundation/jito-solana/releases/latest](https://github.com/jito-foundation/jito-solana/releases/latest),
 
 ```bash
 tar jxf solana-release-x86_64-unknown-linux-gnu.tar.bz2
@@ -121,9 +119,7 @@ export PATH=$PWD/bin:$PATH
 ### MacOS
 
 Download the binaries by navigating to
-[https://github.com/anza-xyz/agave/releases/latest](https://github.com/anza-xyz/agave/releases/latest),
-download **solana-release-x86_64-apple-darwin.tar.bz2**, then extract the
-archive:
+[https://github.com/jito-foundation/jito-solana/releases/latest](https://github.com/jito-foundation/jito-solana/releases/latest),
 
 ```bash
 tar jxf solana-release-x86_64-apple-darwin.tar.bz2
@@ -134,10 +130,7 @@ export PATH=$PWD/bin:$PATH
 ### Windows
 
 - Download the binaries by navigating to
-  [https://github.com/anza-xyz/agave/releases/latest](https://github.com/anza-xyz/agave/releases/latest),
-  download **solana-release-x86_64-pc-windows-msvc.tar.bz2**, then extract the
-  archive using WinZip or similar.
-
+  [https://github.com/jito-foundation/jito-solana/releases/latest](https://github.com/jito-foundation/jito-solana/releases/latest),
 - Open a Command Prompt and navigate to the directory into which you extracted
   the binaries and run:
 
@@ -242,9 +235,7 @@ above.
 
 After installing the prerequisites, proceed with building Solana from source,
 navigate to
-[Solana's GitHub releases page](https://github.com/anza-xyz/agave/releases/latest),
-and download the **Source Code** archive. Extract the code and build the
-binaries with:
+[Solana's GitHub releases page](https://github.com/jito-foundation/jito-solana/releases/latest),
 
 ```bash
 ./scripts/cargo-install-all.sh .
diff --git a/docs/src/clusters/benchmark.md b/docs/src/clusters/benchmark.md
index 35978cdd0967..424262caacfb 100644
--- a/docs/src/clusters/benchmark.md
+++ b/docs/src/clusters/benchmark.md
@@ -6,7 +6,7 @@ The Solana git repository contains all the scripts you might need to spin up you
 
 For all four variations, you'd need the latest Rust toolchain and the Solana source code:
 
-First, setup Rust, Cargo and system packages as described in the Solana [README](https://github.com/solana-labs/solana#1-install-rustc-cargo-and-rustfmt)
+First, setup Rust, Cargo and system packages as described in the Solana [README](https://github.com/jito-foundation/jito-solana#1-install-rustc-cargo-and-rustfmt)
 
 Now checkout the code from github:
 
diff --git a/docs/src/implemented-proposals/installer.md b/docs/src/implemented-proposals/installer.md
index c052aa7b4e54..343fa67fc3eb 100644
--- a/docs/src/implemented-proposals/installer.md
+++ b/docs/src/implemented-proposals/installer.md
@@ -2,9 +2,12 @@
 title: Cluster Software Installation and Updates
 ---
 
-Currently users are required to build the solana cluster software themselves from the git repository and manually update it, which is error prone and inconvenient.
+Currently users are required to build the solana cluster software themselves from the git repository and manually update
+it, which is error prone and inconvenient.
 
-This document proposes an easy to use software install and updater that can be used to deploy pre-built binaries for supported platforms. Users may elect to use binaries supplied by Solana or any other party provider. Deployment of updates is managed using an on-chain update manifest program.
+This document proposes an easy to use software install and updater that can be used to deploy pre-built binaries for
+supported platforms. Users may elect to use binaries supplied by Solana or any other party provider. Deployment of
+updates is managed using an on-chain update manifest program.
 
 ## Motivating Examples
 
@@ -13,16 +16,17 @@ This document proposes an easy to use software install and updater that can be u
 The easiest install method for supported platforms:
 
 ```bash
-$ curl -sSf https://raw.githubusercontent.com/solana-labs/solana/v1.0.0/install/agave-install-init.sh | sh
+$ curl -sSf https://raw.githubusercontent.com/jito-foundation/jito-solana/v1.0.0/install/agave-install-init.sh | sh
 ```
 
-This script will check github for the latest tagged release and download and run the `agave-install-init` binary from there.
+This script will check github for the latest tagged release and download and run the `agave-install-init` binary from
+there.
 
 If additional arguments need to be specified during the installation, the following shell syntax is used:
 
 ```bash
 $ init_args=.... # arguments for `agave-install-init ...`
-$ curl -sSf https://raw.githubusercontent.com/solana-labs/solana/v1.0.0/install/agave-install-init.sh | sh -s - ${init_args}
+$ curl -sSf https://raw.githubusercontent.com/jito-foundation/jito-solana/v1.0.0/install/agave-install-init.sh | sh -s - ${init_args}
 ```
 
 ### Fetch and run a pre-built installer from a Github release
@@ -30,7 +34,7 @@ $ curl -sSf https://raw.githubusercontent.com/solana-labs/solana/v1.0.0/install/
 With a well-known release URL, a pre-built binary can be obtained for supported platforms:
 
 ```bash
-$ curl -o agave-install-init https://github.com/solana-labs/solana/releases/download/v1.0.0/agave-install-init-x86_64-apple-darwin
+$ curl -o agave-install-init https://github.com/jito-foundation/jito-solana/releases/download/v1.0.0/agave-install-init-x86_64-apple-darwin
 $ chmod +x ./agave-install-init
 $ ./agave-install-init --help
 ```
@@ -40,14 +44,15 @@ $ ./agave-install-init --help
 If a pre-built binary is not available for a given platform, building the installer from source is always an option:
 
 ```bash
-$ git clone https://github.com/solana-labs/solana.git
+$ git clone https://github.com/jito-foundation/jito-solana.git
 $ cd solana/install
 $ cargo run -- --help
 ```
 
 ### Deploy a new update to a cluster
 
-Given a solana release tarball \(as created by `ci/publish-tarball.sh`\) that has already been uploaded to a publicly accessible URL, the following commands will deploy the update:
+Given a solana release tarball \(as created by `ci/publish-tarball.sh`\) that has already been uploaded to a publicly
+accessible URL, the following commands will deploy the update:
 
 ```bash
 $ solana-keygen new -o update-manifest.json  # <-- only generated once, the public key is shared with users
@@ -65,7 +70,10 @@ $ agave-install run agave-validator ...  # <-- runs a validator, restarting it a
 
 ## On-chain Update Manifest
 
-An update manifest is used to advertise the deployment of new release tarballs on a solana cluster. The update manifest is stored using the `config` program, and each update manifest account describes a logical update channel for a given target triple \(eg, `x86_64-apple-darwin`\). The account public key is well-known between the entity deploying new updates and users consuming those updates.
+An update manifest is used to advertise the deployment of new release tarballs on a solana cluster. The update manifest
+is stored using the `config` program, and each update manifest account describes a logical update channel for a given
+target triple \(eg, `x86_64-apple-darwin`\). The account public key is well-known between the entity deploying new
+updates and users consuming those updates.
 
 The update tarball itself is hosted elsewhere, off-chain and can be fetched from the specified `download_url`.
 
@@ -87,9 +95,11 @@ pub struct SignedUpdateManifest {
 }
 ```
 
-Note that the `manifest` field itself contains a corresponding signature \(`manifest_signature`\) to guard against man-in-the-middle attacks between the `agave-install` tool and the solana cluster RPC API.
+Note that the `manifest` field itself contains a corresponding signature \(`manifest_signature`\) to guard against
+man-in-the-middle attacks between the `agave-install` tool and the solana cluster RPC API.
 
-To guard against rollback attacks, `agave-install` will refuse to install an update with an older `timestamp_secs` than what is currently installed.
+To guard against rollback attacks, `agave-install` will refuse to install an update with an older `timestamp_secs` than
+what is currently installed.
 
 ## Release Archive Contents
 
@@ -116,7 +126,8 @@ The `agave-install` tool is used by the user to install and update their cluster
 It manages the following files and directories in the user's home directory:
 
 - `~/.config/solana/install/config.yml` - user configuration and information about currently installed software version
-- `~/.local/share/solana/install/bin` - a symlink to the current release. eg, `~/.local/share/solana-update/<update-pubkey>-<manifest_signature>/bin`
+- `~/.local/share/solana/install/bin` - a symlink to the current release.
+  eg, `~/.local/share/solana-update/<update-pubkey>-<manifest_signature>/bin`
 - `~/.local/share/solana/install/releases/<download_sha256>/` - contents of a release
 
 ### Command-line Interface
diff --git a/entry/src/entry.rs b/entry/src/entry.rs
index da4fda5914a3..ebf91dc644e9 100644
--- a/entry/src/entry.rs
+++ b/entry/src/entry.rs
@@ -220,7 +220,7 @@ pub fn hash_transactions(transactions: &[VersionedTransaction]) -> Hash {
         .iter()
         .flat_map(|tx| tx.signatures.iter())
         .collect();
-    let merkle_tree = MerkleTree::new(&signatures);
+    let merkle_tree = MerkleTree::new(&signatures, false);
     if let Some(root_hash) = merkle_tree.get_root() {
         *root_hash
     } else {
diff --git a/entry/src/poh.rs b/entry/src/poh.rs
index 9bf6be66a059..84325a9e508c 100644
--- a/entry/src/poh.rs
+++ b/entry/src/poh.rs
@@ -72,19 +72,30 @@ impl Poh {
     }
 
     pub fn record(&mut self, mixin: Hash) -> Option<PohEntry> {
-        if self.remaining_hashes == 1 {
+        let entries = self.record_bundle(&[mixin]);
+        entries.unwrap_or_default().pop()
+    }
+
+    pub fn record_bundle(&mut self, mixins: &[Hash]) -> Option<Vec<PohEntry>> {
+        if self.remaining_hashes <= mixins.len() as u64 {
             return None; // Caller needs to `tick()` first
         }
 
-        self.hash = hashv(&[self.hash.as_ref(), mixin.as_ref()]);
-        let num_hashes = self.num_hashes + 1;
-        self.num_hashes = 0;
-        self.remaining_hashes -= 1;
+        let entries = mixins
+            .iter()
+            .map(|m| {
+                self.hash = hashv(&[self.hash.as_ref(), m.as_ref()]);
+                let num_hashes = self.num_hashes + 1;
+                self.num_hashes = 0;
+                self.remaining_hashes -= 1;
+                PohEntry {
+                    num_hashes,
+                    hash: self.hash,
+                }
+            })
+            .collect();
 
-        Some(PohEntry {
-            num_hashes,
-            hash: self.hash,
-        })
+        Some(entries)
     }
 
     pub fn tick(&mut self) -> Option<PohEntry> {
diff --git a/f b/f
new file mode 100755
index 000000000000..e5fe63550880
--- /dev/null
+++ b/f
@@ -0,0 +1,30 @@
+#!/usr/bin/env bash
+# Builds jito-solana in a docker container.
+# Useful for running on machines that might not have cargo installed but can run docker (Flatcar Linux).
+# run `./f true` to compile with debug flags
+
+set -eux
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
+
+GIT_SHA="$(git rev-parse --short HEAD)"
+
+echo "Git hash: $GIT_SHA"
+
+DEBUG_FLAGS=${1-false}
+
+DOCKER_BUILDKIT=1 docker build \
+  --build-arg debug=$DEBUG_FLAGS \
+  --build-arg ci_commit=$GIT_SHA \
+  -t jitolabs/build-solana \
+  -f dev/Dockerfile . \
+  --progress=plain
+
+# Creates a temporary container, copies solana-validator built inside container there and
+# removes the temporary container.
+docker rm temp || true
+docker container create --name temp jitolabs/build-solana
+mkdir -p $SCRIPT_DIR/docker-output
+# Outputs the solana-validator binary to $SOLANA/docker-output/solana-validator
+docker container cp temp:/solana/docker-output $SCRIPT_DIR/
+docker rm temp
diff --git a/fetch-spl.sh b/fetch-spl.sh
index 97fb1c50aa52..97de447388fc 100755
--- a/fetch-spl.sh
+++ b/fetch-spl.sh
@@ -13,8 +13,24 @@ fetch_program() {
   declare version=$2
   declare address=$3
   declare loader=$4
+  declare repo=$5
 
-  declare so=spl_$name-$version.so
+  case $repo in
+  "jito")
+    so=$name-$version.so
+    so_name="$name.so"
+    url="https://github.com/jito-foundation/jito-programs/releases/download/v$version/$so_name"
+    ;;
+  "solana")
+    so=spl_$name-$version.so
+    so_name="spl_${name//-/_}.so"
+    url="https://github.com/solana-labs/solana-program-library/releases/download/$name-v$version/$so_name"
+    ;;
+  *)
+    echo "Unsupported repo: $repo"
+    return 1
+    ;;
+  esac
 
   if [[ $loader == "$upgradeableLoader" ]]; then
     genesis_args+=(--upgradeable-program "$address" "$loader" "$so" none)
@@ -30,12 +46,11 @@ fetch_program() {
     cp ~/.cache/solana-spl/"$so" "$so"
   else
     echo "Downloading $name $version"
-    so_name="spl_${name//-/_}.so"
     (
       set -x
       curl -L --retry 5 --retry-delay 2 --retry-connrefused \
         -o "$so" \
-        "https://github.com/solana-labs/solana-program-library/releases/download/$name-v$version/$so_name"
+        "$url"
     )
 
     mkdir -p ~/.cache/solana-spl
@@ -44,19 +59,25 @@ fetch_program() {
 
 }
 
-fetch_program token 3.5.0 TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA BPFLoader2111111111111111111111111111111111
-fetch_program token-2022 1.0.0 TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb BPFLoaderUpgradeab1e11111111111111111111111
-fetch_program memo  1.0.0 Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo BPFLoader1111111111111111111111111111111111
-fetch_program memo  3.0.0 MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr BPFLoader2111111111111111111111111111111111
-fetch_program associated-token-account 1.1.2 ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL BPFLoader2111111111111111111111111111111111
-fetch_program feature-proposal 1.0.0 Feat1YXHhH6t1juaWF74WLcfv4XoNocjXA6sPWHNgAse BPFLoader2111111111111111111111111111111111
+fetch_program token 3.5.0 TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA BPFLoader2111111111111111111111111111111111 solana
+fetch_program token-2022 1.0.0 TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb BPFLoaderUpgradeab1e11111111111111111111111 solana
+fetch_program memo  1.0.0 Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo BPFLoader1111111111111111111111111111111111 solana
+fetch_program memo  3.0.0 MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr BPFLoader2111111111111111111111111111111111 solana
+fetch_program associated-token-account 1.1.2 ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL BPFLoader2111111111111111111111111111111111 solana
+fetch_program feature-proposal 1.0.0 Feat1YXHhH6t1juaWF74WLcfv4XoNocjXA6sPWHNgAse BPFLoader2111111111111111111111111111111111 solana
+# jito programs
+fetch_program jito_tip_payment 0.1.4 T1pyyaTNZsKv2WcRAB8oVnk93mLJw2XzjtVYqCsaHqt BPFLoaderUpgradeab1e11111111111111111111111 jito
+fetch_program jito_tip_distribution 0.1.4 4R3gSG8BpU4t19KYj8CfnbtRpnT8gtk4dvTHxVRwc2r7 BPFLoaderUpgradeab1e11111111111111111111111 jito
 
-echo "${genesis_args[@]}" > spl-genesis-args.sh
+echo "${genesis_args[@]}" >spl-genesis-args.sh
 
 echo
 echo "Available SPL programs:"
 ls -l spl_*.so
 
+echo "Available Jito programs:"
+ls -l jito*.so
+
 echo
 echo "solana-genesis command-line arguments (spl-genesis-args.sh):"
 cat spl-genesis-args.sh
diff --git a/gossip/src/cluster_info.rs b/gossip/src/cluster_info.rs
index 7c1dd11dd3d9..85d8cf63edda 100644
--- a/gossip/src/cluster_info.rs
+++ b/gossip/src/cluster_info.rs
@@ -572,6 +572,10 @@ impl ClusterInfo {
         *self.entrypoints.write().unwrap() = entrypoints;
     }
 
+    pub fn set_my_contact_info(&self, my_contact_info: ContactInfo) {
+        *self.my_contact_info.write().unwrap() = my_contact_info;
+    }
+
     pub fn save_contact_info(&self) {
         let nodes = {
             let entrypoint_gossip_addrs = self
diff --git a/install/agave-install-init.sh b/install/agave-install-init.sh
index cf2d1babf3c3..8fa5dbbcdf1f 100755
--- a/install/agave-install-init.sh
+++ b/install/agave-install-init.sh
@@ -16,9 +16,9 @@
 { # this ensures the entire script is downloaded #
 
 if [ -z "$SOLANA_DOWNLOAD_ROOT" ]; then
-    SOLANA_DOWNLOAD_ROOT="https://github.com/anza-xyz/agave/releases/download/"
+    SOLANA_DOWNLOAD_ROOT="https://github.com/jito-foundation/jito-solana/releases/download/"
 fi
-GH_LATEST_RELEASE="https://api.github.com/repos/anza-xyz/agave/releases/latest"
+GH_LATEST_RELEASE="https://api.github.com/repos/jito-foundation/jito-solana/releases/latest"
 
 set -e
 
diff --git a/install/src/command.rs b/install/src/command.rs
index 8a81e1d72337..09165562cf83 100644
--- a/install/src/command.rs
+++ b/install/src/command.rs
@@ -568,7 +568,7 @@ pub fn init(
 
 fn github_release_download_url(release_semver: &str) -> String {
     format!(
-        "https://github.com/anza-xyz/agave/releases/download/v{}/solana-release-{}.tar.bz2",
+        "https://github.com/jito-foundation/jito-solana/releases/download/v{}/solana-release-{}.tar.bz2",
         release_semver,
         crate::build_env::TARGET
     )
@@ -576,7 +576,7 @@ fn github_release_download_url(release_semver: &str) -> String {
 
 fn release_channel_download_url(release_channel: &str) -> String {
     format!(
-        "https://release.anza.xyz/{}/solana-release-{}.tar.bz2",
+        "https://release.jito.wtf/{}/solana-release-{}.tar.bz2",
         release_channel,
         crate::build_env::TARGET
     )
@@ -584,7 +584,7 @@ fn release_channel_download_url(release_channel: &str) -> String {
 
 fn release_channel_version_url(release_channel: &str) -> String {
     format!(
-        "https://release.anza.xyz/{}/solana-release-{}.yml",
+        "https://release.jito.wtf/{}/solana-release-{}.yml",
         release_channel,
         crate::build_env::TARGET
     )
@@ -901,7 +901,7 @@ fn check_for_newer_github_release(
 
     while page == 1 || releases.len() == PER_PAGE {
         let url = reqwest::Url::parse_with_params(
-            "https://api.github.com/repos/anza-xyz/agave/releases",
+            "https://api.github.com/repos/jito-foundation/jito-solana/releases",
             &[
                 ("per_page", &format!("{PER_PAGE}")),
                 ("page", &format!("{page}")),
diff --git a/jito-programs b/jito-programs
new file mode 160000
index 000000000000..d2b9c58189bb
--- /dev/null
+++ b/jito-programs
@@ -0,0 +1 @@
+Subproject commit d2b9c58189bb69d6f90b1ed513beea8cc9d7c013
diff --git a/jito-protos/Cargo.toml b/jito-protos/Cargo.toml
new file mode 100644
index 000000000000..f9f0b5baa312
--- /dev/null
+++ b/jito-protos/Cargo.toml
@@ -0,0 +1,19 @@
+[package]
+name = "jito-protos"
+version = { workspace = true }
+edition = { workspace = true }
+publish = false
+
+[dependencies]
+bytes = { workspace = true }
+prost = { workspace = true }
+prost-types = { workspace = true }
+tonic = { workspace = true }
+
+[build-dependencies]
+tonic-build = { workspace = true }
+
+# windows users should install the protobuf compiler manually and set the PROTOC
+# envar to point to the installed binary
+[target."cfg(not(windows))".build-dependencies]
+protobuf-src = { workspace = true }
diff --git a/jito-protos/build.rs b/jito-protos/build.rs
new file mode 100644
index 000000000000..30ece1620a5e
--- /dev/null
+++ b/jito-protos/build.rs
@@ -0,0 +1,38 @@
+use tonic_build::configure;
+
+fn main() -> Result<(), std::io::Error> {
+    const PROTOC_ENVAR: &str = "PROTOC";
+    if std::env::var(PROTOC_ENVAR).is_err() {
+        #[cfg(not(windows))]
+        std::env::set_var(PROTOC_ENVAR, protobuf_src::protoc());
+    }
+
+    let proto_base_path = std::path::PathBuf::from("protos");
+    let proto_files = [
+        "auth.proto",
+        "block_engine.proto",
+        "bundle.proto",
+        "packet.proto",
+        "relayer.proto",
+        "shared.proto",
+    ];
+    let mut protos = Vec::new();
+    for proto_file in &proto_files {
+        let proto = proto_base_path.join(proto_file);
+        println!("cargo:rerun-if-changed={}", proto.display());
+        protos.push(proto);
+    }
+
+    configure()
+        .build_client(true)
+        .build_server(false)
+        .type_attribute(
+            "TransactionErrorType",
+            "#[cfg_attr(test, derive(enum_iterator::Sequence))]",
+        )
+        .type_attribute(
+            "InstructionErrorType",
+            "#[cfg_attr(test, derive(enum_iterator::Sequence))]",
+        )
+        .compile(&protos, &[proto_base_path])
+}
diff --git a/jito-protos/protos b/jito-protos/protos
new file mode 160000
index 000000000000..b74a23ff236c
--- /dev/null
+++ b/jito-protos/protos
@@ -0,0 +1 @@
+Subproject commit b74a23ff236c0c223b1bc56daf7c5065bb585428
diff --git a/jito-protos/src/lib.rs b/jito-protos/src/lib.rs
new file mode 100644
index 000000000000..cf630c53d280
--- /dev/null
+++ b/jito-protos/src/lib.rs
@@ -0,0 +1,25 @@
+pub mod proto {
+    pub mod auth {
+        tonic::include_proto!("auth");
+    }
+
+    pub mod block_engine {
+        tonic::include_proto!("block_engine");
+    }
+
+    pub mod bundle {
+        tonic::include_proto!("bundle");
+    }
+
+    pub mod packet {
+        tonic::include_proto!("packet");
+    }
+
+    pub mod relayer {
+        tonic::include_proto!("relayer");
+    }
+
+    pub mod shared {
+        tonic::include_proto!("shared");
+    }
+}
diff --git a/ledger-tool/src/bigtable.rs b/ledger-tool/src/bigtable.rs
index a79645e4282e..e195ac1cb69e 100644
--- a/ledger-tool/src/bigtable.rs
+++ b/ledger-tool/src/bigtable.rs
@@ -1380,6 +1380,7 @@ pub fn bigtable_process_command(ledger_path: &Path, matches: &ArgMatches<'_>) {
                 blockstore.clone(),
                 process_options,
                 None,
+                true,
             );
 
             let bank = bank_forks.read().unwrap().working_bank();
diff --git a/ledger-tool/src/ledger_utils.rs b/ledger-tool/src/ledger_utils.rs
index 30f1d77a6804..5f55dce4ebad 100644
--- a/ledger-tool/src/ledger_utils.rs
+++ b/ledger-tool/src/ledger_utils.rs
@@ -112,6 +112,7 @@ pub fn load_and_process_ledger_or_exit(
     blockstore: Arc<Blockstore>,
     process_options: ProcessOptions,
     transaction_status_sender: Option<TransactionStatusSender>,
+    ignore_halt_at_slot_for_snapshot_loading: bool,
 ) -> LoadAndProcessLedgerOutput {
     load_and_process_ledger(
         arg_matches,
@@ -119,6 +120,7 @@ pub fn load_and_process_ledger_or_exit(
         blockstore,
         process_options,
         transaction_status_sender,
+        ignore_halt_at_slot_for_snapshot_loading,
     )
     .unwrap_or_else(|err| {
         eprintln!("Exiting. Failed to load and process ledger: {err}");
@@ -132,6 +134,7 @@ pub fn load_and_process_ledger(
     blockstore: Arc<Blockstore>,
     process_options: ProcessOptions,
     transaction_status_sender: Option<TransactionStatusSender>,
+    ignore_halt_at_slot_for_snapshot_loading: bool,
 ) -> Result<LoadAndProcessLedgerOutput, LoadAndProcessLedgerError> {
     let bank_snapshots_dir = if blockstore.is_primary_access() {
         blockstore.ledger_path().join("snapshot")
@@ -142,6 +145,12 @@ pub fn load_and_process_ledger(
             .join("snapshot")
     };
 
+    let snapshot_halt_at_slot = if ignore_halt_at_slot_for_snapshot_loading {
+        None
+    } else {
+        process_options.halt_at_slot
+    };
+
     let mut starting_slot = 0; // default start check with genesis
     let snapshot_config = if arg_matches.is_present("no_snapshot") {
         None
@@ -155,13 +164,15 @@ pub fn load_and_process_ledger(
                 .ok()
                 .map(PathBuf::from)
                 .unwrap_or_else(|| full_snapshot_archives_dir.clone());
-        if let Some(full_snapshot_slot) =
-            snapshot_utils::get_highest_full_snapshot_archive_slot(&full_snapshot_archives_dir)
-        {
+        if let Some(full_snapshot_slot) = snapshot_utils::get_highest_full_snapshot_archive_slot(
+            &full_snapshot_archives_dir,
+            snapshot_halt_at_slot,
+        ) {
             let incremental_snapshot_slot =
                 snapshot_utils::get_highest_incremental_snapshot_archive_slot(
                     &incremental_snapshot_archives_dir,
                     full_snapshot_slot,
+                    snapshot_halt_at_slot,
                 )
                 .unwrap_or_default();
             starting_slot = std::cmp::max(full_snapshot_slot, incremental_snapshot_slot);
@@ -294,6 +305,7 @@ pub fn load_and_process_ledger(
             None, // Maybe support this later, though
             accounts_update_notifier,
             exit.clone(),
+            ignore_halt_at_slot_for_snapshot_loading,
         )
         .map_err(LoadAndProcessLedgerError::LoadBankForks)?;
     let block_verification_method = value_t!(
diff --git a/ledger-tool/src/main.rs b/ledger-tool/src/main.rs
index 51e1dfe1b08f..1040bcf356c5 100644
--- a/ledger-tool/src/main.rs
+++ b/ledger-tool/src/main.rs
@@ -1438,8 +1438,8 @@ fn main() {
                             Arc::new(blockstore),
                             process_options,
                             None,
+                            true,
                         );
-
                     println!(
                         "{}",
                         compute_shred_version(
@@ -1632,6 +1632,7 @@ fn main() {
                             Arc::new(blockstore),
                             process_options,
                             transaction_status_sender,
+                            true,
                         );
 
                     let working_bank = bank_forks.read().unwrap().working_bank();
@@ -1699,6 +1700,7 @@ fn main() {
                             Arc::new(blockstore),
                             process_options,
                             None,
+                            true,
                         );
 
                     let dot = graph_forks(&bank_forks.read().unwrap(), &graph_config);
@@ -1872,6 +1874,7 @@ fn main() {
                         blockstore.clone(),
                         process_options,
                         None,
+                        false,
                     );
                     // Snapshot creation will implicitly perform AccountsDb
                     // flush and clean operations. These operations cannot be
@@ -2267,6 +2270,7 @@ fn main() {
                             Arc::new(blockstore),
                             process_options,
                             None,
+                            true,
                         );
                     let bank = bank_forks.read().unwrap().working_bank();
 
@@ -2319,7 +2323,9 @@ fn main() {
                             Arc::new(blockstore),
                             process_options,
                             None,
+                            true,
                         );
+
                     let bank_forks = bank_forks.read().unwrap();
                     let slot = bank_forks.working_bank().slot();
                     let bank = bank_forks.get(slot).unwrap_or_else(|| {
diff --git a/ledger-tool/src/program.rs b/ledger-tool/src/program.rs
index 463d017b17db..e240f9d845c1 100644
--- a/ledger-tool/src/program.rs
+++ b/ledger-tool/src/program.rs
@@ -85,6 +85,7 @@ fn load_blockstore(ledger_path: &Path, arg_matches: &ArgMatches<'_>) -> Arc<Bank
         Arc::new(blockstore),
         process_options,
         None,
+        true,
     );
     let bank = bank_forks.read().unwrap().working_bank();
     bank
diff --git a/ledger/src/bank_forks_utils.rs b/ledger/src/bank_forks_utils.rs
index 6a48ebd2cebc..2cc3db7d3552 100644
--- a/ledger/src/bank_forks_utils.rs
+++ b/ledger/src/bank_forks_utils.rs
@@ -22,7 +22,7 @@ use {
         snapshot_hash::{FullSnapshotHash, IncrementalSnapshotHash, StartingSnapshotHashes},
         snapshot_utils,
     },
-    solana_sdk::genesis_config::GenesisConfig,
+    solana_sdk::{clock::Slot, genesis_config::GenesisConfig},
     std::{
         path::PathBuf,
         result,
@@ -98,6 +98,7 @@ pub fn load(
         entry_notification_sender,
         accounts_update_notifier,
         exit,
+        true,
     )?;
     blockstore_processor::process_blockstore_from_root(
         blockstore,
@@ -125,9 +126,12 @@ pub fn load_bank_forks(
     entry_notification_sender: Option<&EntryNotifierSender>,
     accounts_update_notifier: Option<AccountsUpdateNotifier>,
     exit: Arc<AtomicBool>,
+    ignore_halt_at_slot_for_snapshot_loading: bool,
 ) -> LoadResult {
     fn get_snapshots_to_load(
         snapshot_config: Option<&SnapshotConfig>,
+        halt_at_slot: Option<Slot>,
+        ignore_halt_at_slot_for_snapshot_loading: bool,
     ) -> Option<(
         FullSnapshotArchiveInfo,
         Option<IncrementalSnapshotArchiveInfo>,
@@ -137,9 +141,16 @@ pub fn load_bank_forks(
             return None;
         };
 
+        let halt_at_slot = if ignore_halt_at_slot_for_snapshot_loading {
+            None
+        } else {
+            halt_at_slot
+        };
+
         let Some(full_snapshot_archive_info) =
             snapshot_utils::get_highest_full_snapshot_archive_info(
                 &snapshot_config.full_snapshot_archives_dir,
+                halt_at_slot,
             )
         else {
             warn!(
@@ -153,6 +164,7 @@ pub fn load_bank_forks(
             snapshot_utils::get_highest_incremental_snapshot_archive_info(
                 &snapshot_config.incremental_snapshot_archives_dir,
                 full_snapshot_archive_info.slot(),
+                halt_at_slot,
             );
 
         Some((
@@ -163,7 +175,11 @@ pub fn load_bank_forks(
 
     let (bank_forks, starting_snapshot_hashes) =
         if let Some((full_snapshot_archive_info, incremental_snapshot_archive_info)) =
-            get_snapshots_to_load(snapshot_config)
+            get_snapshots_to_load(
+                snapshot_config,
+                process_options.halt_at_slot,
+                ignore_halt_at_slot_for_snapshot_loading,
+            )
         {
             // SAFETY: Having snapshots to load ensures a snapshot config
             let snapshot_config = snapshot_config.unwrap();
@@ -222,7 +238,7 @@ pub fn load_bank_forks(
 }
 
 #[allow(clippy::too_many_arguments)]
-fn bank_forks_from_snapshot(
+pub fn bank_forks_from_snapshot(
     full_snapshot_archive_info: FullSnapshotArchiveInfo,
     incremental_snapshot_archive_info: Option<IncrementalSnapshotArchiveInfo>,
     genesis_config: &GenesisConfig,
diff --git a/ledger/src/blockstore_processor.rs b/ledger/src/blockstore_processor.rs
index 67330d5a949c..faeb305b1b34 100644
--- a/ledger/src/blockstore_processor.rs
+++ b/ledger/src/blockstore_processor.rs
@@ -162,7 +162,7 @@ pub fn execute_batch(
     let mut mint_decimals: HashMap<Pubkey, u8> = HashMap::new();
 
     let pre_token_balances = if record_token_balances {
-        collect_token_balances(bank, batch, &mut mint_decimals)
+        collect_token_balances(bank, batch, &mut mint_decimals, None)
     } else {
         vec![]
     };
@@ -220,7 +220,7 @@ pub fn execute_batch(
     if let Some(transaction_status_sender) = transaction_status_sender {
         let transactions = batch.sanitized_transactions().to_vec();
         let post_token_balances = if record_token_balances {
-            collect_token_balances(bank, batch, &mut mint_decimals)
+            collect_token_balances(bank, batch, &mut mint_decimals, None)
         } else {
             vec![]
         };
@@ -854,6 +854,7 @@ pub fn test_process_blockstore(
         None,
         None,
         exit,
+        true,
     )
     .unwrap();
 
diff --git a/ledger/src/token_balances.rs b/ledger/src/token_balances.rs
index cc074dfcc0da..0055bffa1ee1 100644
--- a/ledger/src/token_balances.rs
+++ b/ledger/src/token_balances.rs
@@ -7,6 +7,7 @@ use {
     solana_metrics::datapoint_debug,
     solana_runtime::{bank::Bank, transaction_batch::TransactionBatch},
     solana_sdk::{account::ReadableAccount, pubkey::Pubkey},
+    solana_svm::account_overrides::AccountOverrides,
     solana_transaction_status::{
         token_balances::TransactionTokenBalances, TransactionTokenBalance,
     },
@@ -39,6 +40,7 @@ pub fn collect_token_balances(
     bank: &Bank,
     batch: &TransactionBatch,
     mint_decimals: &mut HashMap<Pubkey, u8>,
+    cached_accounts: Option<&AccountOverrides>,
 ) -> TransactionTokenBalances {
     let mut balances: TransactionTokenBalances = vec![];
     let mut collect_time = Measure::start("collect_token_balances");
@@ -59,8 +61,12 @@ pub fn collect_token_balances(
                     ui_token_amount,
                     owner,
                     program_id,
-                }) = collect_token_balance_from_account(bank, account_id, mint_decimals)
-                {
+                }) = collect_token_balance_from_account(
+                    bank,
+                    account_id,
+                    mint_decimals,
+                    cached_accounts,
+                ) {
                     transaction_balances.push(TransactionTokenBalance {
                         account_index: index as u8,
                         mint,
@@ -93,8 +99,17 @@ fn collect_token_balance_from_account(
     bank: &Bank,
     account_id: &Pubkey,
     mint_decimals: &mut HashMap<Pubkey, u8>,
+    account_overrides: Option<&AccountOverrides>,
 ) -> Option<TokenBalanceData> {
-    let account = bank.get_account(account_id)?;
+    let account = {
+        if let Some(account_override) =
+            account_overrides.and_then(|overrides| overrides.get(account_id))
+        {
+            Some(account_override.clone())
+        } else {
+            bank.get_account(account_id)
+        }
+    }?;
 
     if !is_known_spl_token_id(account.owner()) {
         return None;
@@ -243,13 +258,13 @@ mod test {
 
         // Account is not owned by spl_token (nor does it have TokenAccount state)
         assert_eq!(
-            collect_token_balance_from_account(&bank, &account_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(&bank, &account_pubkey, &mut mint_decimals, None),
             None
         );
 
         // Mint does not have TokenAccount state
         assert_eq!(
-            collect_token_balance_from_account(&bank, &mint_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(&bank, &mint_pubkey, &mut mint_decimals, None),
             None
         );
 
@@ -258,7 +273,8 @@ mod test {
             collect_token_balance_from_account(
                 &bank,
                 &spl_token_account_pubkey,
-                &mut mint_decimals
+                &mut mint_decimals,
+                None
             ),
             Some(TokenBalanceData {
                 mint: mint_pubkey.to_string(),
@@ -275,7 +291,12 @@ mod test {
 
         // TokenAccount is not owned by known spl-token program_id
         assert_eq!(
-            collect_token_balance_from_account(&bank, &other_account_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(
+                &bank,
+                &other_account_pubkey,
+                &mut mint_decimals,
+                None
+            ),
             None
         );
 
@@ -284,7 +305,8 @@ mod test {
             collect_token_balance_from_account(
                 &bank,
                 &other_mint_account_pubkey,
-                &mut mint_decimals
+                &mut mint_decimals,
+                None
             ),
             None
         );
@@ -437,13 +459,13 @@ mod test {
 
         // Account is not owned by spl_token (nor does it have TokenAccount state)
         assert_eq!(
-            collect_token_balance_from_account(&bank, &account_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(&bank, &account_pubkey, &mut mint_decimals, None),
             None
         );
 
         // Mint does not have TokenAccount state
         assert_eq!(
-            collect_token_balance_from_account(&bank, &mint_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(&bank, &mint_pubkey, &mut mint_decimals, None),
             None
         );
 
@@ -452,7 +474,8 @@ mod test {
             collect_token_balance_from_account(
                 &bank,
                 &spl_token_account_pubkey,
-                &mut mint_decimals
+                &mut mint_decimals,
+                None
             ),
             Some(TokenBalanceData {
                 mint: mint_pubkey.to_string(),
@@ -469,7 +492,12 @@ mod test {
 
         // TokenAccount is not owned by known spl-token program_id
         assert_eq!(
-            collect_token_balance_from_account(&bank, &other_account_pubkey, &mut mint_decimals),
+            collect_token_balance_from_account(
+                &bank,
+                &other_account_pubkey,
+                &mut mint_decimals,
+                None
+            ),
             None
         );
 
@@ -478,7 +506,8 @@ mod test {
             collect_token_balance_from_account(
                 &bank,
                 &other_mint_account_pubkey,
-                &mut mint_decimals
+                &mut mint_decimals,
+                None
             ),
             None
         );
diff --git a/local-cluster/src/local_cluster.rs b/local-cluster/src/local_cluster.rs
index f6bef8bff3c6..4295800f048f 100644
--- a/local-cluster/src/local_cluster.rs
+++ b/local-cluster/src/local_cluster.rs
@@ -339,6 +339,7 @@ impl LocalCluster {
             DEFAULT_TPU_ENABLE_UDP,
             32, // max connections per IpAddr per minute
             Arc::new(RwLock::new(None)),
+            None,
         )
         .expect("assume successful validator start");
 
@@ -541,6 +542,7 @@ impl LocalCluster {
             DEFAULT_TPU_ENABLE_UDP,
             32, // max connections per IpAddr per mintute
             Arc::new(RwLock::new(None)),
+            None,
         )
         .expect("assume successful validator start");
 
@@ -1087,6 +1089,7 @@ impl Cluster for LocalCluster {
             DEFAULT_TPU_ENABLE_UDP,
             32, // max connections per IpAddr per minute, use higher value because of tests
             Arc::new(RwLock::new(None)),
+            None,
         )
         .expect("assume successful validator start");
         cluster_validator_info.validator = Some(restarted_node);
diff --git a/local-cluster/src/local_cluster_snapshot_utils.rs b/local-cluster/src/local_cluster_snapshot_utils.rs
index 3ba9cda04d94..95923cabd942 100644
--- a/local-cluster/src/local_cluster_snapshot_utils.rs
+++ b/local-cluster/src/local_cluster_snapshot_utils.rs
@@ -91,7 +91,10 @@ impl LocalCluster {
         let timer = Instant::now();
         let next_snapshot = loop {
             if let Some(full_snapshot_archive_info) =
-                snapshot_utils::get_highest_full_snapshot_archive_info(&full_snapshot_archives_dir)
+                snapshot_utils::get_highest_full_snapshot_archive_info(
+                    &full_snapshot_archives_dir,
+                    None,
+                )
             {
                 match next_snapshot_type {
                     NextSnapshotType::FullSnapshot => {
@@ -104,6 +107,7 @@ impl LocalCluster {
                             snapshot_utils::get_highest_incremental_snapshot_archive_info(
                                 incremental_snapshot_archives_dir.as_ref().unwrap(),
                                 full_snapshot_archive_info.slot(),
+                                None,
                             )
                         {
                             if incremental_snapshot_archive_info.slot() >= last_slot {
diff --git a/local-cluster/src/validator_configs.rs b/local-cluster/src/validator_configs.rs
index a2366eb41489..05971e1f0208 100644
--- a/local-cluster/src/validator_configs.rs
+++ b/local-cluster/src/validator_configs.rs
@@ -73,6 +73,11 @@ pub fn safe_clone_config(config: &ValidatorConfig) -> ValidatorConfig {
         replay_forks_threads: config.replay_forks_threads,
         replay_transactions_threads: config.replay_transactions_threads,
         delay_leader_block_for_pending_fork: config.delay_leader_block_for_pending_fork,
+        relayer_config: config.relayer_config.clone(),
+        block_engine_config: config.block_engine_config.clone(),
+        shred_receiver_address: config.shred_receiver_address.clone(),
+        tip_manager_config: config.tip_manager_config.clone(),
+        preallocated_bundle_cost: config.preallocated_bundle_cost,
     }
 }
 
diff --git a/local-cluster/tests/local_cluster.rs b/local-cluster/tests/local_cluster.rs
index 8826ca0a17ed..1e4414a0cf27 100644
--- a/local-cluster/tests/local_cluster.rs
+++ b/local-cluster/tests/local_cluster.rs
@@ -843,6 +843,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
         validator_snapshot_test_config
             .full_snapshot_archives_dir
             .path(),
+        None,
     )
     .unwrap();
     info!(
@@ -882,6 +883,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
                 .incremental_snapshot_archives_dir
                 .path(),
             full_snapshot_archive.slot(),
+            None,
         )
         .unwrap();
     info!(
@@ -1025,6 +1027,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
             validator_snapshot_test_config
                 .full_snapshot_archives_dir
                 .path(),
+            None,
         )
         .unwrap();
 
@@ -1091,6 +1094,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
             validator_snapshot_test_config
                 .full_snapshot_archives_dir
                 .path(),
+            None,
         )
         .unwrap();
 
@@ -1119,6 +1123,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
             validator_snapshot_test_config
                 .full_snapshot_archives_dir
                 .path(),
+            None,
         ) {
             if full_snapshot_slot >= validator_next_full_snapshot_slot {
                 if let Some(incremental_snapshot_slot) =
@@ -1127,6 +1132,7 @@ fn test_incremental_snapshot_download_with_crossing_full_snapshot_interval_at_st
                             .incremental_snapshot_archives_dir
                             .path(),
                         full_snapshot_slot,
+                        None,
                     )
                 {
                     if incremental_snapshot_slot >= validator_next_incremental_snapshot_slot {
@@ -1321,8 +1327,10 @@ fn test_snapshots_blockstore_floor() {
     trace!("Waiting for snapshot tar to be generated with slot",);
 
     let archive_info = loop {
-        let archive =
-            snapshot_utils::get_highest_full_snapshot_archive_info(full_snapshot_archives_dir);
+        let archive = snapshot_utils::get_highest_full_snapshot_archive_info(
+            full_snapshot_archives_dir,
+            None,
+        );
         if archive.is_some() {
             trace!("snapshot exists");
             break archive.unwrap();
@@ -4960,11 +4968,13 @@ fn test_boot_from_local_state() {
     let bank_snapshot = loop {
         if let Some(full_snapshot_slot) = snapshot_utils::get_highest_full_snapshot_archive_slot(
             &validator2_config.full_snapshot_archives_dir,
+            None,
         ) {
             if let Some(incremental_snapshot_slot) =
                 snapshot_utils::get_highest_incremental_snapshot_archive_slot(
                     &validator2_config.incremental_snapshot_archives_dir,
                     full_snapshot_slot,
+                    None,
                 )
             {
                 if let Some(bank_snapshot) = snapshot_utils::get_highest_bank_snapshot_post(
@@ -5064,12 +5074,14 @@ fn test_boot_from_local_state() {
             if let Some(other_full_snapshot_slot) =
                 snapshot_utils::get_highest_full_snapshot_archive_slot(
                     &other_validator_config.full_snapshot_archives_dir,
+                    None,
                 )
             {
                 let other_incremental_snapshot_slot =
                     snapshot_utils::get_highest_incremental_snapshot_archive_slot(
                         &other_validator_config.incremental_snapshot_archives_dir,
                         other_full_snapshot_slot,
+                        None,
                     );
                 if other_full_snapshot_slot >= full_snapshot_archive.slot()
                     && other_incremental_snapshot_slot >= Some(incremental_snapshot_archive.slot())
@@ -5183,6 +5195,7 @@ fn test_boot_from_local_state_missing_archive() {
     info!("Deleting latest full snapshot archive...");
     let highest_full_snapshot = snapshot_utils::get_highest_full_snapshot_archive_info(
         validator_config.full_snapshot_archives_dir.path(),
+        None,
     )
     .unwrap();
     fs::remove_file(highest_full_snapshot.path()).unwrap();
diff --git a/merkle-tree/src/merkle_tree.rs b/merkle-tree/src/merkle_tree.rs
index 09285a41e7af..57bceea1ecc0 100644
--- a/merkle-tree/src/merkle_tree.rs
+++ b/merkle-tree/src/merkle_tree.rs
@@ -18,7 +18,7 @@ macro_rules! hash_intermediate {
     }
 }
 
-#[derive(Debug)]
+#[derive(Default, Debug, Eq, Hash, PartialEq)]
 pub struct MerkleTree {
     leaf_count: usize,
     nodes: Vec<Hash>,
@@ -36,6 +36,14 @@ impl<'a> ProofEntry<'a> {
         assert!(left_sibling.is_none() ^ right_sibling.is_none());
         Self(target, left_sibling, right_sibling)
     }
+
+    pub fn get_left_sibling(&self) -> Option<&'a Hash> {
+        self.1
+    }
+
+    pub fn get_right_sibling(&self) -> Option<&'a Hash> {
+        self.2
+    }
 }
 
 #[derive(Debug, Default, PartialEq, Eq)]
@@ -60,6 +68,10 @@ impl<'a> Proof<'a> {
         });
         result.is_some()
     }
+
+    pub fn get_proof_entries(self) -> Vec<ProofEntry<'a>> {
+        self.0
+    }
 }
 
 impl MerkleTree {
@@ -95,7 +107,7 @@ impl MerkleTree {
         }
     }
 
-    pub fn new<T: AsRef<[u8]>>(items: &[T]) -> Self {
+    pub fn new<T: AsRef<[u8]>>(items: &[T], sorted_hashes: bool) -> Self {
         let cap = MerkleTree::calculate_vec_capacity(items.len());
         let mut mt = MerkleTree {
             leaf_count: items.len(),
@@ -123,8 +135,20 @@ impl MerkleTree {
                     &mt.nodes[prev_level_start + prev_level_idx]
                 };
 
-                let hash = hash_intermediate!(lsib, rsib);
-                mt.nodes.push(hash);
+                // tip-distribution verification uses sorted hashing
+                if sorted_hashes {
+                    if lsib <= rsib {
+                        let hash = hash_intermediate!(lsib, rsib);
+                        mt.nodes.push(hash);
+                    } else {
+                        let hash = hash_intermediate!(rsib, lsib);
+                        mt.nodes.push(hash);
+                    }
+                } else {
+                    // hashing for solana internals
+                    let hash = hash_intermediate!(lsib, rsib);
+                    mt.nodes.push(hash);
+                }
             }
             prev_level_start = level_start;
             prev_level_len = level_len;
@@ -189,21 +213,21 @@ mod tests {
 
     #[test]
     fn test_tree_from_empty() {
-        let mt = MerkleTree::new::<[u8; 0]>(&[]);
+        let mt = MerkleTree::new::<[u8; 0]>(&[], false);
         assert_eq!(mt.get_root(), None);
     }
 
     #[test]
     fn test_tree_from_one() {
         let input = b"test";
-        let mt = MerkleTree::new(&[input]);
+        let mt = MerkleTree::new(&[input], false);
         let expected = hash_leaf!(input);
         assert_eq!(mt.get_root(), Some(&expected));
     }
 
     #[test]
     fn test_tree_from_many() {
-        let mt = MerkleTree::new(TEST);
+        let mt = MerkleTree::new(TEST, false);
         // This golden hash will need to be updated whenever the contents of `TEST` change in any
         // way, including addition, removal and reordering or any of the tree calculation algo
         // changes
@@ -215,7 +239,7 @@ mod tests {
 
     #[test]
     fn test_path_creation() {
-        let mt = MerkleTree::new(TEST);
+        let mt = MerkleTree::new(TEST, false);
         for (i, _s) in TEST.iter().enumerate() {
             let _path = mt.find_path(i).unwrap();
         }
@@ -223,13 +247,13 @@ mod tests {
 
     #[test]
     fn test_path_creation_bad_index() {
-        let mt = MerkleTree::new(TEST);
+        let mt = MerkleTree::new(TEST, false);
         assert_eq!(mt.find_path(TEST.len()), None);
     }
 
     #[test]
     fn test_path_verify_good() {
-        let mt = MerkleTree::new(TEST);
+        let mt = MerkleTree::new(TEST, false);
         for (i, s) in TEST.iter().enumerate() {
             let hash = hash_leaf!(s);
             let path = mt.find_path(i).unwrap();
@@ -239,7 +263,7 @@ mod tests {
 
     #[test]
     fn test_path_verify_bad() {
-        let mt = MerkleTree::new(TEST);
+        let mt = MerkleTree::new(TEST, false);
         for (i, s) in BAD.iter().enumerate() {
             let hash = hash_leaf!(s);
             let path = mt.find_path(i).unwrap();
diff --git a/multinode-demo/bootstrap-validator.sh b/multinode-demo/bootstrap-validator.sh
index 374a9288f115..65b317eca453 100755
--- a/multinode-demo/bootstrap-validator.sh
+++ b/multinode-demo/bootstrap-validator.sh
@@ -106,12 +106,42 @@ while [[ -n $1 ]]; do
     elif [[ $1 == --skip-require-tower ]]; then
       maybeRequireTower=false
       shift
+    elif [[ $1 == --relayer-url ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --block-engine-url ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --tip-payment-program-pubkey ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --tip-distribution-program-pubkey ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --commission-bps ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --shred-receiver-address ]]; then
+      args+=("$1" "$2")
+      shift 2
     elif [[ $1 = --log-messages-bytes-limit ]]; then
       args+=("$1" "$2")
       shift 2
     elif [[ $1 == --block-production-method ]]; then
       args+=("$1" "$2")
       shift 2
+    elif [[ $1 == --geyser-plugin-config ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --trust-relayer-packets ]]; then
+      args+=("$1")
+      shift
+    elif [[ $1 == --rpc-threads ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --trust-block-engine-packets ]]; then
+      args+=("$1")
+      shift
     else
       echo "Unknown argument: $1"
       $program --help
@@ -147,6 +177,7 @@ args+=(
   --no-incremental-snapshots
   --identity "$identity"
   --vote-account "$vote_account"
+  --merkle-root-upload-authority "$identity"
   --rpc-faucet-address 127.0.0.1:9900
   --no-poh-speed-test
   --no-os-network-limits-test
@@ -156,6 +187,9 @@ args+=(
 )
 default_arg --gossip-port 8001
 default_arg --log -
+default_arg --tip-payment-program-pubkey "DThZmRNNXh7kvTQW9hXeGoWGPKktK8pgVAyoTLjH7UrT"
+default_arg --tip-distribution-program-pubkey "FjrdANjvo76aCYQ4kf9FM1R8aESUcEE6F8V7qyoVUQcM"
+default_arg --commission-bps 0
 
 
 pid=
diff --git a/multinode-demo/validator.sh b/multinode-demo/validator.sh
index 77082f658924..a0271b8c9504 100755
--- a/multinode-demo/validator.sh
+++ b/multinode-demo/validator.sh
@@ -85,6 +85,24 @@ while [[ -n $1 ]]; do
       vote_account=$2
       args+=("$1" "$2")
       shift 2
+    elif [[ $1 == --block-engine-url ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --relayer-url ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 = --merkle-root-upload-authority ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --tip-payment-program-pubkey ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --tip-distribution-program-pubkey ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --commission-bps ]]; then
+      args+=("$1" "$2")
+      shift 2
     elif [[ $1 = --init-complete-file ]]; then
       args+=("$1" "$2")
       shift 2
@@ -182,6 +200,24 @@ while [[ -n $1 ]]; do
     elif [[ $1 == --block-production-method ]]; then
       args+=("$1" "$2")
       shift 2
+    elif [[ $1 == --rpc-pubsub-enable-block-subscription ]]; then
+      args+=("$1")
+      shift
+    elif [[ $1 == --geyser-plugin-config ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --trust-relayer-packets ]]; then
+      args+=("$1")
+      shift
+    elif [[ $1 == --rpc-threads ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --shred-receiver-address ]]; then
+      args+=("$1" "$2")
+      shift 2
+    elif [[ $1 == --trust-block-engine-packets ]]; then
+      args+=("$1")
+      shift
     elif [[ $1 = -h ]]; then
       usage "$@"
     else
@@ -256,6 +292,10 @@ fi
 
 default_arg --identity "$identity"
 default_arg --vote-account "$vote_account"
+default_arg --merkle-root-upload-authority "$identity"
+default_arg --tip-payment-program-pubkey "DThZmRNNXh7kvTQW9hXeGoWGPKktK8pgVAyoTLjH7UrT"
+default_arg --tip-distribution-program-pubkey "FjrdANjvo76aCYQ4kf9FM1R8aESUcEE6F8V7qyoVUQcM"
+default_arg --commission-bps 0
 default_arg --ledger "$ledger_dir"
 default_arg --log -
 default_arg --full-rpc-api
diff --git a/perf/src/sigverify.rs b/perf/src/sigverify.rs
index 6078961d42db..cbad41c51053 100644
--- a/perf/src/sigverify.rs
+++ b/perf/src/sigverify.rs
@@ -110,7 +110,7 @@ pub fn init() {
 /// Returns true if the signatrue on the packet verifies.
 /// Caller must do packet.set_discard(true) if this returns false.
 #[must_use]
-fn verify_packet(packet: &mut Packet, reject_non_vote: bool) -> bool {
+pub fn verify_packet(packet: &mut Packet, reject_non_vote: bool) -> bool {
     // If this packet was already marked as discard, drop it
     if packet.meta().discard() {
         return false;
diff --git a/poh/src/poh_recorder.rs b/poh/src/poh_recorder.rs
index 5bf701aa5dda..23a5a17e73fc 100644
--- a/poh/src/poh_recorder.rs
+++ b/poh/src/poh_recorder.rs
@@ -58,9 +58,14 @@ pub enum PohRecorderError {
     SendError(#[from] SendError<WorkingBankEntry>),
 }
 
-type Result<T> = std::result::Result<T, PohRecorderError>;
+pub type Result<T> = std::result::Result<T, PohRecorderError>;
 
-pub type WorkingBankEntry = (Arc<Bank>, (Entry, u64));
+#[derive(Clone, Debug)]
+pub struct WorkingBankEntry {
+    pub bank: Arc<Bank>,
+    // normal entries have len == 1, bundles have len > 1
+    pub entries_ticks: Vec<(Entry, u64)>,
+}
 
 #[derive(Debug, Clone)]
 pub struct BankStart {
@@ -90,21 +95,19 @@ impl BankStart {
 type RecordResultSender = Sender<Result<Option<usize>>>;
 
 pub struct Record {
-    pub mixin: Hash,
-    pub transactions: Vec<VersionedTransaction>,
+    // non-bundles shall have mixins_txs.len() == 1, bundles shall have mixins_txs.len() > 1
+    pub mixins_txs: Vec<(Hash, Vec<VersionedTransaction>)>,
     pub slot: Slot,
     pub sender: RecordResultSender,
 }
 impl Record {
     pub fn new(
-        mixin: Hash,
-        transactions: Vec<VersionedTransaction>,
+        mixins_txs: Vec<(Hash, Vec<VersionedTransaction>)>,
         slot: Slot,
         sender: RecordResultSender,
     ) -> Self {
         Self {
-            mixin,
-            transactions,
+            mixins_txs,
             slot,
             sender,
         }
@@ -158,16 +161,21 @@ impl TransactionRecorder {
     pub fn record_transactions(
         &self,
         bank_slot: Slot,
-        transactions: Vec<VersionedTransaction>,
+        batches: Vec<Vec<VersionedTransaction>>,
     ) -> RecordTransactionsSummary {
         let mut record_transactions_timings = RecordTransactionsTimings::default();
         let mut starting_transaction_index = None;
 
-        if !transactions.is_empty() {
-            let (hash, hash_us) = measure_us!(hash_transactions(&transactions));
+        if !batches.is_empty() && !batches.iter().any(|b| b.is_empty()) {
+            let (hashes, hash_us) = measure_us!(batches
+                .iter()
+                .map(|b| hash_transactions(b))
+                .collect::<Vec<_>>());
             record_transactions_timings.hash_us = hash_us;
 
-            let (res, poh_record_us) = measure_us!(self.record(bank_slot, hash, transactions));
+            let hashes_transactions: Vec<_> = hashes.into_iter().zip(batches).collect();
+
+            let (res, poh_record_us) = measure_us!(self.record(bank_slot, hashes_transactions));
             record_transactions_timings.poh_record_us = poh_record_us;
 
             match res {
@@ -203,14 +211,13 @@ impl TransactionRecorder {
     pub fn record(
         &self,
         bank_slot: Slot,
-        mixin: Hash,
-        transactions: Vec<VersionedTransaction>,
+        mixins_txs: Vec<(Hash, Vec<VersionedTransaction>)>,
     ) -> Result<Option<usize>> {
         // create a new channel so that there is only 1 sender and when it goes out of scope, the receiver fails
         let (result_sender, result_receiver) = unbounded();
-        let res =
-            self.record_sender
-                .send(Record::new(mixin, transactions, bank_slot, result_sender));
+        let res = self
+            .record_sender
+            .send(Record::new(mixins_txs, bank_slot, result_sender));
         if res.is_err() {
             // If the channel is dropped, then the validator is shutting down so return that we are hitting
             //  the max tick height to stop transaction processing and flush any transactions in the pipeline.
@@ -771,7 +778,10 @@ impl PohRecorder {
 
             for tick in &self.tick_cache[..entry_count] {
                 working_bank.bank.register_tick(&tick.0.hash);
-                send_result = self.sender.send((working_bank.bank.clone(), tick.clone()));
+                send_result = self.sender.send(WorkingBankEntry {
+                    bank: working_bank.bank.clone(),
+                    entries_ticks: vec![tick.clone()],
+                });
                 if send_result.is_err() {
                     break;
                 }
@@ -951,16 +961,23 @@ impl PohRecorder {
     pub fn record(
         &mut self,
         bank_slot: Slot,
-        mixin: Hash,
-        transactions: Vec<VersionedTransaction>,
+        mixins_txs: &[(Hash, Vec<VersionedTransaction>)],
     ) -> Result<Option<usize>> {
         // Entries without transactions are used to track real-time passing in the ledger and
         // cannot be generated by `record()`
-        assert!(!transactions.is_empty(), "No transactions provided");
+        assert!(!mixins_txs.is_empty(), "No transactions provided");
+        assert!(
+            !mixins_txs.iter().any(|(_, txs)| txs.is_empty()),
+            "One of mixins is missing txs"
+        );
 
         let ((), report_metrics_time) = measure!(self.report_metrics(bank_slot), "report_metrics");
         self.report_metrics_us += report_metrics_time.as_us();
 
+        let mixins: Vec<Hash> = mixins_txs.iter().map(|(m, _)| *m).collect();
+        let transactions: Vec<Vec<VersionedTransaction>> =
+            mixins_txs.iter().map(|(_, tx)| tx.clone()).collect();
+
         loop {
             let (flush_cache_res, flush_cache_time) =
                 measure!(self.flush_cache(false), "flush_cache");
@@ -978,23 +995,36 @@ impl PohRecorder {
             let (mut poh_lock, poh_lock_time) = measure!(self.poh.lock().unwrap(), "poh_lock");
             self.record_lock_contention_us += poh_lock_time.as_us();
 
-            let (record_mixin_res, record_mixin_time) =
-                measure!(poh_lock.record(mixin), "record_mixin");
+            let (maybe_entries, record_mixin_time) =
+                measure!(poh_lock.record_bundle(&mixins), "record_mixin");
             self.record_us += record_mixin_time.as_us();
 
             drop(poh_lock);
 
-            if let Some(poh_entry) = record_mixin_res {
-                let num_transactions = transactions.len();
+            if let Some(entries) = maybe_entries {
+                assert_eq!(entries.len(), transactions.len());
+                let num_transactions = transactions.iter().map(|txs| txs.len()).sum();
                 let (send_entry_res, send_entry_time) = measure!(
                     {
-                        let entry = Entry {
-                            num_hashes: poh_entry.num_hashes,
-                            hash: poh_entry.hash,
-                            transactions,
-                        };
+                        let entries_tick_heights: Vec<(Entry, u64)> = entries
+                            .into_iter()
+                            .zip(transactions.into_iter())
+                            .map(|(poh_entry, transactions)| {
+                                (
+                                    Entry {
+                                        num_hashes: poh_entry.num_hashes,
+                                        hash: poh_entry.hash,
+                                        transactions,
+                                    },
+                                    self.tick_height,
+                                )
+                            })
+                            .collect();
                         let bank_clone = working_bank.bank.clone();
-                        self.sender.send((bank_clone, (entry, self.tick_height)))
+                        self.sender.send(WorkingBankEntry {
+                            bank: bank_clone,
+                            entries_ticks: entries_tick_heights,
+                        })
                     },
                     "send_poh_entry",
                 );
@@ -1358,7 +1388,11 @@ mod tests {
         assert_eq!(poh_recorder.tick_height, tick_height_before + 1);
         assert_eq!(poh_recorder.tick_cache.len(), 0);
         let mut num_entries = 0;
-        while let Ok((wbank, (_entry, _tick_height))) = entry_receiver.try_recv() {
+        while let Ok(WorkingBankEntry {
+            bank: wbank,
+            entries_ticks: _,
+        }) = entry_receiver.try_recv()
+        {
             assert_eq!(wbank.slot(), bank1.slot());
             num_entries += 1;
         }
@@ -1445,7 +1479,7 @@ mod tests {
         // We haven't yet reached the minimum tick height for the working bank,
         // so record should fail
         assert_matches!(
-            poh_recorder.record(bank1.slot(), h1, vec![tx.into()]),
+            poh_recorder.record(bank1.slot(), &[(h1, vec![tx.into()])]),
             Err(PohRecorderError::MinHeightNotReached)
         );
         assert!(entry_receiver.try_recv().is_err());
@@ -1484,7 +1518,7 @@ mod tests {
         // However we hand over a bad slot so record fails
         let bad_slot = bank.slot() + 1;
         assert_matches!(
-            poh_recorder.record(bad_slot, h1, vec![tx.into()]),
+            poh_recorder.record(bad_slot, &[(h1, vec![tx.into()])]),
             Err(PohRecorderError::MaxHeightReached)
         );
     }
@@ -1527,18 +1561,26 @@ mod tests {
         let tx = test_tx();
         let h1 = hash(b"hello world!");
         assert!(poh_recorder
-            .record(bank1.slot(), h1, vec![tx.into()])
+            .record(bank1.slot(), &[(h1, vec![tx.into()])])
             .is_ok());
         assert_eq!(poh_recorder.tick_cache.len(), 0);
 
         //tick in the cache + entry
         for _ in 0..min_tick_height {
-            let (_bank, (e, _tick_height)) = entry_receiver.recv().unwrap();
-            assert!(e.is_tick());
+            let WorkingBankEntry {
+                bank: _,
+                entries_ticks,
+            } = entry_receiver.recv().unwrap();
+            assert_eq!(entries_ticks.len(), 1);
+            assert!(entries_ticks[0].0.is_tick());
         }
 
-        let (_bank, (e, _tick_height)) = entry_receiver.recv().unwrap();
-        assert!(!e.is_tick());
+        let WorkingBankEntry {
+            bank: _,
+            entries_ticks,
+        } = entry_receiver.recv().unwrap();
+        assert_eq!(entries_ticks.len(), 1);
+        assert!(!entries_ticks[0].0.is_tick());
     }
 
     #[test]
@@ -1569,11 +1611,15 @@ mod tests {
         let tx = test_tx();
         let h1 = hash(b"hello world!");
         assert!(poh_recorder
-            .record(bank.slot(), h1, vec![tx.into()])
+            .record(bank.slot(), &[(h1, vec![tx.into()])])
             .is_err());
         for _ in 0..num_ticks_to_max {
-            let (_bank, (entry, _tick_height)) = entry_receiver.recv().unwrap();
-            assert!(entry.is_tick());
+            let WorkingBankEntry {
+                bank: _,
+                entries_ticks,
+            } = entry_receiver.recv().unwrap();
+            assert_eq!(entries_ticks.len(), 1);
+            assert!(entries_ticks[0].0.is_tick());
         }
     }
 
@@ -1613,7 +1659,7 @@ mod tests {
         let tx1 = test_tx();
         let h1 = hash(b"hello world!");
         let record_result = poh_recorder
-            .record(bank.slot(), h1, vec![tx0.into(), tx1.into()])
+            .record(bank.slot(), &[(h1, vec![tx0.into(), tx1.into()])])
             .unwrap()
             .unwrap();
         assert_eq!(record_result, 0);
@@ -1630,7 +1676,7 @@ mod tests {
         let tx = test_tx();
         let h2 = hash(b"foobar");
         let record_result = poh_recorder
-            .record(bank.slot(), h2, vec![tx.into()])
+            .record(bank.slot(), &[(h2, vec![tx.into()])])
             .unwrap()
             .unwrap();
         assert_eq!(record_result, 2);
@@ -1869,7 +1915,7 @@ mod tests {
         let tx = test_tx();
         let h1 = hash(b"hello world!");
         assert!(poh_recorder
-            .record(bank.slot(), h1, vec![tx.into()])
+            .record(bank.slot(), &[(h1, vec![tx.into()])])
             .is_err());
         assert!(poh_recorder.working_bank.is_none());
 
diff --git a/poh/src/poh_service.rs b/poh/src/poh_service.rs
index 04dc8d4c5a1f..e5b40d6577d9 100644
--- a/poh/src/poh_service.rs
+++ b/poh/src/poh_service.rs
@@ -192,11 +192,12 @@ impl PohService {
         if let Ok(record) = record {
             if record
                 .sender
-                .send(poh_recorder.write().unwrap().record(
-                    record.slot,
-                    record.mixin,
-                    record.transactions,
-                ))
+                .send(
+                    poh_recorder
+                        .write()
+                        .unwrap()
+                        .record(record.slot, &record.mixins_txs),
+                )
                 .is_err()
             {
                 panic!("Error returning mixin hash");
@@ -255,11 +256,7 @@ impl PohService {
                 timing.total_lock_time_ns += lock_time.as_ns();
                 let mut record_time = Measure::start("record");
                 loop {
-                    let res = poh_recorder_l.record(
-                        record.slot,
-                        record.mixin,
-                        std::mem::take(&mut record.transactions),
-                    );
+                    let res = poh_recorder_l.record(record.slot, &record.mixins_txs);
                     // what do we do on failure here? Ignore for now.
                     let (_send_res, send_record_result_time) =
                         measure!(record.sender.send(res), "send_record_result");
@@ -381,6 +378,7 @@ impl PohService {
 mod tests {
     use {
         super::*,
+        crate::poh_recorder::WorkingBankEntry,
         rand::{thread_rng, Rng},
         solana_ledger::{
             blockstore::Blockstore,
@@ -456,11 +454,10 @@ mod tests {
                     loop {
                         // send some data
                         let mut time = Measure::start("record");
-                        let _ =
-                            poh_recorder
-                                .write()
-                                .unwrap()
-                                .record(bank_slot, h1, vec![tx.clone()]);
+                        let _ = poh_recorder
+                            .write()
+                            .unwrap()
+                            .record(bank_slot, &[(h1, vec![tx.clone()])]);
                         time.stop();
                         total_us += time.as_us();
                         total_times += 1;
@@ -505,7 +502,12 @@ mod tests {
 
         let time = Instant::now();
         while run_time != 0 || need_tick || need_entry || need_partial {
-            let (_bank, (entry, _tick_height)) = entry_receiver.recv().unwrap();
+            let WorkingBankEntry {
+                bank: _,
+                mut entries_ticks,
+            } = entry_receiver.recv().unwrap();
+            assert_eq!(entries_ticks.len(), 1);
+            let entry = entries_ticks.pop().unwrap().0;
 
             if entry.is_tick() {
                 num_ticks += 1;
diff --git a/program-runtime/src/timings.rs b/program-runtime/src/timings.rs
index 9ffc47021786..3a0b3145d860 100644
--- a/program-runtime/src/timings.rs
+++ b/program-runtime/src/timings.rs
@@ -8,7 +8,7 @@ use {
     },
 };
 
-#[derive(Default, Debug, PartialEq, Eq)]
+#[derive(Clone, Default, Debug, PartialEq, Eq)]
 pub struct ProgramTiming {
     pub accumulated_us: u64,
     pub accumulated_units: u64,
@@ -56,6 +56,7 @@ pub enum ExecuteTimingType {
     CheckBlockLimitsUs,
 }
 
+#[derive(Clone)]
 pub struct Metrics([u64; ExecuteTimingType::CARDINALITY]);
 
 impl Index<ExecuteTimingType> for Metrics {
@@ -298,7 +299,7 @@ eager_macro_rules! { $eager_1
     }
 }
 
-#[derive(Debug, Default)]
+#[derive(Clone, Debug, Default)]
 pub struct ExecuteTimings {
     pub metrics: Metrics,
     pub details: ExecuteDetailsTimings,
@@ -322,9 +323,21 @@ impl ExecuteTimings {
             None => debug_assert!(idx < ExecuteTimingType::CARDINALITY, "Index out of bounds"),
         }
     }
+
+    pub fn accumulate_execute_units_and_time(&self) -> (u64, u64) {
+        self.details
+            .per_program_timings
+            .values()
+            .fold((0, 0), |(units, times), program_timings| {
+                (
+                    units.saturating_add(program_timings.accumulated_units),
+                    times.saturating_add(program_timings.accumulated_us),
+                )
+            })
+    }
 }
 
-#[derive(Default, Debug)]
+#[derive(Clone, Default, Debug)]
 pub struct ExecuteProcessInstructionTimings {
     pub total_us: u64,
     pub verify_caller_us: u64,
@@ -344,7 +357,7 @@ impl ExecuteProcessInstructionTimings {
     }
 }
 
-#[derive(Default, Debug)]
+#[derive(Clone, Default, Debug)]
 pub struct ExecuteAccessoryTimings {
     pub feature_set_clone_us: u64,
     pub get_executors_us: u64,
@@ -364,7 +377,7 @@ impl ExecuteAccessoryTimings {
     }
 }
 
-#[derive(Default, Debug, PartialEq, Eq)]
+#[derive(Clone, Default, Debug, PartialEq, Eq)]
 pub struct ExecuteDetailsTimings {
     pub serialize_us: u64,
     pub create_vm_us: u64,
diff --git a/program-test/src/programs.rs b/program-test/src/programs.rs
index e839b2c09009..95fa3d55d0e1 100644
--- a/program-test/src/programs.rs
+++ b/program-test/src/programs.rs
@@ -12,6 +12,14 @@ mod spl_memo_1_0 {
 mod spl_memo_3_0 {
     solana_sdk::declare_id!("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
 }
+
+mod jito_tip_payment {
+    solana_sdk::declare_id!("T1pyyaTNZsKv2WcRAB8oVnk93mLJw2XzjtVYqCsaHqt");
+}
+mod jito_tip_distribution {
+    solana_sdk::declare_id!("4R3gSG8BpU4t19KYj8CfnbtRpnT8gtk4dvTHxVRwc2r7");
+}
+
 static SPL_PROGRAMS: &[(Pubkey, Pubkey, &[u8])] = &[
     (
         solana_inline_spl::token::ID,
@@ -38,6 +46,16 @@ static SPL_PROGRAMS: &[(Pubkey, Pubkey, &[u8])] = &[
         solana_sdk::bpf_loader::ID,
         include_bytes!("programs/spl_associated_token_account-1.1.1.so"),
     ),
+    (
+        jito_tip_distribution::ID,
+        solana_sdk::bpf_loader::ID,
+        include_bytes!("programs/jito_tip_distribution-0.1.4.so"),
+    ),
+    (
+        jito_tip_payment::ID,
+        solana_sdk::bpf_loader::ID,
+        include_bytes!("programs/jito_tip_payment-0.1.4.so"),
+    ),
 ];
 
 /// Returns a tuple `(Pubkey, Account)` for a BPF program, where the key is the
diff --git a/program-test/src/programs/jito_tip_distribution-0.1.4.so b/program-test/src/programs/jito_tip_distribution-0.1.4.so
new file mode 100644
index 0000000000000000000000000000000000000000..29fc1a0eb5b8c419b67d124872c814948cd4460b
GIT binary patch
literal 423080
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
Y{jy(AYCQMNrF?PS;=*R3-G}D#Km6G%fB*mh

literal 0
HcmV?d00001

diff --git a/program-test/src/programs/jito_tip_payment-0.1.4.so b/program-test/src/programs/jito_tip_payment-0.1.4.so
new file mode 100644
index 0000000000000000000000000000000000000000..49e574ea8cf71011124b4b139bb5f055ed85ecb4
GIT binary patch
literal 430592
zcmeFadwiT#oj-mi$uwzE8wx|qtk|L=7>!%j8^%Q|DqwWAsF7Ml8bX&gMeTG->63%n
z($Y&%C>No|UF{^jq+V8by-;1<psTw@S1rmax}xCXihR9Pyj4N+d%ZvJ&*yp0JTsF_
z+764qHUCVWnddprIiLIOe9pUG{;IQ^G8t!o&F*&&S8G@By9N5gx@)J|EpCB3!?m~t
zZibsK_hy}Q^K^)c&+p+^=j_w9a~Rx?5f|Le-_xHf&*pvh89vwIoLl)+&L{o3ub<D^
zr#;uC@4MwGd@lWY8y|~5+w^+uY5d3M&ltylzWZE$b}f+4u~Gis+UDH3<KyE|FRyc%
zlU%cN?$(Txwfg)vx&PKy9dBSe#~IkdarWvs)1BKlK0ZD+tk+G>ZNc?*yq?qS+@dEW
zxVWm_x#K?S+*nEP&p5XL_g~Lz{QfVuI+t@#k}t+a^uA{24vmkG&&fFV@b`%W{N38*
z-1D7tb6T9+61-<l*16H(8sqNxkdx2x@$vCTW1YYK$i(X`$vS7rI<oGEgm(=8QHA#{
z`nh9LxbK(*?)PCn>j}>g-rLINaYw`F@y#0Zc$duM848cvWFAq8^yc#m^_q0)^NaLa
z=`z1WuL&ogU#8az$NWmYR(R&u%5_MGV<|db2s&wYZoVVkyy!FK_{8ra-GdKsKj;zk
zcE)F%EA%du^+bEfk3E?gyuN6WeCC?Kb<Rb-OXL&JL)PH=)~lV1E?SwoZ*9eWO;?j|
z@mD;7?;BIT27jIBoXfhW%kPgRcpg7Rcs@bkc`nyc0Z*<wfhXY`!t?Gyz;l^ApWH|I
zhWFhy7{Zh93*q?+=Uj+)qZ7mX??3I_SV3On#xCL~#^0fM{mrMHdoRCszIz?%@CAB*
zEWb&g5vS{NZE5*Tx`w>KpU)dztDM-w?^|0d<+I2MonJNid?EN#<##l!^DA;Z(B-aM
z8Y7>7y0@BqZrnQ0nq-|@WSz5R;U=G>SiVp$MX`LLT#91(Lb-HKn-g80Ys<=KbP+Xm
zLVq+cLi*dH^as@X6A1U1Z%^R!k;%am_<Uq?@Ps)!Up_e1`9{5`$@AxAblw@8H>98o
z=6!}-hx0C!&70#S^XBu(y!m`GZ(43qN#$}CzPTpgn=y(rH)im;nd^?}y2-g6YOCQ7
z^PH#rH}f;j^@vrL&^hRO*3F>ntL6S`<MsbAuseeBvY)|o7~Q#$@0LJ6D4)Sj89Rpb
z{plN=i>~8*qgnj)9d|u~=c8G~r|&qR*TlE)*w5=@<u%UdZ<A}-L(@Jq{q^|v>V@a@
z`}{re_jg|O`?>gj>qusy&)*+^|Lmu|=5~Dl;r~3<`TW87`+0lsI1ArD`<$~L^7%vZ
zeQ1B(_Q?3S$-%KzxRdKydJXi;C2}3=Q(1pt*S+Ls=Xy)j)45DWC^YN1plHPOv+8Y{
zMJ_s4*Pq`f^YI<G$Y-=&`9SR%=sEBU;EYd<k3U@FFH(W)32xWZ)E?_u*n_}7K6{5R
zrkyaN^Vq5L+C{qbi}kac-}^4!*Vn=4`qT~y^@G4c^)cSlA@F($=XIm<FE1xuhhMy%
zaOfK4XZH?%9?y05G-YI6S$ChTqi|h^{NVFz<-WpoWE`Jgr`P0DpWh<a(RHL_pWnu7
z<Ey}4m-Php{w<FXex<F>MSB&$(=)<hS$B%OKlB&QNZC!xaIN|VeDzeNt9Izoz>a~$
zFnS8_JLc04azo}@JmIeh*AmxPJmGY`=K6|>9FqIJ$|=8w>yAnaPnDy7Q!HQge$pNE
zF8sP!J`WQg(aG{U!6WF&D;;OWyGqsry8NQbgXiCn*aIP)0Vkj5dqa2wUg7%x-@bCW
zBYYa*=iQ+kYIbh5!uLKr7r+-Qi-!5WaQq*n?t3QIq5L0?_uYNY`J1@@kS_%e#&;Rx
zTYiFX`8%(BGJtC0rvOgC4Bmq~z&|@dXNo726Yx7_9EE>R(^tvIDnFCo^*v3u%kLN;
z91xDbeJkYIm*n@cQ@Ng4&#dJ_%#WH#&z$w?K+mWi!2Dl+6ZFNUGH|u=YU!CXJ{{<p
zz>l8?{Hh$pdQ8v!^m^x_0_Pj(8HG!%XUgE@JNENB(KB*gMbE_Fr}RwxeM-;7->3A9
zd|#$#upXt$u`3CGz-{|`fETsL19>Ft5A@OMo1kar$+(H0c>>`*e42b86-WnBj^npx
zRew0uA6eBO{Mkh#^Z6W@2Ym8mKJVdNIpDdLK6xsi8`1af)Nyucd}gu5Y52YG;(dJ`
ze6BCgb%gvZ>kahD5`hclY;>8*E4o7t;TzG5ZMrVGat_z{^J>!cw3*)cvCQ|BrmQ>*
zIfq-}C+t7AJdShfEs4Dztx`H$NjX|rOTAKvsBa3FQx6r_P(BxLqFgR+qFv~xsUCWo
z>Yq1oJhN~8*_?2N+~qKd9665bnn>Pmy*`k)M_@<(+rEImReym_Z-4LM*^!^!7w~uB
zztyrMSAxGQ>`2l}Vn@y){l#`<JFjE@Zj<Xu{w5vb`*Qv!o#Oj){w5vc`*Qx)xML8<
zYYX{1;M*q(9ZzmY9(wPQ*palGeFyEyKV>`e-giSD9<Cj!c1{=VY2U5(<fL|_*^OpL
z(yl7RcBI;ku^mZ!q8>YPpW2br*Vbo83LOP@PTGz{1PJ{2@3)rQIcYo6?)$>6uq(`N
zG&|DlMzbTizQm3+yHMp<Y)2|QE9^+KFKfuNVfAkg!;bv<b%9(9^dsQp^L%d_Ua)&?
z{lkD$Ab0k|-wWU?dfEKhX5>`}-}k5Bi<L#gd|x>JO{x13@ihJq$Gh&<N5_tQ(-z=c
z?RK@(6FZT5<Vftu*K9dDcI5AG4fIT4M?QQb^u@bmqEoRWe<5*p>e<ka6g^YLjvTqJ
znjOhFL!xIaenGm9;}@}>Vf>;}&m?h)ay^s8CCc>-;}Vs6#)%#a^^DMO6+7}ZA~)Y8
za0~fF)*tAjXH?ZQB$TM6{(oNiwPxHRrEem_CsKQ1(zu1jUHyqhkG1T~#>Xv=6SzG`
z=}qm-I^!>Kyn<$35U2Pb!CRqVaSGKhg_M3NsC+g3Qcye5^o#mAv78I!Upii4dgg1F
zI~VQIctxwlD+uT#)dS|A`V(}Xo7A4Y$>Is7ACA5r=&Yd!zz;sp_l9!a;tAVTp5Oba
za(zj8&gUSf?Y{4Q$~nJ=bQ#jK_~Ayc=I>v}b;kbwiM)>eeT)B8@%MLcb`!)CzDs+y
zW<23rlna4e10`V{m;vmAq0Nxf%zGY*Kk%|pP6z(LIU=X09#`%P<#eEzYxx5|-&V~Z
zFu5H2`;6<wa{93wS01_=c$wTESaai%_yhm{i7Q_y@H$+7K<(JaU|ji%P4)Q$^~RN7
zo|12Af576;3qJLy9ap||TXlb+-njBSz$uVB^~RM?Ou?7>qcX01eCobhapjrNGmk=C
z`8%Mq2F8`Yx+(Anjv(%I`KJPZAkZ@dHymEv>8+odTHNX6s(R*6H}3S+!TR*f-W!fY
z&!qf-KjHl4^#ZTM)iaOXxYLr$>eDmz#+}xFvfPeN>lur?6hHZ=9e4WRwbk`Zy>X}4
z0ZxIQsW<NQsuX;wXDZ`P=cMkd6?Z!8laG#`d7S8(#>Jgnpl2-p0zYTn&HztZXEvsB
zFXUB_C-UkS;2MA4{06-*#FNzhYCNi19obEL68aD0D%V~M{lynp9b6c<Inp}cr|e4d
zQkJ(J(|8`>un6@x=9g-|2=&F1Cu`9>Su^K{Yy3r8N8&Z#)YH-=_hUTxyY?A1tAEch
ziEGvIZq@u^u0_YyyqkY1$M4Bn{_QvPXInI%mSy~)(8~Bnp^b(^!D&8intpEL_r*0D
zCwYU$9nRLc!}HYt(|Chd{KxRuI;s#(_aQ#|XE@1U3@76omIcQ36TtsJ?FC&ku3>RU
zeE)Izo_NpN@5(n;=Z5=!_%YZa$k<lakK*@R<agE!S9|_*|CsQ%&ohrdwwv>Bo#xzu
zAn%6wht)NYe4@Orc|Ypxo1D8XsGlF}<2abd)Al6qF}jH^;ku(`q_dOOGLbZw<;w2)
zZG7LU`iZ(!+?lmHMTJN0I6UEEaf>8Q&-eCd9d)&Oj<;Op<b7B#_B{X&J#9Lk)*0rS
zG_KoAemS*?^9|!fJy&7Aj~75h1=cOpp6`#y$0|=N=X<aGUM=2ruDs`N`8}pPt8?sC
zIIBEP#wC7wrT`~Mh;V%`xC(XXD!-1x_~|%X=T!;a*!XcBtk(HqKHwD4*{Q+(m2d!s
zqF$2gKALctBXF2^)W%Q4;c+s4<M8MjjK^PZ1f9T|Z4CVHm+`e8_$c5v4gc@S_$;hH
z8sn$==zxsReFaBj{Pg_4DB~jv-x&Dslku@z;pmK?p8rQ={QXC5{51S`$oL12+W6`D
z-zeiBI%?ym=f6e9r@_z&`nf{JKTQmhqcMJZ{wrnt`A2R1H2g1?@fRJn@ze8PB;zkR
zYU8Kp|0)@O%TXIYJ^uwV{<fnwetQ1Tk@5E(wei#QKTXEJ?Wm2Pp8peN{QHmE`04q#
z%lHS6+W6`Dw`@%8sKhR8+<Jby0s6ji>v=%NZ=5~!eHp)TcI`K0{KnZs|0d%%&K~-V
zjNdqW=pSVK#@R!|GJfOip_^p<#@R!IGJfOip?AvojkAYV$@q=4hyGT^Z=5}}SjKOh
zJ@jfBzj5}^Su%d(?4jq$_>HrNI%NFD*+Wl~@f&9k&64pOXAe!2@f&9k{o%@L_QbhI
zE&h?VkA8Y3?1_a(ZTz%-bdQYRID6tw8NYG%#C{pSarVS#W&Fn36Sv6tjk70q%J_}5
zC$`J@jk71-E#o)No>(X2H_o0|E#o)No>(U1H_o1Tvy9(3dt#xC-#B~XWio!_?1?jE
z{KnZ6&y?{SXHU$N@f&AP953TH&YozK@f&APJiH$Iw{iBwK^ebs@re6m{Kmy2?vn8v
zmtXo18NYG)rQ6n5vF9#=6^8yTENHMkFUWH~S@VDhSRwDW5A(Z-_D7tbQ+pxI&wV_2
zPp{@_a!nc8X>IvB%YWvY{>Xgjv9z1QaXz#jdDY*`?@2tXarV#O3H%#p|7?@-8)tuR
zl<^y9f36Mi`e@*zzrpx;i;TamVfmWZ%J@gmUQGKlXUq7Fqo*zzzj5^Rtg7_XIR9Xt
ztfz7Q!SM~oM_YsO@$kCF=I;;6_>GgV_pPg<-x|mt-;(t-jz7NKV0`>bgYofCGJfOu
zdAE$;IDQ_I@sFPTPRF~hk?|Yn?_Vk7H_qQ*BjY#D-|v5v`T5PVp2qR>LK(kt_Up@J
z{Km=GGi3b6@$)lf{KoO~JQ=@n{CvEO-#C753-}?@dhOgaY4I4>>qN(qesj&FgScKl
z&pumLf1H)B<>+6<dR5f9qh1|#r}!I-^i%sJ<eIzW3*V)ExnPXS^BlLQdAeNR%8%HO
z^IiPi`bx!q=CSOsZuOb=dr#BD;_oe=HB0IwI<MFMTw3Rvn}%+>?B9qHa&2;()XT2R
zIJf-7cKIT#U%mHTtnbAS%P-=%wyw_W`Fz&>ihic`g}7N>BlW?!!~C6G+vDViOIn>&
zT-!d0nb!A?<-;y|ny#;na7CY2{6&A8{@&itb>}j9x$o5J&Y|LXrtafQ{AKp1!+v>K
z{?+PZ|Mgw)o4+XQiT!kYulB?1QNP>fYxU*USJ>bX!f_wq*vj>cZIWraTpQyCQm+hr
zwEj-si)-K`tNRwr?~m_G;Vpd6hu`I-kH_X81btPToOA%kev<7o%lnP(_&~6)L*osR
z)_><RFC*Na!udu|Q~sF74I8$PBddL1b4@Rj8&MZ8{J^q$mz(yN^1bzA?rEXlWpr!%
zLyZ1&%^FWRcBLRV<}c-so@S%-e)+xgN;X9C-Q+LB$MQML<o6Ihn}LVvtcPB{iqBi!
zf9I8iO*ETv)Lbk3zX5)jNp3p#k>L7(;794+>g;zae_MU6^@p3zx^tBC10=Q|WTy2`
zAUIsS-swvB)7fXC^80THon(#fo3-D03SK?Uj1S$aD39fqt}lek#ej?A&DN8{MjMqE
zvi@mYU$Xw+$~;2)B%H{Xc3=3O^QTCkuL|fB<KfTxQHJlW_PzZMSun7q_1n1Tj%S?y
z1N+|OQo-u{Gsnm{(aCJIVSPrTla;=-?^JX$3DNrKMJIE;wht)XPcQ2@Zn)1Y-EZPs
zt>nWUTax`Rw!aH}+xDY?pIflEnD<}w>+$i&@_IJaSkGnmRbS7!kMZ?fT4Oz*sIi`B
zJ;vAb+8XQmV2$-0{}^A-88z1Ps~YS1!>=CO{PUz5>$$zgdhU6QucxKPdfuK|4^$TN
zCja&rU(W-ZtIO-}r`BWg`Xi6=^&F_Np1~UHxjtA=xGx%(llA#E{bavSWgq20>RhAA
z_EG-vgFzhgd7{o;>~HD*(kRk6h1zX%)lWFHmpaMpAM1-A?$g}S?1JZMxS5|}eU-!e
zFZ!r+GnaE7{${>64VQF3Y<vGD==<uNyIenE|EzP)b<Uz+XZBEE2kl|GZo}`iN3ue7
z$-dX~GtRx(IXQ;{;}r9>4=-=!Ib7$o^6abPfR5M7^D45k%M<xag`4_$7tGRqvw97F
z{Tsk1zE9z!_Ek~g4L=Gq^y*J!-E##%6RjIhbk5?&^7C7D9j$~%abR5RP_w%)Z{m8+
zZ_@h|ZpDsAD(-_vT6v$sCF7(sA>anr6z6vw6u2eufrXrvQCyXIRevAma}UN*yx~2N
zceU^XJOI+R57^*8SN(@G3re@<e`|m5@O+t9057_a*y8%;e}sMO9>#v=;9Qy+pkLi@
zY<>GH=r_e@wvYQr`0UwJ<g?#=WO6?9T|Cbxp5G}-&rc<tT7Oud-zRhut>X8&rk4wS
zdOa`9<c9CCbF=KcEcSKx-RuYN7qbt%?N5(N{5_YUpM1$Q#p^KlmCw|D({VpP9WQz^
z;~wx6;a6LqBlwA!q4k$v{uGVRFwEmlZDkz959xVbUF<KPb@X4%KSf;P{_*i~j0ayS
z8sUApOpEX-=n??QW#|`K{37ePAKUPsYyEG+?K;AB>~)lTo##;=jcH$qu{ZGhxwilM
zdct{3&+C93dHF}-<LGnhznZ**KZ##@rtx=N;}3op;1liCe*C)#|F>SmbKu6b&qUU7
zebHX+%U>eCv0nVyJfdNKZ|}pr-t`XWW^R?+;&X|LCmt^o$vQb2CW&LT{6XN6mD3TO
z8)Nv_MSFOjl)XRK!ni`ubncTMLlYa^uje0PU7!H0ACSU4E`3MRud3SbUmfCo0uMbu
zso2hW`gMGdU!wG{>-X)%1IELGR<x6z4DO!gF3!*9a~=c)`qT3qOwZ$ac)XpbQ%{9`
zLqTU@e}=CN0gj9-#OKNFX52H{!*dU+t?yOu0G*PqdsO~r-S-9FV?6fFVOm1ZdY;r6
zm+fY9+OD&Y1n3v(dd}q!F+B8sJLe7akoEHR*gxN+alz%+DgWvD2QwKya()KsZN<U_
zp3pm;uVsIcF+J}9a0cAq?=MTm>CW1j;B$=a8<Y4d!~XGlXX-rXYJUmeMY(foGvQ(S
z0d!RO2;fgX@pFtGRDS9CA!&G+T?9Q2ii+b|s^3kHMI(GK-g7bDqjDu0RynM8*G$!0
z#gj>&);DIw3ka`hSo!5-&d>V$S|6RP({tMTd2W!!-!0B(_T5S6F~E#I$7kOY#2@s$
z62N_73hocTKY+Wg@6?RKQTx%%)c)><2R}p4P28jXLfH1)jj0|5+X&oLe;d9EabIVi
z4;Q^e>C(<cdx`R!=>?US@wtl%Pn+LNi|6hp{h57W@o$sQMi+iD`3d+s2Ktogp0ej;
z-fCYM|Ka|u&=J?YVz%N<`#0OUQAW20N1KP8Q)O^M{Tx`&;&U^#Kg{w-`HN}5SbueH
zC&63XH>T(K95<zB&HKdktokRb{fTW|_I|Tljo#-f9(@PlG^TNJgI_4uriFY}=R7Rl
zSHV|GCkCgPI*$<khdvDc(sQ+j$#(|lnX31q5%Nj#bmcRRgRi(*@ioHp_i|0wi5!jP
zo!LV>RbMLIMSE0_jw-$G<vCut%&$dGj={-*URGA~i>Xh?F5~yUOYM>ll?U37GV91t
zwvXN`y{)*O`6;6tn}6p`)U&p3TZh>Jxu(l$m)N{@zBWHwN3D6;x@>;A%w4holQ(`b
z;coh6`PrQ3@~woc=|exLbg1&7^SUM>+==w#kKY&SM}_|$)sK6rAD3@R-h;eRXeV59
zMY)}j{(b-Z68Yu_c>ZgQchhrv-dwEb)+-;XKRr|Rf2`+L>U^3U_1r2Na7K?4>A9sN
z!F-0OmkiIb94{EZpG|$Q^pTdU(FmV6`ZqoWe?gLtp(!o$geu1yCVxxh6Qf)6uWUY$
zpBH>Mk+<Rfp}e){aR2$>_hGejRe!J0ystgKe2(Ht<p<sm$i;ZMl8kBB(0}Vv`tR8R
zKB8g5bFRwclTI)^<j7xYN7{Q#Zd@|m{2b1ArqWZiSM^emFNU29{NU64Bcq!zuJZg3
zC+EqUTrxlF%=JtZnfyKz2Uo+d88vv3&T|>|of=a;7w2hIZ(h=*`8xH7XIdWA^nk8o
z#VpO6Yh0sq&MzoGHD8r=KO>z6co6!NlObKKZz}ZNRf<0xj*C89Dz7`=XmHnlTXtS*
ztY_37iuE1sqD0>@Pi}l&q3_gho2z~Fd>8R<^lEx;?0n7(^mrQRaf<VZ`8I7wTHbzy
z@-ESLoCn^Q|FDbYwc$S+ru|`Xo~iQQ?8>pt3ddH`m%$(J2dd03MIIE_XI@1AC8h(j
zZ#AAZb_2(|q*>`i>lkdlX*k+_78k%eGJu=<skRO~H_hxh!~x;r&b0WYos*&0D;AMX
z&RjlM=<JdfosZd<3J35dc2H&A@p7N<(sRH&XfHtSr}e`JebQGl>z*&qMZ+5Rn5S_G
zl4I;In%*$J@X80#FykcVFPNN&cI)}#YLEG8<$l-&vk3U*8Lsn`%o>LizsGc3lNT0W
zi2aB8%0FtKpW32!rP?Di8P;*pPKCqE>F`B62@n5rwZGrX`HV3<5Zn93jkKdIt`Or%
z<%d^#Sn+(y2XFN)S|?}gH@?lf*>aA6*~y?&fY$iU_|))<=S7ZeARU_hF;nY{#%@%4
z*M6Cu%k`Xe<I~vRQ+W~ldnzx~|F!kSep-g>&T79*qkEfQ%pWQr=W1Nbcc{Ei+s&%K
zeRsm&ANWupPwJef$@jD!5c{PXf3f$OKMFqFChw#CDB8MJ?i=6Q`1X8Ecj~{!_*eO0
za=_kW;{b1<EWCF;-n*0Qj`65+#>O+h$mlBO|5@a}6)z>7LqCYzy7@$*qga2c{crfg
z`ymHn`&#wcid8B5TIsJdvN+ZgWL)^qC#3vm^nrx^FfV0493RA?@Z6H{{AfLw1kat3
zdhYSTa~5B;JdW9&kUQXy+_afO=u4+HNxTbiee?FjjvUkc%O0((xqLeF0){uEQ<2Bs
zxiOVz@i{6MS66z*eJF**C*o^<HsyoYxQx+9Xs?|7A?N%hlqVJ^Ge0(+|H-u}pQ`_#
z%P=qyoyGU`G%<dgYbBu?z1Vv(ulolOKjr%@4`gyWkvH0RQ}shke|jD##`$j<hl0!U
z961mg<dV{9_}=fx{RE)Z8(H4Kui^X+Zx$D|Iy&>m{2G<Jst1yJQ=Y}}(`)b{-e}`u
zza0MTImEB=O;3gfzvWMij!=(?-#ZaF!MfC+Ii)ot@)h$FIjizukJfu$-b^~mW$547
zIrLV~X7y-RKk7T^ukrNvWPU!cbz{N#O43($r%Xrs9ZTFaI7bV8q9cuKm|brDTJ8KG
zv;PcU(J<vN_>C)-zjY`5)kC7!dzz?Ff%jkEoX|I}n*(|`xTpOmgMa5)9DU00M}iIT
zKZg^0EW>|GgW><h6#Ty#Tt`n)IiPiakfWc|bFc5(0Q-)=TivApD_&b2r^PK{7eH=%
z^+Qb00N=+ynAF8g^u8}2rT6`Fo$veXQF`A%P`6<8Y;~_`xgWy!Bl3PaWYD7`|Fs{n
z9?Kis?f6~btM*`cE?{`RG~j&?>fhB5PRmu~pOAXNeLs}G*Q}#1T+cq`xhCBgq340s
z+kZXjyFN$c0mjFA?6cN<0gv01-lWe~d`_JD*9Dc|dD=C0F0|Es#Q9T=V~29@9(_Od
zSB3rSYn@-c;GLj%IzrJ6eDC4+iT?rpn;X>+crO!Pg>5vb3){6H{L^SK6*tkaDoz8I
zo%3(teg14d=by)MOy7q353YpyJ0_pa&H#Kre+<_3k1`+AM@FZxqr&sdjc-Fb`Fo)g
zt<O+B4ZQy19k2`dJ>+w>c^JOxrK3poQbJEP`uG=*6hGR>f3@Q0GR4nI#m`#p;~#1N
z{-G{`UvcmS{G4IugX_8A-8_%kck!GZpXa&GUe9w5>2eYBmchBL?MkQjZo>IBj3@PE
zPL|H=(O&vbk@^#6XNUU@gkHK9%DjC3Tz+=wxz2$dut599ANU`2T46T?=j?s&3g^Zs
z-d(PZ`DgPFVfO&j7SDp6^a%E;G}BM$d<p|CxeWJlTYMxcXk5wiM+Mf`yvOl5_*arw
zF6w=%Uvf=!M6-H+YVYuyWnIyT=EHU>Tz2U>pBgv!-Rf_4@xHzeKG&BgTtm1E9@HKO
zJ%9Ke;FDbfPqUA(PH<!zjv;@1GJso8+v1Anan$=n&wsS+`Pa(xQGtorYW5uP7_I~7
zafEmrDI4$HiuoXQSZzMAm;i_Omp#w@OCdb4C26APZzy}7`XqdQV3OyrE_<HxFnr!m
z^8ALf=gH6E^H)sryf1s6av^;F9g{p?EPG!4DwS)Xr*}^B{ED*YDd)oHaiZ`<@b4>o
zUhOxnZ%aRC<AQz+|8EMO&$XRI`qB8`<Z^)X&1L9EN9$AkzrLLRqYeB$mIE>WQ?J<h
zwb8RVF6eVk<YKu5{RRk!^nW~l59A*B9QS=z?TmMzf6pF`+sEh1K9PK<@nYCpfQOxv
z8kH!|O^yMNVz1eLk0UtO;SrptUb6GqWExe*KaTRR=6Mw}<#((T6d%Il!L^WU$H?y{
z@31~lMkq(Hj|9&lg#kDpKU)3#*hdR4|5X=U9xOXAHNgw%zNhKu@_RM7d|lx3fc$<q
zcG18n;@OpU(SKa=f50xfT<xNPvxKgSgD>Id4B8!jvD!!7Y9Do}eUw-GsDu0z@@e`U
z=s9M;UzMEe*OTd{T{Noo2{q331|8$icahJ1UhSg}+DGAg&sDo<e+|3n(}?3yOu1a^
zlVn`8gD01VjJM@7D#vv{Z**NsE?!qI7a_03F1kVQOUp&I!$Y}v+1ezIR!uGz@OvN^
zh2I0Y_+9ihsW@+&cs4m4%SEcSI^>qEQ}s|RH;q4uD9i(zHk4a$68<OM)Rwz92;J3|
zi`UBU)%gE4!v9yx@4b)0`Ro^70XfWg>_l=necpH9o<I%<d0&ykj{+V#>cWGbZ(kG7
zw8yLA;YorA+UbWQhi~6gT@L@n{{=bxDEg<57dhN`|MXxDIot+0OtEno{wWg^xs3WV
zn!i7M|Mc0S2eOX)(H{-}^xGctqlfw@@FynoPwyQ_;MSx0pxy$!Qs??~|4FD9(*7m(
zaX>C3z5~1P+rfB`MgQQ&%O~~^w&C|c52pQt-y?qd81fGWF0V(=_D!M(FRZBt-*!3Z
z>P_<dM0zRhA8gwl=%xP!zv=wC;6nSfwqANsO}M;L;KI0{&)@b(@Qc-rM^B?5iqM=B
zc4o&R`Q7?T`2KeK73$BSo<aCj>*%fi%Xb}==X_V2+@H(*lZ<EMgmn5v<cITj$^GH?
z$mjX|fr{_%lkfLed|!A3_untyqdp1q%4&W$DlL+E)V8<kx98G+=*gF}F9hBP`xc*3
ziR(XUHWT7uy^7>513sPi$aq=20^>s-y?D2Cg=Nfp_V#i=U0?n$WF5V|>|5HGpF{Yz
zZDM^^Fz&e+H;BjLJ&<=c{<C*GR~%f)@k$&g8YcYu6u-SCzOT>rF$UvX9%ATP_%Y0z
z_GF$SevBWwNAM7h5P#9>^b?|C;@S2kM5mM9;{1@-VOTyW*>A==Xv;tOJnM0cZmo_o
z%*V+3)vg3QkrxZ+KZ<yx)<@y@74LR#jA{Eg4ukJMfag>{cW#As3c3Q8%g4jH)35{a
zhv(jYBF^<D9I}oZyP_SW+ukM`xP2X(57P5{t&T9#{x7~;>zOsQ?H9A|sxMD?_s!!t
zem>#r7brZb2Fuo)K0n;>_u~Q7eYT0b=xKYU=)-8VopMv_Icz^yoWIt-MwR*N7s>jg
z(!xpj?L9JnZTYn|mS1WA>Emkv|EuKpxwiizpiAH#@V^9jQ+#%A|1#GT+=umt{9(_1
zbVEYV*q4D43iEH~#{1f|zI>SV3bDLYc!hFC{27g>CG>Eo%%^wwKKYDBbex?!?k?T$
zwOBv9`MvMreSIB#&gdXqS1mk$XaMW@DBrhR<#WFiJcZ96`Xk|Y+%Lz+E&mk_Q%@LQ
zdfkthb!1o@Co1v2kPn`4BHpY0Vf1~`Zl$l_{Pnddd4)KM#UmiMkbwbS|85ufitn-d
zPx$ZP0J9&%`)}IioL{bd5#w(%`mA3cr0Mg*HIV;}(>JeMQ_k0hue%Q>^$1pXJjOIh
zy#Lhp#d_5n20wHi5A&sfAJzqUAKC>!l#JvDssE!w8@721o&nipKRpROq$klkP0n2`
ze57&3fDi5WmUg~x=ewMXcB?)r%@g|U$ux^x0zHBsbz7p#%I<Sl);H+36dj3v)wmMY
zg${aH*XwpAaV1>89`^sJh%brTOWaQNM@U!p{44Ri)xBwbCdOHJMbcj(x=gmi3w<J=
zHO4fU#B%|+!s|$9zKeEN;dQK&@?GT1!s{sb&5kN8WPxqre8REtIx3vP>#3ItbfetT
z>?_<qpzbf5ckm2z+4&Boyt!<~p|x7pkuZ8%&XGJ`PxILhTNbQ-tEc&84y-b!@y4F!
zvm}EUjnJO!X<i_m6QU8$v#0q*4z61?!gb&rd*rjS?u7zS-$6L|Jn1Hl|1qW~<2pmL
zC!?LDH^6oJ<1yZ6MSk_P%y-y9)zkc!?z3g{?qnV?p7%2xL`*X8r@NoXwaxofhtkJz
z-iTyn9qZtZ#=I|-@pkFFPjoPqdz$A69VhTU!J(upnfLLs&o!C%EcfHGdAB=k5fA5m
zt-OczibrGKiyj9!TqE<&Wv9813H?0L-6x-&?su4P6+T`n^Vp>8eP|rd^)&xs{H<kp
zIy8<<e6rr(j$`J@dVf6*)t=DTgX8Z{t@mg09_}MK8tZMBdJ^5IruCjZng1RK-&lQc
zPv+inkgCa(p3D!%pM`6(pX<roJ&vu)QAznE^Izj%k!z*5%y-6z<eGfallk^IGLhBb
z_`NLPe}TgB8{^32^)%lx{(0Q5b(THNUmpiP5;%T!9IXu!IDTdP=W=cIe!IXuq#KCF
ztot{4&(VP6H3G+TWV|sb5zLQm5uERK;urX?Ll5Ko=se1UTn12dF6yD2i0fUoAA;5C
zh4K?1FR(qSD|R!_u(ah#;s^QsJu-f-MdM>F^D?+U*OHOnvz$g;-_v<I^B?E~i2LmQ
zy{{!=p*Qg7yY829tsh~oDJM6WzV+Sv<##{hF5V}<w!1Oi4`%h*o$Ga65%=w}9)X_3
zFOYYOFN5AiH=0Dxguj3Cdftb8%F>p5ML*_RnlqRx)(K6Kl`bk=Cs5IOI^UaBJ&ii4
z)1E+`gFn3YIoBrsj_JS2^Fj1K8krw|&Si;T1~|a;0bZa-G4J{KUE?+Q{crXAA*p}+
zlwc6}5PRix`cGN+Jy~~zhB=_8^O)Z+=E=W)fP52;X2cFDoJWH8`2&LA=sfkm@}!IC
z4TMACWa{N&{tLnf%hmp0q4j*r&r?1ATEZUtr|{%!^uDb7GUqiyItKke1p7hv1!Mmc
zECWA7=c#cSv#*VQqY~*b+NpFo$a(vrgED{XbAtXppp0l#*R_M|>1nz{;AVB;w!b&p
z%jY{mKtgBz@_EuFtTQ}w4cBFI()Q<|uKHk#-hLML577N5bF~jZ=LU`+?*rgvykEu7
z(0R6<Df2&R%@;Ud-Oo@^d#k8$wS8kIPYga;$Bleu&&||61IBN@pYQ3^{hat7f8by6
zUys()Tm4}t+p5NWU~E3oFvmIbBIRpaFM=|Fzv_v(I$yKb&s<;GCj^CRHlFVyoy7YS
z-pKL57ti`ba-Y%Dm=;tTT^Jmq9i*pdug3Wl-bUZH?-2cs0D{hS3=~?Oi@~L0KHAR)
z^Lgb?=qH^oj0LP)>C@(6@rI~Gc-ebxpN7HH^ua{$`_@SEzNkdHt@+-oIG?$?Uo6+g
z`Wd5R>oZ_<(K(y@^=#c)ca!k@Nlz0pjK7cRPxq(#A@!pa-f6zdx|?O3XgBeZn>JSl
zj7ogY@DYuweA+=iFO(>6ih1_)S+4z*R%pD)<U&u&%Voz(*1c5T1G$JDueL7WY2#|=
ztgledG|H=L_uY40qKEMNWviWAp?zQ>9+u5}J4CUYxBP7@t<D$UFTHr)rTBj7+b&sc
z`!Mi*&)b#?_pe;qx7zA|F|Nq_puf+`)rbQSpFQqw;mEAkJLOuQEb=ke@+9dShH=+1
zWG8<<f2bnvA$3prgB9N&l(;heP|O1?;q#}-edb4F{9A(kSw2rZ;eP!2Jn<CTdF_8J
zk3WH*0rz{ZqrOhB_qD5G4+y%d!sFv9JW$Uyla5rr6o!>PI+Q-N55@}JcL+T{K0Yq{
zeenL*=>FN|8sA-!f1KEFg%Y1H=AR(fOJlo=0(WW44zWMX4$8IsT0DQ#I|*Fa?;?)p
z4iiqc57Oru@3Q?tVZ09UTi>DnWDw^@T+es3OMJrTX-|f52b{yY`9lwnC;q3(^*Jr&
z`|yC5*Srn%#`)!@n|*bSV0dgV@eKY><FyU%GrOeOxh-m!ymX}8?kAn8T+}#Xc>kFr
z&J{|8cWhUbh!3+Xq7wCYF|T#{DnEVx+d>Dv|Lgo5{CD~68~9iGoCrSHR}c+zUVy{C
zHslc%4so5~Zo(n(2L;XnUa-DsgmMbweD&?gIL61xc-;cfa6CMZ=ei#p9}mB`IQFZ4
zUH(1jBkNWRMsqD+knwUYKN9|ZtkR$H%S3ee$XgS*CGcVZ$oMOat5&7QARcD)_{(8e
zM#q4+(QO$2vitwvFzglTXWPf(`<busgW6vwO%Ef=C(VxgRg}(w*MDfOwyrl#nXay^
zN>`s6hXxzlt?!>!gHJV{2fnj<(XRn6K^_=#)$G~uzT1bL^I8X&b#xqaEk6)Fl+c^T
z@l~!R@=o{DYyTR9XUIR4YnAd2{CTwHo#}nx<w+|NyR;|seF32FCm&A*p8Hhp?F2l7
zxWCYu(qjl$yZ-~YKTStkCt~(4=K21XYV-qaRe62_xzu0AUtg1shf`Un(aq*M>E_CS
zZo+k%ygThd$g$7JI-=4%#!uSmXGWztdd+o4rFOlR+lB7X+98%F&CVToe7V2ha}9h+
z`nP{-bPBw`_ivpmjM5(KY5N)T-~pfiE|m|M{|Mm8M3BkLKecs-{Q3B|J6G7N>z|&@
zK;ccc{!q?YKI3$e=N1>B1O1qV3&}m9>nirz=ayBI2ior>ppUBhG0+31?;c;L+_L*y
zCy-m9+s{s`HoyAhRVepf(jSh~ec1Bqm!<mj+)qo1o~tIWPWUDGi}{nsEd5Mi=bzq}
z=(}9zhtwZapcmt(e-Gdp>NWfQU-5gO*PzEi7r&}u-@Zrmz)7@+rZ69)$4{29u5IeK
z(%y(l+x0r`n<sHW)5r0C8tqRL`Xe8f@$@<MBfaj=_NQ{cq@T?KjjUr`sm0L_Xa0X*
z$NVR<(+mzbR-3olZT{&x?-M!i5I^Q;jHU1cKLdDs<AdYlxi(}M6T8^*!hjnPhx^{N
z3i=jVn{qilnH(~^;tI@vRPhwl%|mj8c(VJ~fL}G98m`Ceiya5c{U%%IaE*2Twb0>z
zOgew@{{lH`b!QiY?$h>PV2?c=`a1AWa4X<;f#B_c(yP{&mG07O)~$u>djaArY9|8z
zHqPrysCzp@?4<C1nXl40-uJV^l+VCp=;yxwl2ASmNn9kPf3bgq^-H`UfScj*%s`%0
z<4e2mj2iM8^TN7rJP7%$`-|(a<7?sZ8Hb6-r`CbTsC19wm32x{>3+Rt-ZaEpEj-T#
zo`<UAIT}{~MeA0_HVQcl-fsi{R>U`0#}K~P;Q2_3e@u>drTEAA>ds$|k6XMW>xk%(
z9ww6mCdVGy5z2F|kBsHH_KTgsZ?$nAlyS74a#;J#){uu;_jJaKrl5b!kNeS%a(yRs
zALtdk@1E3spg+*<HQ8!-Vcsspi_mMpPbTNKT^v4toaRSgCUh09r(S;i3g9*cIsBy^
z)#b3!(I<s3|H%0Sc7e_R68W8t)BO_KiLkE_w>N*#`U>Lv$^5>XQ17aCw8bHEO)p_y
zQ{y^TCsb`d-}wdP2=g4_@3x-S8hr8XUsl&Qg`nQh_9t8453wWLlYClP{=6M|dB!LG
zV#cFRnU-OkPxJY)JPq>e%L<66i#dh*Tv>OLPi1`5@+E#i<N0bg#`&t<e4pjBtpAtg
z&8*K|(e$*w-*<34>mO(O4*l$qVYc&ZqFs#VcCySM?!$djQS*VSC#-*;wwa0Zh!@QI
zdDZwX`00w@LQfHH@j5IIXL-P3&eP7ZK%OIAFYv6ZtI^S+hagd{4komJURc07el5TI
z4uzlPu{7Uh`K;WuU&wt~w^Q(g_b*8G$3un=agDYh|AO_wl*1?TI_8HM{&4?-R37>@
z!Tr8_9qj|{qi%Uv%Y$Pc-~VCIZ=}gN)bZH+qD{~ui9Z#}Ip7!feRT)uPf}wpD)D`O
zV5Pj*_Cxyo+6p@bb;_vMEb9|UHjMjOV*FD!VcaFEH+OJctxNU!?Rw2RSfAgf*XQc}
zTjaV>TBg^_<T~VYsjm;@?3O={j{~lIL%6g!_93;tf12;b{O-OA`3%0#`rl_=PB<(Y
zR`|1BjpS9HsdX&i*mV7QG~CO1cIbYV;Wz5_KCWx{JiWd}uV10pqjHVB7sl<$JR$-i
zy-v*c9a~Wsp3IkZ;p}r{_3mExr6h3H{SPr7xc>q4*nX;Wo!3$RU|$Tb!}soo{Tjr_
z&)-!3`|tjU{Vrw)6F<fL?_@nD_k2I?Vm~y8`LKa`{G7r380LX`N2|*OU5EIqmOn$i
zaTv!R#dXk!4|HJloY64p7x4Qn=y3xTj_vcXeb<J6)<ZexweG8DT8+M2<{vaU_mgJw
z(@9d_{v`ou@9@Qf-@Xp*yFc<~;=7Ce_oJP!=XJO4x8L<DUN2^!oxZ&C!D9WsTkr4U
zIDH))Kcs)~LsTOFV!fYT4LSF5nNPG)<F#5>XzRxOaYMX*)h}NA@uIE-zh|xQ)>Yca
zOwU7^Y@A4w-hReHp^L&g?tAw$7V&zs_Ji8W1aY*E^-a+xt!vVAT9SEuP4tQHC%r}M
zx$o5H$**>P-K6u{t@2L$QzqjxKka8Mk@-cNSRiBlC?_3v9S^qgGZ-f?tYhCIKjSoA
zKMQ00jQM)agM|DH`U%lGZk+Km7V!P+SSRggoGaIr^ZkgxBU-2D$_utx?~Q+J;&;H}
z_VhcF^$&Br&G6=2+y`#5b^9U4{iCfKzZjxkFKiu@ar_YVY+-A8+`F(9UVw9cNb51T
z@<0kd!~)4^D+339sEzB_dVplU@8*2BBC6$FdcS1N_0QNxd#nF8+M7ER-#bWGezDf8
zb!)v^7yUJ}3zPR>A@472WPYTu>C-Zg!UlK~&P7+=!q4?A?2q&uAb1VHkM*0z`5U;l
z^R(<dj-IUX-`lxPf;V|y_ZLn6{3Y^yvAc<%{TY6Cv7p0uupY(gPyCSjy94xtqmtUU
zdB!`;J}>6KA#%&=nu_^5^qTlA<{2-EN?LcD-><(bKJ&Nfwc;bcPp^p=pT9+~HSd%k
z)ob!oF+Z%=<fmf3q}Sx9Vt$8Slb?K^@y4j6{FG-rGPZy6Tl9X#e}0`_Q-1mUTD_+H
zD&|+|HTkKSFX%P-p_u3X#;8R4@_E`bk?KpIr+s8~6F#r|cC>EN=XIY@iF(YdUI_K{
zJ)(!Xe-8Ro=qj)Kn*#d?`?4mguSS22@cy)(6?;qfNx-f`J{x-G=U2imq25aNtG!+5
zKAb0>$Nd-mVtm~CtU#_v-IMWkM)k9v+nM~%@8iCof&PWYfc=R(F#g!vUEC)x-VYnZ
zA>@5p4<5fy`*OzbJ2CY>tDmXT2kIa3zQA7=IBDDu^ZEQ0)$BIPwZu+S{gv7mX8j0#
zUi<!Zu<uXB`vN@A*Ld)&QHQWs?ZvoW=yKvEh@YhU5-ddgGl>5olY(`8?gQoPlzo0d
z{KW3t_W_)HqU*7`SHrXQD^!0pnx%Ta!}@elAz2?I+n;Iu9!<Y{rS}Rr1aKd&3U~H}
zjrJIymG8qdc$+^{Pya{3cL0BZOHgM5_yT^fNB!0)@e%E%otA5}IxYqR!N1@uqtB2}
zgs+uP!gbsJyVB1P4`G3J@9;*E?|mKYD-w-RPuY5+ovY<{-_5>F(XLB*y_kKb`tsWE
zaj|~it@n3voW2f@AFdnnBeXv+Etb=Z@&6Bh-dO&BG3dS~zw^Mx+WgK&%M<bYv)>MT
z_)OuW-eKD3(TLK~PNl0|>h~_z&u)J2yLew;2cI)LKZGOT6vFYPMZAywP!5N0&j#NH
z`Hr-lU!BT#ptU^c^~K=hQPSx|c^>2Y7vMb>XUaJ7myI96Pd4szKH!|Ec{!<^u>J|*
zy3_Md%PY%6oQnAbbO4DS$}79?$(WDr%T>LC`G@=#4Qro+Ce|UN?*uB(ZGR}%hx-Ay
zUx3et=ZhVXvwn-EGvqqF?}4`^`!pwtE8UigD}Dbxd=K<kp~N^sQTa8LJAf0${dgD;
zX>#rvh*z~ZcPJPa$1kPdbK*70d&XWM<X*Lp)I+K9!#GrLf%b1t2B&7ipHP1)*jEL(
zSwDX4+r%HP@fWR9e@go@^t4Qi;f(bI-uR65Rg-fMs6YM;>3{VLj#E_sNY4?o^HyTJ
zxkcY=eGd8=xAA(uQeube{`l3Zzb~V|Qdmhprm%*DR9H*Dr#MLawAfF(v^azIs9&sk
z?{3Y9chT-Nd((H&&J5)|_NQaLMSnElXnw`FMD9-+J~MPbeg%B~gX7f=AMJD4f8>1*
zt*_y0ymOt~&SM;Jx9-zdduFcrOW5y(_?PvO(D>I(J>L+&gCaV6l`b?cf_|j<27I;o
z2j%fs;VaaY27Cp4EerT{@_wYuCz;(dmA-yUAa^G1>sSByh{!-*nO!aROG*8qn*CJk
zA3trkpDXiM|LZ7>pPv6;WBenQKgKuek55^y)Z&|^|Lc5%^JuJJNh9g>m^$b*+O2W(
zQNn8~eSp(=|KnSo>)fvUq0GM4xL;Pdw%krNIdZM^jb}gAo=i^S?FN@5&TjozEzYie
zS*!Gul6ZR1r{S&W52K~9(OQkG2KE!=jLD&Nd^U=>naKK7_B0(Q_h;P`g^qfMpCg}r
z9U9*ld8S;Oo{4romDk<M&%5}XUrfEzXMOe;>-XJye;3E;>)`mI-75W3RL(-~{j`wS
zH&Kys+H~B#*7|%G^CEE^K8`~(UR5Y)Tvh$%LP6uImNzPBT-EYQ+LtfRI~6pps(C4k
zCt%+9t#mHR(*KWwei?!fwe#Zhi!|?LaaXVBiT5;{oM0bh>#t<zQd%B1wtMV6B(;0|
zkj8uT9JZcV?r1zNQaeiXGn0;&*Suaq?WsKDUxkdu<MSGy&oCbE^BSMeFfQ-&8XwIt
zKJPUj7s)Oy=e*|0l6iiGaWL(-AIfuqqn>wHv2Klv`^Ajk`9Y1_^)ue*^UR-FKcnP*
zpOg0$*3j-MT&8x|YT9MdD%xq$O4@Da7eov{$o^5x%Pap`91Z?C{&0=Io{Zu3V_aWJ
z^Ld9o&Tjezx-Z<$Td{a#G5=4(r%{Rd&|;qFjYK8pON-Wrti*h(kLz%lZ}oXSm%XI?
zl;?iYD2|8noX8};$a5Bp{j21?#l;1FYM#n>Xk5U~PuKN(JqN-Mu^)62U)A`6#!riR
z?Hd@!PigmAe6*Nn{2_^tGVT>=eAnm8`(8&H=e7RV<~Q3pA%?ePUkms9rSsRmgLye`
z=ei#?JE5O+GF3aF!meh1xqiEv=K&V`*{82K!}@vY{-18$*Vx5A1YXYt@*R54VGz$m
zzd*>vuSVF%Og`+K|3O(7cLkU0&uV?N@cb{ZUv{^~&rPpSd!fX;;&ak!*nQD%^4V1E
zfV6%2@TIVix!zjunacQSJL4e658@3+8fQ+=|2~Yb`ZbQHTK>}F=DpNg$?v?5<K`CE
ztrEw+3*#R#-M>ifkYj{C!nhOi6rsJaE){pOc+A1~Bkn}|FN`N)C1E_t?tkF@&Ux))
zFc}?91;1(df1(chIUG7o)6t#=)6x4Uq@&v@uWHiKmxx!TqpYJnapdytOU!pq7B{$D
z<0^JO!cmADRFhY>zs2k^$gkZI@;H=VNuG=6bemsLORktdb0qY4vC!XSef#@}zncBx
zFO=V_@&BSr5odmr{N6i!qkQ&h|J`Wh-EwVxb)%gddEL$Wo@mz<yk5+Dpgzr$`o;Qv
zx8C2yar!zqekc!shp0rp2fQza9X{##Er%a(=&B2zm&m$m!;|o?2G3^+JPB{ai{|`y
zdA#U(S~r-E7mW@EaaWb^c>dL?=TUbEI6=?A&XK&4-fwlQRr~%=Fiz+Py%c#AwR<g3
z7agZ{M8~Utq<w1qZ1pS7p&<6p*K@W`rM+EqegFdGx}N81`E{&!Q)-?l1+w+}e)U_I
zaX!5f?R)EEG80V()o#ZUI+v&I_^HS7ei7gW^8?)Z7Uw$WP%fE&kA6zfAD8Q=`5RV`
zYyGR!_g$d&&jqu7Dr5J}=DIA89ol7Epg)6rXN$-u#?N{(>oi`W{=dqDQ<@m@06tL9
zSS?=pm7uQ|{K`AW$H&jSh_q{RzuI#@44#YjFupxk<Ea;H;=+txte=kMiK5+#PwkUx
zb%!R0f%l&c(GLTiN5hoEaXz_L-bVA&xhC!Jul8Biv4G7Fus$P%>wZ1A<|6_9;r$O5
z`Tj3WCmo)28Twzbo&)d%h1tG(>oe|$)ZQMV-5J_Lg1;bdjQttLe}M0zRDJL(-@~|b
zIIj@@FTD))L(H>;c_8%t1ie1|{c`z(K7GgoZ3*6kJkV%xjdkA@(0!!)?d&|ns6>Ck
z&H*y}%lyGe>v#L&{eI?e=y`)B>#st;GSa@rKF_*Hz!jnQVxImPt`TbJQ$G>c=;LVh
z5m@J7kdKP}#Ubj=iQs=)0Dr9eI><lO_Xg)``*jZf0R2g{&L^mM5PDF4PRGsTyx_5v
zqZU`fdoNj$#LcSVu~t5BPJ6PiKI`<HxRU0ZV!zt<Tbf_3`6u<OBb6UMukZ@$7yuu@
zx7Pdb3i2M+@`=|5bd;9+V;Vof_y+>MgI*2wT-2-eBC|FB)~od*vo*h`cB`MQ@iDbi
zO+SHNL{IAbVm+zxt5DzmG&K*D3;{oo`@J_)F84)ui3%`z1$l{xQz%ciY2I$(TG)?-
zcTeVBBA<P~)thNu+8oluDQ(RXnZ|q}r%kV99rs<J&yV!^A6EQ!sQgs@pMJm15A*-a
zvU$8s^@P5E3VLE%An#*6u}bxX%HwK!;-v7oHtLsXFW1qznddm6KMK|z+S39D#i#Wj
z#d<o*^n&J5mG83J$Hxy*UxaW$Tmx~SzYFk;@t&)4{>v)omjr#tfDg)f%5_}h&(0Gy
z`5*RU0{%leFXzOo9;zniuX#7+d^oQVf16fUm-DFmIubem7Xg1xF4xQDc%Sy&nM|HX
zC5=M`@|^OWb@G5G<vZhsxTbt(T(DBUQ;sEg(E7NbzAX)Zz{%(c_`Wm9J6e5+*&Smj
zT2a1#Hst(XjbGJ>^F+hShc)zo$(yLeI@UywPEAgSa@p{HxN`Y>TNAl9#<YnWW0{n*
zx)0ys{y;i!lTY9wdtbRdfzmX<6Y??I%sxSWV3FJ(ZPEVQgA3(4<ijPYxX{8sFy6T4
z@z|fkyhAR-K8VpC-3O%dWwO4o(QeMSGu<C{lJk@8++^6@vYtB530&Eq^ks(Lf{F?A
z=a=I5ApU0kVZSByU2BBS5;~rz@SdZe^Y!x#`LuYs&!5Kc`_JX)&;t1k;oJTP?9<V{
zO+j4uH2Gfp)D2YjsS~^e`hUS6!hJQQhj8C=3HaK}JVnp+SrvV7#?a?3uy?ls?*@;c
zFaFB+!R{j7j32|_FMVIRe#JUKcYpUl`Myr98{a?g0n|lmKewR2KIkl*kF3}7KfyUQ
zZ^8Qld9p9Hj;*P6*gpUBQ}dknQ2G1N2MF)ko+00ym%2Z~{DS&g8~0W3!@lyhN(b%4
zyT<RMlF^ICxl2YzYG)5p{zfI^XRT){DgESW&qpQFk>yQ7x=HgZ{3XD7e+K)THBUH7
z{N-BP#on3-e#=tuv$*bG0v<s=T;jh0JnX)X_f_B54E$zoe|CUB!Ml!Y<3%Hc2iEbb
zXC{1#>j!^SPFF^6uYMpn@51CJ%ZroqF5<Yx=<mVckeg3T$xWDScn{=E!vD9){XV}>
zKM&~VUGkaa!}jz0q5JvSe~)~I_`2oy)%kzFd{6$5)~meMewES2N_j9JcnajfJ-<)n
zfgjkx_XhEZr*=XfFppeK9$cH^BcZD*^5Ey&ArA;Y!&fK|9@t(k53nx4GoO+NfCIk&
z#7{sMuM~M3j~mE^gIHG}r)1q#<ida9y#ZZqNv-FNDY`cPy)!l6+fs4}{R6N*@Dt|y
zwbcD5){qOgZ--nU|3{@;NDr}GFgh~1VDy!e3wwx1KVWh}=_-~Bq_1jnLEsd?&E&$z
znvu`p{+wLfu@&+l4YxB=a5FytDCl61(m@dKsU;WoY<JG<d6XeP0Ke7b0=|#wLFG*7
zXWa3^a=Gv~_m#^9qr0#CWGZsuT)`9M!e6E20!{>|lnYA~uZ#3^rGBoJ&t#v~GJZd_
zg`fTF<THfB!Wwd6*%al1OUZ?GWpZHw-y6t<y?-tJ;w0ZwO)gxR;v=D}Dso|k$OXdB
z@D<91OHzD;bpf6?|D+smfCIiiy-Y6XxPe^QmXZsy?kaL&QA#c>O0DPVDf%|Ka9(P@
zOHy*-z#l0W4yjytW$OM<V}5~tv~kZCxj_DpN()I3v0N}ZGPz*%m6i*{V<H!nu41`B
z`l==u1Wr}t!V>gT8RfpfYH}eBx3(1AOfGbYTu^+~As3!nLoNWn)#L)ckBlCw$c5oo
zl*@(RrtAfyyK_Uip#A9M^RZI(^*)db3sZ6d{;<h~sF!;Cl+0YQbRb94{V~3LWpd8C
z!DlkRsWW}PI^7c&^;*77)TfJjYn-p%r}x$2H{HH$V!!E2=%c9chhJrW(_cy-GmQgY
zOnW6#zZLi4&vz(2cPO2AsJ!e@c{!~6Qae;$4k}#_sk{v6R^(-s{<k78C+hb-fqV?*
z;+wjqk0|A0Tc!V0uUy=Ja{@1;*HA8g@#b=S$>{Uf_g9yT*W91jOJ#AbYVuIyB6uI_
z8bGI?y4gA3uX-S`m(u)QOD_IHYQB@n#nIILwdCT+&FI5+m~wGQ<5;nsbY$`{8X<fD
zuZPh0?I_5_&7gxR$i?-*Qx$vZaOL9ox#e>4bv5MTuKNRfNzW;Y`|)3*=bVzwrB3sf
zOga5Z-YlrA{tWt&TAXqAX(9>YywdD>dae3xHX^{dU*nmx+vPg6lhWh=L)rM}rp8~8
z8vl&)@dvcO+3fjzkJ>fSMVi;p^H_6D)8%*MN0H%(>o_&v9u4!{R@1+B{;Zv+6O~x!
znB#F%E*fFK%}bh{bj*r|**9}0+s7pJVp<;=J$ar)wvop?4)9jIATAGk+jsE!<)^Wq
zt@T?!wT*Evn}?k@f;d0o-gq7>&1JF@N0;*+<eKZp{XfNd7ekzH*8Pv<!E<dtl26O`
zpf47(U3NZK=WGVzA$RcoT-_%dUBr9}^y1qCJqkYi=*>yLg)yqDSZ`n)jMxJNXdF*I
zHShn{RXqRH&SlFwo=0K%QOj=^tUe;HyVdh{hc$27K|C3}qG82b(*b#L1>Q9OI#c(<
zA@72?fsGR#o5GvsgJQgCpVj4a{`c^PI*w|1!}rzjc3BE<YaUg+S$%Z9c-!%3ylI?k
zFom}lKdN|R9lO;dOwMmB|BN@q+Xqv4YkO4jrv0+&=C=ikH|nEUzv;PChc73oe-b&#
z@sFN<<9HM4x2ej>Po(g6$4!mUZ-h&we$&2Yb>pr5&v;XQyFG=sp+^;O+JCNYyxoIo
zyXepS=Dwf8Ti>IKH>;Pc*DldMWPiq+`&9~W&wNzzM)_&{me~FD2XakxWGnGRJXh*7
z&DWaU->Uwa_P2sRCH|VmdneUrt@L|he{K3C{#vX0YXdd(*>$YXLto7@eP-vFHuL+r
z>Ze54C;nR7kCOTl_-ns=Z=lb#)Y0O6vA;G=)QVi=FZS0is^zaKTs3ZN{+jh6FV0$`
z{yXtjoOPjIlmCjd-lEr(qs3Vl=r#3Wan_slns!Zb)|>QN_gT(btk?82inHFR*W9OB
zoV7@<<Gk>!h4D4(pxHOw>fNFe_j>|fv;QZFtHA%Q)vw}EP&bO_W?hxUmnVAep44;4
z)cM^0)N?I$K6gv%xj$~KZ=Tyz&;7Q}=hmg3`$e74ElWLjf1S@QOg(pRozI<-dhWZy
zb5?&~ae!zo<7uF$bs5Gxz;VF)x0a$GG^mPvlm7kr8xnX&8_B12_ml0{x;Z`9Ht8?h
zBykqJA8`!(j5bkjSp6=-FyL(PJ3iC>5NzK|(kI|I5-;-ItjqQTT3@GqcBb6NcB}SV
z7-C<i!dBfkKg7OHg{>?g_CpI~zmWB_^+Ve4Z7X(zpwFrH3EQgiz9H=k2H}W!Q{3m^
zZpOPdYTtyz?%R7O$62rYa;*QQ#-%2MYqUZ4^>ncxePM(4UFhPuz=aLkccF`Y+6x=B
z??M;*WknmbpKTY<uZ=cn--Rxo7Z#0ZJ-YQ<j@SP=&U=H_bz8h^GCHUj=M%bqWD5~T
z)%`H_u79)kvmIc6kHTi|^YH`hqg~jn{cH!g@2#*|``HfYzPQb-6ZZppj>u*Pvi$(h
z5sCI_{k`?SjMxA7ocCt!Ya8S>C**^Qac-1xe7E))UB6%9pmnPC!eJx($@^~h6|jD{
zzMFjo3LDw?)^~HCc3~s?-}-Lt<Fb+Vr|)JzmuMps>%MzG_kHf<d=j~kk#%OZzizbg
zfXw^w`JkwDa7fp$eOT*V|5j;R?)(t@XcV?Sz;U!sM`0_^UGhWhds*0ezy8j8$Y?A5
zCO@Qo?zeK^fFII6_<Oa_z4axH*Z*eDd#iw>Y=8NLbg)?a7*~w<T8?+sX?Wb#+sE7Y
zYhB+a#+QA+_OITQmvMYQ`*jpHov7FB+fmpA3j+B+_8W;d(eL;D>^Bl^VuKCe&pNS6
zIr!J4-vQ=DqfPTUZ_S%bCJ&-LD)-gCOyGJt$L(TY;b`+Bj$0?6MI*XzW5YtOuZ!nl
z6*hG1HTxeIHoQWwnP)C+I9IRP|2W#f_?7R{{@EMO(BHK`cLhJ^Iq${VkGWgVuUNlC
zo(uO&;0v>h<31~PPJ<SrM>|z6?9}~BJ9S^3)~_dhY>pw_T)B+z*}!;dVdGl4E^Osa
z(ZZGixh}5L&u#p^xPbTh`FzgL<2b&Z^Y$wh{(AnSZzo(M>m%JxxLSQvv7K;@w2ySL
zop4RgAJw>Ed_Jkdb&1lC^|NkQKCu2G?WAw(D^hGHeOtejVms;E`kNHnN#EAr#J6i)
zOZ%JncBSuy%D;A=MLXqC+^>XXm~kJLVmswa+y|!J&UMp1Fzu8t)(6J7Yh1?qz_e4o
zSf6g+uJTj+xA}JJfynyAv{SxYpO|91o%c$4UTmj)xBc10cI|Io(tc*`8eb?;p8Iyn
z_elG6`*zi1w%@Fs`Zy|4uljcC*{DRlT5PADjY`z3#dhl1s6@S5Y}dX%CF)h*PCXly
zs8@Zv)`eK#@OHH$Z2w!k?hh-`uJP^K$Dl;Jrr1t9Co0jdDYnzjiAuC<itV&>tpBHP
zr=1g(XxI35+BxyL8|`YxS>Nw=?e|rpJ?YzNUs|8gVms~2s6>0R*iQR0((^xx?d;2B
z{i1z4?aR2IbUW?Kc%MLgUa#82@p-+vUyA0o^D~ltO^h4ZejVn^!@T&p*hdr8#~{B8
z`#t-!@$qOk_wV#f%h6BWt9^lXQyxdlbiEtbi9Z{TJBs~M!TIy}v%Z`d|F-MspFq$=
z!|V?axi0tdBREfmUt}fvAp9lvxy21I-j}DL?}6fb59b-y{q0Nb-&%xq2X%j-T#WO^
z8_;i?<69jJ^b<g9^$C!_cK_>cz&WP$qdbqhjnBJ^_HciY)m=S*nsXOppZQI61pFZF
z<}tF7n@e(bC+R--tn8X3oaDK}r2?O5FP}qPN9riFUI+8PV`Wk&HdD{b0XzZ0PKxa~
z4w0N!qkV~keI-H{!MQQV6{P>U=#R?28QPzESm^^zbzv`Py=YpWnO?H<Jj3<CUk%rD
zE7l{_<=jlI4~f@9F<)gpbi};&&6{XlhgOE`Izj6Adxu{|JvpN5*{SQ>#r@8Hv3_>*
zd+W#D*TLudbl+RZSAeJOLk6BQ%Rnbo<o10?&nr<sq<n_FztErBOL+dy|4!mUQ4RP<
zBkGrEeMl`l0G^~T<Fk)*{ks3(>f2DKAo$r!{DS_3P6GOS>EAlpZ<Vg^k$%rX{qT$a
z7WO3LWqy!xv=C3iuL1qdcs=-@=T3Or?=s4BC;VWgT!S35I0N8yU=8F9&!w<^+adpB
z<+$&bKGIXw{sg+e&*VW?&#{?Gd}g?B;`mJS`Y=AD`nBG;K^&h^e>Xn=r&fGM^?99k
zc%}V4S$szAlX}k?+N%C(9G{{6lEi1!KaJxv>Yv8(8TC)&_>B6elg4L`)GxL8jQORy
z54&E!bc6b(aePMo(l|b&erX(^QNJ{f&!}G-$7j?ptvf!WcI^?zXK05{JwBuUXdItW
ze>9HIs6QIVXVf2!<1^}y#_<`o*XxeYs6SDs-&pC-rQ<X7gRBpD-E^=~{m?i*qkd={
zpHV+Fj?btc8pmhU4~^q9>MzwDpHcs_UU?JC7mM>)d}fO%lK7mQdih{0v`ZMDq5ql0
zXXu9}@fr0;<M@pFrEz>l{nNVRGu!0-;l6NuVS1z@UOj1iW*^6^Q~o9K8E8-FM~lyV
zNUtqEvsbSzJ~OJ<7N24LS`weZ?o^CdZ+zx9xxZe$P=9>pevVrwpC$2`dpQ3%KJ#6@
zw)o6<^xEPxcj>joXIO`s#AmQ859hs3H9m7to=e+NM?XG;-9b3#P_|#Y!p1hSfD2n$
zPh8kCL$3cEpHX`Lb9_eP?|+WZ{NIVs-0{Fv;xo5QIX?65Yv~6;5FL&9%uOxuch84d
zb4L=NIpw;k#b@STS1msCa-B!5_{@vs_o>Hc7;p*W8Hh-R{_)?x?Qr5V=$cf%UnU)&
z`N7-5I7UX|7+LA&0>Ali<1>s4S-chg@l}|=p1(4a;oKx1L-VOhJcfp1=-*2`WSD*u
z#{KuQ`9FGbm;*~Ej>EjTW#Tx@$i0)tVZ6pM(sqNz!7Ae~w@Un_R-7drmjV2aznF0s
zp|>E8myWy4ym)GHm;XAiO5A0y#$ARckGqu6FFYN03HBF4zF_|AdvTw}LxX)vE1R6e
zoe*gb*9H2)bHC}s{4^eSg2l@<E_Z^~pOhHK^V&x{Dlv{}@eIJfzIe~)i5Kg4%J9AO
zgRG12dCeR2Grw@kwCNI8i#9V(j`yVNahCKV9>jid)qel{JCk^joyU#)&|%H|62Rg7
z-h?lErawpIeYN{;4aSRBPc6O_73+*EU8ZrRdi|b?x*3ftb!mM?!Rj5D$En+&ENVQd
zi~0FNQR7KnTK`bgc#@t|QYdOXsY}m;C~7>ZOY0ws8c*ud`iBwDr?Or}>wbzFS32yt
z3gb$?OV3~L)^pkm7H49ft8REiR{y}df<k2V4_XfqS^WdgEh$7+|Dfl9Mpplz^$^-O
zG4{9jaz2&y3jfS_a`8yxOnQz+!QxEJ`_;Yv)f#8&RzG^R#+ka+k6x{Drfxk~Wwpkc
zy0y+>wZ@sc>32k{HO|znbrm}`4_Ofxc|X^`TH{QI9bdU##_?TRZ&R>1lh!5G8)qq6
zy#xK@Lec6SSievxTD=4P<3iEu9kkA(X!Q<S&r!5`2gWO+5zXgT)Nu_c9cY~Cu=#@L
znM4JPGcn&>_xjgroN18fffv?loM}+cJ724Dra?XLe67Zr23a2xt<^Zwpq_WWR^v>A
zj6X!9oR9S<P3lz^bNvMxO5V<!suOR1G0!oNc4@x7LT<jA<6kzlxKp&o;!UG+j(TB@
z#hY%?Yl}DWeDA^<i#O@H>uW6D#PhbJNaIZv^XuaL)=VwFWO_P*qt*TF;JNQ>HLj%j
z+)3++MzpSPMD<J2;!7*J-lD~q*6Ovzm)7aE#h145{Y8r}ZPROuFKw6WN;)`E;NTZ8
z;qTqc_*~&|<4ab5r}|;1+94J7KQjpbRT^I^YJ6$6#+M?EFI}$jrIk~x|5<1CKZIja
z|3f$?^*@ATQvX9ZCiOprqmS!<6pj`3KMKFN{)hCN)c=rvllmXhZ&Lq5`c3M8^t^bj
z|M3ec-;??l)n8iQlGOiDjwJOzlp{&~59LTw|3f*F)c;V9B=tYq&m^w@A)P1nKUObe
z^*@y3N&SzWTOZf|=(+ZB{SW1MQvYM|Bdh<R98c<hNS{f3$?9#a{zuRGitB%<Pm}r|
z>eHnDhx#<B|FJlp)&EeRCiOp7k7V^fYG=gtKUyal*Z<I-N$P)S&m{Ffv}cm~AKEiX
z{SWIqllmXEzvB3k+I?~TkDl8V*Z<JIOzMAFUz^nbSUr~2|Iofn>VK>r%lsM2{iObf
ze4f<*SiO{l37nt7eJ8O0S^vZRBwqKyhkn#Osk)eL>Q`NLKjKR~r!F_m&Nrt(kM`Wp
z^E7sAJ@|611G=#?&V>G$miM>1#jp<O#qUYt2hlL=@awMwqMQrsCSK75fBqeepO12$
zVZZnVsr4SjwdNzjx}LkPL7a)>o4;y#|8PB42lS0=aQ<|<4u}dV8fAUhn4V`5*8#23
zIMWd6X)GfC=4u_$NtehnD(isO^PKr;51)(AmC$v-A6$5;b7P#2o2hk0pa+cDN%Kdp
z@t4#ARmPcwK7zW9>n}x|N$H{@&UBD;F|71qbwFCTQ!D;q=XYA29_D`r=CA!cX5LJ=
z#PhFN$5a_-!u+FQ!U^LJl+AyZ*8AMYd5`G4cj`KJ9g^?;V*Tvq_r8nw^>y&MzC7U(
z*89kNl|J#_4Sm4li)A79eMq+tq8GD!q5fV2j+4|=0X|a4v)<^2epg8Uf={KBXjJJg
z=)3ckUiRln$6K(mC%o_9dJ#wB`2v1up4b(kToFDC>E<<v({SHR+(%^(_tp3T)&Ygj
zLk@-UjYX>vA7UM4T)z|WEmkaab0Ok&x-RYWhPtJ6Tnuo){U1f#sigQlVN~KKk;31f
zutTqjZ-2sey(Yf>3ET9V@g9Ey<sb0Cc#_&-)@M!SW!BNp#(hhdI=A9PGAg{ySG;YF
zRO4K_{Nl6CkM{j4&vn0~?^k)Q^;02!)A9{)G&oi3Q~&98&fVI^cv5^{lXE8p`!*pL
z5pM##{$d06Zyx>gNnRGjr2v=0Y@83G=Q$3w(Ow>G*H4}w8|i*aJ0~*I{g%l&lBV}a
zrx+IqD{6mvT<?@~NQi%2vrj$w5BMlQheYY1U-><Vv!>y0^p%nLq|%4>Gr@bnr+wNd
zBdk;1B6WgF=b7WALeS!VzMuPqlXGdf@6~G`ijWS3&x5*N^l^>xTjgAuwd=~`tLt!o
zz`swp8hEFC%{uO*eKh8^bdq^JG>Cc8fzG;*l0N#iFW3a<_N3u6*||Nh$2`=(4B_Gg
zF7|%z_iDuZUsmJ&2W9=#+gbM>S-<s{GJ7vM2g1&cRl14KmDRp!@wu}KzxZ5Q){|Rb
zv5@Y6oU*4xZa4E>6Ud8?y{DY6L>>in2|VC_oMVLh_r3?`1?c`hvoH5hj`n1Du88Fc
zOb=LHCdM&6aQR!3yk&A9>p#Q$R=p*$gNnMZFkIhtkDza&)$wzG{9^&G8>a}@cM4o}
zzf(=P67C7Sn2!nJ^(uiY^QOsttltmsJEsh;d~XQXtu^Sz=wKPv7to2w*FfJR!vK2e
zdylJHA3gv3NnXy*X$#+fi~2dYtbo11er?ex@f+>c{tmh?-}*d6Biiq+OV7cmavp=o
zkzKS`$8ONijr_!X|MSP=<G1n>cC_$oE_007p>e-M?e7-%JB<5H7+>mqW4>kofNJaO
zSOtHO{R(q!49KGYk=S=?SHpjR>zI{U;QUxlFtpdDKb^&srf^;(JY3KPEF7%A<t@xp
z;{E7Pf%AKM+GyzKrs@2q>HIWLXm(sU&O;YqzK@rQMg=_&LG7%#pI$s)?K`OFA|=1m
z?&@i}SMUIPGksp{&*eRu&)GpZ+W9ZgqxOe?qi6F9=dn44GUWSQGwt!Q=kWJ2Jr{be
z#>b5w;1}c0&X@9j^OIpO;IAjE<7nJ`vsj<bU8w7X-KH*|yti`}CgS9K`@=lV9v#zo
zfvv|r$4=qh#y8A@@K4sM@#;CSN5ggMJ{{{*VEYy3YQ7_0r}ii5?A3Kz-$u1>tzV;!
zvsvMMq2^sNpR#rKvLGQnPp@_Dov&B8vFszB*Vya0CeY<~-|gHOw~r-oQ2eCFjn|*X
zv#nqAKV!P?xr(oN{f6h4==!xqO1yr<v+j3|@vM3A%Jma~>3Q1v4G*Ee`4q_4)OyVx
zz&P_e72%*4l}Dj`*@1qQDwo3VZ<Ftn{byKV`dlrH-+rtjTYje;G&;9_sNuMyutx)Z
zVCR`Pd&qC{WweKK(E4whz5sq9zjD*a5B7a1S1?c9xAKAj|9b9+;lZ9mSVqnT)lWOO
z8+JKP?87?bQ~O+C+`bEvcuY?l8OZLle&u*x^7>Ws`)?|Hp6jS~-#-s<9at}Z7ynYv
zqXXPS|1#@Hc=&$x@;>2?Rjb~<%FjvY=_RX{%jsFm-nw+P<uNcW@k)5(ns}sMGCMNF
zALt^)AMjbt5Bc#slRn~UIOj4vr#U_DME>f_*Q36I&-p=~E9QrI-k6;y8I`o3Z+yO@
z_T$lgT-Jxz&d0=h=|^gvNuK`cIjzpEgx@+qzcXBK8`dA}-+EDRKxcs;2{>Urr>6XG
z&=ctB8SCNiu%B*tjtj;I9uN0?(AQs)(2dc1^b|_jT(j2gsh%mAeAE11tI9L~TGGMT
zbNPwy#cp`5j+1@0{7}e|U`+pj+5k_l`fQBhWcmIP$de|0-mx)!f$g2$nC`2G{UUlz
z{narTk+3gX<=BF8ze=BPWxTa8n+nCwtArf_j<PuA7`OGx_YdR!SL*X^R6qq0{LY2_
zxxh(Q=Vj*rV1L|0cwYNq<)%MN=H<I-uM|!s|CzpMZDHSIe-`I&_5!~D1I9T^=g~q1
zT{xaH)OS<fhT{OH)yDaK**H9pt#CZ~-FIs}m*N-i#T%=QgY#&U`A|`|Haqvb@$vD3
zo-6J3+yKPQp`p$0D4tDyZRZRY<GL)aqj&=6Q@n}mD{dm3ifbtMiqnX{;u}aXW;YkD
zADPOdP`;(lQ`oV_IX{i?G<jB3eH+_Bc7C4HlhI4`M%w?UOn<t-2Yi<v|Hd`WS${L*
z`<mx9w37ZiPbD0485*)<T3<P)@%v~!;bL}fv_5ri!!+_+v_bDnpWC4FCwevwKgg5o
z-<;S(&{xPfg?9Ee_+9rWhkgIIhv#?%=Q;dlX%Z&^-o?)d&NDH;?ITw^S6s{dS61$V
z-=XxKVdB6K9{MdfA$q-@Z`Gsc->F>&dK3Bbd_EUxfB7-BNdX1C-xD0Jr<rwj6RqQO
z$50M_Zz<}O`F_*;6Rqd^tEu-zFU+=eQ9%0cgR+ir-Xhm@-sT^I-(ZsYbIAWT->mzI
z_$T$u`%87g|B7(Fb2wk4dq3m;iuwK#{BH9N;EViM0$(y-)_qgv>$~r%7)Ru(jiY`s
z){RQNWZgE-mpRUiyDG*JxoYDC^Ff7M<$PGT>AMe9j3aW@#tG(wO0mlMsC_eIf5kW=
zS8beNKB%;+oX^J;KDTh3K;DX6J%{vc=a+)ck+SnDhk9BJKD!k@+hrWTcppDIZsTXy
z4*3M#LN5E+9M=zy^7}US52$ut#37t_6vTh`-;4e0tW)U8w2HnA?Up5}^N~O>kR#wf
z$eCwd4S$_-CyaNC90}}td2i5{!Q{o$t}c%w%DE$&w}Kt{kD<NP;-sQh?4>&}??qBy
z)05dJ^M+mqJRmQjiNg78d#Kz_m30O4vGp9EnhyrF`Go79c{TD&iWiL+MJ37uZ|8On
zQJ;kH6gX%cDH<j|?Hsc)Bo7p>w;>*P1b9LGJgf2R3i*=8i|P-o&+ziA!76xBc@MmN
zB!w4fa^U6Af${NZlz7RtS$zRUEkBR1Dn5dF7(RZOn#X+LBhWi`-`%PEK!2D|_iDuB
zSjUm%wRyl(++QcZ<ad~#_1E$FWqQqe4xe8s*C8G;KJ58<fxip*frF!+#4FyvZzaaH
zaki!2vqi62SK{;Q^jhmq@@wU~u$Oft6?jy5VIJZ68JGtwEWCf+J>V14slm<Sm-zil
zcaM+P8aEoHJTdym{Y`HvkKe8ZJ_5YKf5v^!mHf#&iFX`!rgpo?1&jAKIrptr-v5(}
z%jrY-M8`FG1-dI+r`pwc-`)e`<KcTmj_7;B`9E+0@IgHIyw>%VhzFn7y1x?f;Pb3!
zi%P_U&$Hewlq<3x%O5FS8b4!RH%i`G?G0T|Y;RcKlYs9w4hHtd31)BnjTpwg!=I4-
zfPEdT!;3~f!u^3=T4%U(C$GC%KNs!#J6<m)KlbId9&Pc%TA$dW&p%E+`#O%7&kA~|
zAuq7LKCEvF_SCX)eX%`tx~wmJZ&mrA{qhWsfSd9E1>paX&On#JythG*8QnEI2h$t#
zf5RZob5i^$9)TaYiiXedJqz)k;699F^cjx(%0cJ+cFYcP_^VQHGU@sPKC*S4b(rgV
zA=b55*QN3HiPrU8yeGJ?*1G0nUD|Ioj+dNhbo!7uZlRo90=*m5q0IZwq(2kj|EWt5
z_n-mfXKWMuCB&o1fdG#p{}qpT9&x=8uELKdH-h)Bz<nkU0{vm~>VuMReV^c~Z2rGv
zy$U*v;eGu<AEr}U*&o5;-qCK(-w)9a=#1;U1pQ^>rs*5&!uTfxK4IMGA=Eih4&(Pj
zcP94RTw90rT~+<lxr%lquJH#si9hrU#NXIc<-<jzZPYgkC*)6XN8FE)x8wX}xz7{L
zt|#+hxzF|?hVxCs>tzAF!ux8iKT~D>As+9#6ZVD9JK#f1)#9=iug5k1;`y`e()HBp
zo3p!}@CfAeMC1CdEwsl6%JE)V*Z!c`^HFII;h0}5&qbwqdc9Jv3#HTadKs_xK3%R0
zdphJZgdgbK=hw-7A%6g_z&rd+(937GQlG#>@Ojps7+!r|>$LK$&nyo7l@Mxi=ydsv
zN}NYA&pOAb#Ch6&xTwT+_`L3u)BSONkab#7N#UdWnZo(ce+ctueJkpefGR(D#zVkY
zc;7*}Z@zqQbnbP3kk7Y?9t-c^{|Aig<a^wY$bioulIIc6d0t?*`usup-t6{be!ra8
z9*zh36Acs2(FpMjeu6xRb|rS+{irwFL;ad-eL)5+7s{pdd5UuGWFYSmiUGbhZmmyl
z+x_p{iha=3GsUeYhhJ79hxe(y`o;fd%ng5d-_;k9KC;*Y40+ra#J2)Dg!64-XQrQj
z#huJY{8Z|mXy*d%thZu)G~ixdZ$*1Ip+nlcef^{}<V&!C;t=bzLpY}OK`8Gr|5w94
z4eWq4+|&AF6mhU%oofZ(iM-v3-?=?d;>MHNdvAc>HU)d{?5)lfZ!)|+UhsC<a;RJ7
zP(?r8i&FAO={c4^<l{vCm^`BV@v%HoITXNG;1TF&k?Vn-Wpe20Rpd}{i1H?pGbVTV
z{zUGWoMF9CRO0;Wl{*QYmCHMmBcRVEcPD&daw((>p*xM6m>dAT?GO0Ar}a4D`)IGm
z1p~T*91HdM_%~69uX?ObeG}`k3j98e_#IXKRi|F`T}m&pUbKEsPfXDZ<#<9bgnvRW
zN<Vv4Um2YQ>tB|NBLN=JQ)cJ>XiKQ4xGy5Xo9@HOb01G}=nEp>ivypRPt!xiyzX0z
z>4W=%5<SFyLw->A6ZPvpvy#Fg&;3Z@ys4+?KUqBA4^-+Y(7iW3)kZtY59&Uq!O;r6
zMm@D7)@#&L+iU2lZIkM$G#^6l0lsFpp0xyeMdKjTEiR*R^8im+M@Xk1nt)DYJB#5*
z7Y(bO*pZS$ZO5v;ct?dFl$Pf^!u&(Ci}hS-OMQNt>BaYNN&K%QAHl+uDf3AMf3V&#
zvFDCHf0!L-{IUKq${(cTG=ChZu%pOFw6DO|u&aGu`6GXB1%KciX`f$^;t%p&r5#86
zFtOv7RJ^|$e?%jR{dNxcV^sMgj$1xXJfM(2z*ixE%s{+T<Ivy-*nL^8rw*S>$0HDb
z27RMbHuT8Lx0Kr<@SE}dH^F~<c8L9N^?UH+C-O_8k?r&&x-=dg_o+Wo`H+3(L%XUP
zd_w!w;==PW&p`hR|EB!viQ;t6`5N?Ijd+;qSHQ*I_hhAeu?ORLnD$rSJ4(0&af^xI
zV*4(V{l+gAdE|#^r}_cfrA9|y?b1T&3xsE$c40C91&NatMn5m#7Y9Gj>(Xs{ALU;$
zul*!S`}BMBhqUj+?pyeMKkeo+deQjx4c{Ce&$Znt_Ijl7F+bgF9h31>+Hdd4%u;+m
zxkB!y?c!Sg$b*}wCU<|j**PDaV<dRfJY?4WBiEsQbK-Tdefk9JFuP>B`lW`4D`^J|
zu2(z2;BIkSgE!;0zF+q*4{5wK&eu?W`2otK5D$P8_^@{=>TT6-o-!V6{=XDDIsEni
zgwMz8f3jQ`2T#`TZT;HMAzr`sL+t1NVLzn%iU+i>K@11_ui^UBasm7fcr065Ew92v
zYcxVW3dccQ$oyzL|3dVe(o(_jJ{$iz-z<-V86Hmm=J>dsBbRkI2|b0+8{Zrwea%&#
z$NL%W+yl$E%#(&IN#5r)y|#SKe7R1K4?lSRBzd3ctzq70Vd_2S>b1>dfnIaIK7WQ>
z7xqk^_X*G6hTKGD0^s|SyDRfPen9<_qJT~AyXw0W<bQ@)FM#p>b#Zy#=Zr(u^FF`b
zj5)9XJ=7CIN9Gp>d7lrVztL{a2YFl3Cl<d|K7&3fTW3qM&i=2~&ijP(|L|hqgLp{t
zKEy+k_aPpVybtkkIC-C*H%}f1$hy~%e$(p@{OMZu@QWdr>xl20J^TX5WsTbxBgPv-
zx;A^`OW!ExJBv$yA@x1-;-HJMZ(twI$7#O>>kxcfe5=X11Ff)&7<i6`Ro`}K{B1<}
zt&4HG-kr=_MZ1(g7Sk{4>%LLm)2IHB@1XzWyVSo*zdwMZ#3gh-nD^s=pDE<6j@?ZC
zB>GJARw4XMZvA}<PA0d81Wv3Qs+ea0r~lM^=sDnvBe1htzdAKL>o=Q%^{Jf|t`GKW
zR`(r07W0tbc+=GI`R#DMaUPQUMZ$H1FQVOAH>LR&(9gf$k;p$>Ux56z>a*N5){|D?
zFQCVC9C9|~YmGQ#D92{uKC`!j{ITV+&KCJwsTb!RVjc^wI_7)qTa$hG={#1Fw-Pt1
z3?9NqsdZqyF9RMy9D#YOM1Pd<yUO#a=B<1;?LEt1`3_#kd7ygpR~GMz^H`&5AODNk
zkKz2&@cMt3%6=>6TY`1gg2(72@OT&Mmku|NW$UPjOYEW@Jk>l_MLhBE)Sk9{Rh{wT
z3F3dy2VVW3kbW%AVR7P%l`rw<Q}J4h7Z(SPR-9PlRR4?lDeQC$^HVRYBR>UyFU;qK
z^awo^4Qo7Vg!Bq~3HOKjs_T)bi1Ss?JM4Vbvo=l54moX8wS3h}B<~TfqgKA^xffDT
zS-xt?l0@!?&)3RV{p!GDD_?a8@;uP<X}>(JCtmx;a(T>rRU&6!jo)kN5z}9x{qLYR
zYsF&%{bKQ$gI9(5D)tjQa(VNFl)R}ko*L(;G+$+ThX9^phX(pe<hA)BL7x0SuOeNA
zd}Z>+^4`TbKgE1UlAp4Cl;x)^?ocZ)UM_c%Jjc<>Pm%ATmsbaT-qSjZd>-g8=A{z)
z`3T~fhntt`;(IIg$v4DqKk~Ty?Hni8ON3*Rmm=Jgyp-mtCeTZh<)yAyx}ZLqEDy!^
zC3z^L1It4h-fQKd6n_7Uc_`|mBo9@tkE-XP5`DzHT}WSP{)2o2-<ciy3;1Dm=cN)l
zJ%0i^t(})j(Px~OdS`|IDshNFZq)L_Uwzfo;-lwY)yTZm(uVVg*=v@UdRCd-oNC^-
zas2XV<)z3kNnWa)UyeL4^=t4)-Fc~mKVJAB_2s1&A&wW&x#gt{zYlIKw>K<Kv=02Y
zX9?q$s!u1+OD&T7Yv-jNU%`jf<VPGY3GzgDW1fND7ydOrS^f5j;)wTtd1~>JuWzi3
zmt^C-)H1^5u=7$s6~}w>ywsJ1XP$UZ@=`poF3C%+)B7m@lDyPf{oeGF<)v2g`w8+=
z3l1PJ^)=CpQ_qK3Uh3=2(*|+7wEbHvFZIEVQ<J;z+t|pw)Td+}QOWR-&Py5GEiYy8
zKJvWO6D~qrLha?l&P#oO^FQpo+)b(Vr}I*_e#=YQ`j38IDtA$}ywp2Mr&aP&i1V1g
z414+h{_6gu#dq)hdU>47;=AAfdYG5uc?xMe2;=X2Yqj}}aDH(<Xp8V)l9$@1*Or&s
zF4yVtk(XL9NnYw{{b62eU+O)#=(XjgM)lhAQaj|jp1joHeMvoCn3wwbck0Va{nfW8
z%1d$oDd4&C{PMiijv9HXk&Vb1k-$SeA^OGq!5}YnKI%vVxg`3eN?xjLok3n|_LnEh
zOC|GPbUyGwJS2H3;vvaP5f4dTig-Ajyj0U0C-?WW?iE6h73&Y|gj)9SPd7|09`rvO
z>dQ;5`a1FtKVzIWz>DB7$e%pc@=Rlkrk0oZ;)cMkm>|!zu!bD^8-Y{(d8R*LU(6BM
zO`o}aYIf6TxV|cRCfK9k>*vTiJ|_5nEasawP7$wL!*$2`CiX`P<v8<Ay1zciH$`77
z&o|9Pe((tLO}D?nm7PN+e5Cej6v(G9;y$yZ)johcw|vtf=^I;_Z`zW|H~s7KqnmHK
z0`LgpSj;yia`koi{jl>*wBwR|6R)GaTCbh5lhSopah<ls!?eDsC(bvm{5=G0IR7-f
z{(d>^I=(l&uU5Wk@g(p#9d&m$|2qAWigoDz%cOqpd|Ahl$A4eVapJh1+OzTg1dZdx
z`=e6z=A*UtN72p<^_ImiEZ=m3@+JN%@=b%fA1cl_9cJ8D`@mb>)};9+-T&f;D(lRT
zbU#!&-*nzl$u|+s{~vpA9;Zcd{EyFqk1U=<*kyVAsHl<PdI2gRc%UL8qJp}LU=&=V
zfEVj}FpLMNQN#<;C_$q<3+~~GM-)#mnn=_n-oczi6R&s>HHH{<zpuKcYx<dao|$=`
z1@!mh57(Jzrl-5Qy57}QT~+QP;@2>L({S?7qdc$bvQuh*)2d67?fd?4iP`rx&X+iw
zfwBEf?@kE%o3;SF3^}(J<!`#<H|v+b=}yp>72ezXZQI|p0my$PXUX4W<Se98NaAmL
z0QB7i{-&l&w7;nx&tsP^Z<h1EM*Q2%zrMVQ@FV#CCYC=UcN9HsdsURb>55B2{7o!x
zOgxMDxy4Q@ahT#)5Py^Gr!9X|gxo2=zlqj8=xu$}I<M=}CBoli_~!&Xr<5`dY6yKd
z-`{i@&2JmWL&e0qe0=jPJ|R1X;S-{}!6oLK*66t1V*aM#%ol`5mcMBR$34xFxF`Ca
z@iz${h`)*Y>xsW<fgSh6^eg6X;=G6++qtzo0RHylp1N{e#{!P)SWrCf$@Vt|@u>X%
zrX1{lTlidX7m3%1ii0wI+O+_m`u-+Lf2ZQ0EdK1eA)hzmbH!>O8|H7yh+U{;KHe@J
zAB*2q<eb6*n~z1W62HMeXKDFX#4j|*j_2z*zFt>;p&(zE?iacr_&By-$nf!+74iH+
z%ZvDh?wb|V3&bz953G}x6~u3`{X&Gt(SD)lF-}IW7aM0$j}beN@(V41eky#9@(V@T
z@osxAnSJAG=6gIRoENY36450!9<@=tP|<j$5AZwrexdjAzVQpa$IlUe7{AaezAyM8
zexa3gzkpxp>le%67rHuczHL1<$}e>MtYrIxV`iECf#6*E;*}b49MOIup}Y8ngx;n5
zg<d!T><6sZruGX>p#EF-4zXtdy+9$i?H_f1ywg$E_-((Cj9>ghGXC=Wg<d%!%<mHI
z7Xo{X%llf;YwtKUeBUR2q1#>z+M~oTbjyqJ{6gnW4eOun7g~+$&-jJb@U{4boIJY{
z$Vu=EjVa<6dixaZ7wXOS7>?7(*6_9Xg}U*z_=PI*I*woH_6WbwU2nwm3w;7{VM=d8
z9ALTcHc>uNn6F)q4*G>E|7+~0+I~3^^KQrY3-y=~&o2}hr}7KE_NzjEA=Ce=qhUU1
z9*kdz=E3-dXdaATh~^=UUuaof@qKwIexbIR$^1f#X2$ai?e-%0h5qxc^9x-7^iB|e
zGz;pvNq+hQexXex<j_V)r}%!MN33(nN%f}lf0aycf_h;7_(J?bppU}3{?`jI-;b`h
zexdyn&g%$0?xKDn&X=tGLIYngat-M7qOwo=aY*VsxV_IrdmrbEf%h*zs*qpE$fsHG
z9KRRl7y9{3@VDptg;raBp_!+c`WZV^ay~uIpRx;;Uw1MI;*j<NdZ>LW`GrisyTR{#
zu01ji=@K+EB2K_Rkl*mnE1O@4^d8Zpj9+M%y!axUUgJ+m<`?Q&gdQKmxwq7QAs$Db
zU#JI;qjWp%#?($yJ8c2`8|Vv?$Dxp4=+%o!9^t%O=konLd2`BTpJh50i$hwAexVb}
z;uj))zK~z2g8b+u`-OgXak72i%@><}UmCyA;&H?u5{L9Vh`UMP7dq+r^~*1GD(K6~
zPGax3ZNJddM+WUb<QFn>_DT3%;STEQf)|WmIu7Y9(03E~g-*P<Bm6=a{u|c2kvGi0
zzF#Q9-tYT`*iS9_I_>eR^Hb;-VtT-SMEudiS?&blkT@@=<TW#KNMa`yzmVAf#V;iL
z=_tQYQ0{>K6(;Wz=gDJym30q##oOTbYo&EwR~h9OGW@e8p2se?Uub`t-;(X=gDpNG
zIvPG9x*NX`^GyPKx}6`dB7jGhUntLhPTw<rA>jk@3(3559MZSIFBHV1^81BOI3~=V
z9_1G@eEKUq{}#@t$^AkfeGcnS+c#`|9nM{r&oA^>{GO3_G5NTFepSpb)Or!&Cds!V
zexW>nXUFk%z%S(IBQAd)J3C$|$k(O&h0X*%&hu|Z<*_q-{PSPN^9%I_JDS2VJ6`B?
zsPm`xU*Z?~64pseKe8Lf_6zmJ=cD~XSLCf1)H787qWnU~LO+$h6J_6svg1v7Hkp0n
z5a#=EztCW!OKQK+DM*LnexW0Yo_X;?WAVQ63ytCDNFEr!&`7>deB=3kp<#5tfL{pC
z36~x(bV%NO+j?r0U#Qnb;r2GW&V%Gj>VA>qcvpZoTiK<2`%I~M?E10XrSk!edGSI*
zckv4ey-W8C&7J`E1J-L(`-N(#|Ec{#-K_B!^9#xN%kLMuZbF#fCE70p_86W2^CXq`
zN6S5sC!qIE_;t`8C4QlCzmDe@8gOb@|7^d|I9z|mFEo*_#V<4&uXX=GPJ&-(ViCX4
z!g}o&nr(e&CSQwRXgXhuUx>~*$MFk26yX<|4Eay3`bA-R>>zJ})|(Iqe7_LYhlBa}
zU`)_2G%dm}wADq);)Py@bCt?3g?Pf>mviV4e;OF4@(W%6Od-FJ>HjNZU_NLbj9-Z6
z!T5z}9*kdz<{^z==z=4Q@5@W^3!QRdGQZHo3-j~GXucMG<HHr-PQTDzK<@;8p?xpR
z$0tn>kwed~2$w_8A)Vs;h0d|g4=2@|_IM_l-n5+_Ux;4_^if#X_u@F#U%${dW0TEm
zXFYCT?}&;Q;`*1$FZ9`SLBG(I;Lo$;g_L~?=TYg+wqNK#keh9&4q=@|l&`F>x=KFn
z3(tw2kM#rXZ$JCOaKF&F{|58Z?E`g4V3X)LW$_Dr0rXJ&67mZfx%wOUeZBPyeefyJ
zLHFOLSI_!nexcWj(Bm#R_f~el(91ZE()~g!s2$%g#QJP8J8c2G1@N=S`x?Ct<Xo%R
zXXjo(@)rIT_Y0NRKC9<HP(Nuc`h`v_i(iQJd9e?N#S1+J{s2EeUHW*T@fRfX3mtty
zX?~$eb;KXy7rGkaV-om<ws~&-@(X=`Y|u_(@3(Eg&_zcC<rMjajGUbTzbo8991*+-
z@eAz?xS7B&^nVw0gkNZgC2yF2eR&gM@Av&eBnL|I3stb(3HJ+$oDqMt*h$4NB=&#t
z3(0<Z-TQ?W!a6VN7c%^_63-Qd+uI?31D;2%;PV?8<)`ZZMaBz#^DmI+rTc~cP3`!&
zWZTn;?#3^~d{cs7=qXR*Q8B*|eb4xXgb%*GexV>9mESM4<xxreLWWN-Ex@Nff5wg%
zx)b>-&%U7a_44|KZcWF>1@x<8exV;RAE)yRbsS%>E5A^XuS@p}?F4)r+b?AJ`0QWA
z^9#)_;uqS{3+e@8r+Ea{Ny~h)8^-nv&Bf=V{X)a@)(h$xYQ04Hg?d0gWB7%l?07X#
zC$n#C$b28}7g|VkN$nTf9_dirFZ3AEGtV#dDBd@Ip{4ws_$Q>k(GtGz;|bNHX>O(a
z1^hyAPPlZx(1v;QZR@E~exWyJgxh7J{6a6y=t#fNN2^f}SqFZhgT{gVfYyC_ztHQ{
z|I~h=-&o^ccYdMK<HGzd(S9MY$7nm)HYz`l-nWZAwg%!rls!uPLRG(t=NI~<KCFMX
zUuZe5KjRl#!Pnv!dI_&}KR`}`Uuaqpzt9h%UY_61YU?}i@wNDcR`Ip?g;wHq9KX=7
zBm6=;VBNi?bY7bGjbVPFDNr9s`DG9Xe812Nd>`z`Er$jDLMtQuLVuW%%rA5;oU2sd
zM>}hXUnnq6<rg}9c_F`$>Hl?y!F<p>7{3tBgYgT|JQ%+a%|jZ$&|XIr-<Ox-7up`=
za)SCsTY+4*>R@ZW7JZ}bm)}mm&=-e?;}o1w5dPP3&;N7d`Gv0dWw;!=4Cxf#FVx>U
zKOE&3iqf0@wJe$5^jAH;5Wf)Uqp+?|!*Q&?exb(`&g*hL?xKDnk`KZkK#wKQ2K_=K
zz@JxwU&sNu8R-`?^67u03;Tt3L%EtCFSOk93w?QFdHq5U0zDKClV8a6dk*}*-ui`F
zJ^_6((0_|wubr68FLZqodQ66MZ)NujU5n!=-7oZGYR9*~u|8YOPFuik0s2B5ztCa4
zF5zEszfdvzEcH9DzP+E%iS}RXQ@qghwd5D_$d6ufyiiX!nP2F8ZfSm@t&a@)g${xE
z$pn6(KRvU4`Gx)la$ng=?ESXw7a9ukU&&eW3mG{(2!2oC7kVG`-2{H2H>Y=mU+6y{
z(|%p@$dUcS$QxS6dG>zaFGO;n6u;0@(}}Ob{X!yV#4jXvQt=CkoLT?;LO+CcUeqsS
z_~$2huBhC8p~q={OO6+Mz~Yl)ej(<Y68u6Q^9A8iF~1Of@4Ms|3gS`u{X#2Y|C^V8
zD=J>d@aeDue45-ZbSm;yo_#^txy$PpIxZa_7tpVY`GvL%$hV~NLLJA~>&h<_<m=M?
zLhk_|$My>uKHd%X>$!2HhgC=(#U3bcG|sOn;um`7{GeVScA9fwowQKmhxmS>HE36i
z_6t?yt(Uldp_iebO5cgHZ$#PgUVk!~edC$)mHj3!k6b0yTS@H~TJ;g)LeV^O+u?We
z{X*N~ed8DE&Cl6>p&Gt#`-QsE{Q`a=I44}XU+5Ver<RYlo*LyBy5anAds~!W=$i98
z(l2x;j$>W;g*w%h!!I<C`k&e_G{+kMy7LQltqb$JMEixn9;5w2e^U8*0&<e$g<k(f
z&>kgzp;vwp&o6ZM#IXL^exbg&{)}I!A76`KXfR&u{)t~`W)Z(o_J`UpG|u|Y7`_(2
z&`7=(ztAwej^h{lON3wOEv$Q2+%MDz>hmbSOwcd1#P<uGJSylH8uq2JpXzh%H=m!(
zFLWrJt5n~Q@(TsVsr*74KUv5xWcojP6wC+BgYgT|JQ%+a&4cj^(LAK_3w?2D@qKwI
zexX(8CG!jY;k<Z$p;LbG?eq&h2=q=6FSPVLrB|^3K(BL=L&GEF(EdoL_<o^}As(az
zz3JX3lIcyi>hXp6g+Lz#KS*C3$NK9Rnx1f8FVy2M>K7vUp#4H;JZ<C}(5Ex_^Gfgw
zJ$XnWzmSnnOW`>={~Z!9^x=8o@j`vS48{vRa(sFHLeqdA%3eu+A=B@J;rI2{FLd&U
zpx^8M+w{8r_+);e!;8>k2RQducE8Y}IF8c&LI+SgzMYor0>(~D``SD^Z2`MQT))sp
zye@ISRWy&BZJ(undA@y?`u%P43;lR4`Gp3PAD#U|d#A21^xC<}{6fDyH_R{eQw%`R
z>u)Kat9tfrQx_BD>>m#g`h_+GyiDL1`swoZ%P({r=*tT4?ftgx7g{qiD5uCTWaRAU
z@OuKkP&4Se3H(AgovZyqC*i!6E^i+CC#-iPZ;JVaME+3S7|BmrieJb(w~${*<c#=*
z==+V|0>4le*17K&YH%Pmt6pc2H_cW2bL4W+AIt3*nojduvR~*di%&Y<FEp6>g7E17
zdw!uH9+lrO^pnv^{6a>~eU0be!ud40U+DYDS9$h@JiicRBP%8DP3pK;=Y7wX`%!k*
zcg_jlzed?vSDjPH&Uz<}$Jg^>uBQTeUNQgFZ_m+k_Pg(&>h~3#hZ^=jAT;C)we#5p
z*O%>|>WBK7me*na7kANe-~M(ZtfxHx)CoAxx*gy*E%*QUcs&2qM6l<nbz$eTn|DqS
zU&KGv8*rs%GTAR<$1P37=cD~o_j~{Y)9W^jK5~9spZC2G`l<A;DF0NHJ#p4!$?Pm=
zG2aK{mWI&!Ynw)NN$sDy8tG8nKQ)KwnHRToCEhpwsoDIT?Vp;-_ig{wbh=-_KecKZ
z_@^jAN%DA^UR($6tnm5f_yCAsrh4WpiQjE|vEtjPdhA0$z9u+FzX!<I80YAhF9Un&
zjTGmV+OKm2j(=VFwOYoO!>=`n`k#9IyIJF3cYdvV$A<ZhPNDU@i2OBL-hw?z`?Y4N
z{6hLUu_w=17PO~{U+es3+OKs!@wu|Qf&7Dg^4K4S_3sMmpYKnai|f|-wdV7+__Y?|
zwcS3%JIyWP*IEYk_WX91Ti;pA*W%Y&!q?*0YQ^g~eyz_U{90E){?r(LtrsA!Ovwqv
z4?o^%zK^S24-WdZS|j{gd!GaL*Yjvz6uw})jC&xb-ss|>J!3VT3sv8b@@oagsr*_?
z9xde8GX4M82$&C=2jkbGc`$x0ng`?8qIpQ;*Sck7al1kWqj8}AC)drYU5$E@yNLO3
z$Qrz!wD?w%n|Cn3jGvG9>qp&4e|cZx)h@(qZwS{>RdluW0?a4R^9<`{8uT}TU+COM
z(&rG*3;2a9Le_D{xe+Z^dHqv3_B!*&-PXC`q<YHfk0#So#_MtU=V&g*{!VIo2<M@`
zb{guX?xMT#+8Z*Nt`{$+>rqtC*1dz~%^OeWp6at?Z}i50h0lAVHsJR+;dXoA-#oe~
z+}7&@=54Qp^R}-ZpYQjnr}<EF6!ccNnbwc?`|SEu(C_oCvOlJ&A9T@(LVh2!eqDI3
zfZykyMvy!E<>A3x%kMKC>TZx4Rv=H@-TCeOFR1r}T@vWuALyazMt&dD?@IW6z4QBw
zWqopo_hF#A|2DmjJT95vXY(TTcn8k4mCf(7KaXRRym3U?&p$hq<d)>y+8X3b0{i*>
zPp)6~^M?VK70%jr6x)8@4c3w3SF)cQe%%CqPhdZP>fquyr}v%ro~`ZYPmuk*h3l@z
z+!uR2ad|p*oi^h6fAKxIlim)$54ZCSwd31^lG@?PKG)D(OZ8}NIx0CHRnKM4+1frd
z>>C(Y<J1B8*UeG;rk+beJN%3qY$qx%tRw5W>`3Pm5clf3Oo_0=8$O(b=U>C^o5}Nb
zozC-ng*Cs${JK1!1?+vGSH+3<JA&sG{&_|Hx-!oaceDQcb;-`>;QSgpAL*|(6^=8n
zpkJ5leDI!*OVV-*^d70#S||_Xh2YQg^FYcu^F5L7x;?W08Gf4pdSc%B^nLT*gLC|P
z9ozQ5EzS<gSF!&s1b%Lz`XF)ToV#cR?gR7fe+M!@?}GfS^+j9$N7>Q8Zb;_0{!fGP
zTf;n|-e1!f>639flN@hlInH`o7q0glwO+j%eBG(*G=Rs`J@t6rPB@-FtMQn6ZfIT!
z(9_;GA$?_^qUy%K+7QIysC`P*KKA#IB-^L_vO(>?{C&zRNKm(JCD{`a+fzsLJiPTT
zG-Plvre8$j&)OLOl%8SxMeKT2cky`OpJ)3S7yJU{O5=>D@voaSPG?RlzUNI{$nR4f
z4KF(%uXR5uPcH4(9_d1S?#&pC`)d6h;J3&A3dqX`3&2}I`#x_0@4wafNj}p4+{j1T
z$LGsO+s|mrNAer#_QUuT_!HzQ>{BWa3G*{vi1gO&z_?r`7pLKQ%5WTx?`Pba`RZom
ztKxS0Pf70O+3Ej<_l=!?H9u$D>EGk~ww-<z-7jFL|K}56r~e+(CApn`a~|gmT0g1v
z+ReC~25d*mcbsRDKfb-cJIUX~cI6}ZJ13`G@1hsQSnt4Bz>koB2KaFoUhjnWMf{+$
z{^z7z|1%P-fAm-8t^Wu)Vb&$C|17Wn?8rQM(GBHAv>!C6AK8A;Zh7s6t#|DQ{S53v
ze!S_bZ}8lUvIinQsr^WlKWNRgWd5K}rxmZmo^g6$h2(YN$2s%xa`<t+c?SeU^7U51
z>+K7A-_P5(?)*6C9v<c=iT2}weMtLpMyh;38b^S?V4d&(M9@A4`V-vW_lbCZoSN}r
z{j>czYf!EmKaPXz#rR(;L)Q=ZaTXTw<6I8)@q9l{Uv8J}_1WHhEq<IDz7{_Yt=l+$
zoJzGn0yzm06F{fKA>U~XKh8X;2c*`w#tFA+q3_3e>A;{L2jr5EC!HOqH-EQtLoz?k
zBXEvWeIMlu<CLyv6d0%S<DCC+AwQ1k|I!0tK4>0{ABX0__;F|+j30;QA&npBq=Smv
zx7H^=&LHS-0zb~))6_nqfFEbY<N512<BaPJa!}8^<~z_&#E;Wxo%2n)Kid7_Wc#CS
z^|<`~(Sg|C_0f;xB%HU59-r^W`2o#`+INs2ht`kw<NW(Ev+hC8T&3*bY5X_`fn15q
z>t@#PFnF$jALpED;eMPomLF$7sFP7fKh7GUhoT$#aZJB|2fwekew+{gf$LE9-=<fu
zW0LuC-Y7zkd*J+6+5I@L=8YrDkMr2bpdaTS5Equfk2C$T^~;ZQ;qajS$hPCzew^PQ
z5VSLrAII?PtMI$+e~@(-Qa9zt!;9k_=m!f~KREZSj_~8$fb(CvA7>7=liH6%@!+NS
zamJoi$d5zqe;fTctHIyL_Vs8#j^V?;cuq9jeiUUFb{9G5Kg+MbB7U61t@$nH$Km-D
zdqqpWeG>GRIDVXJo>%x++>ayk+yQ<Zv{S6X^CGIASDu{$?5tj%ox&kMV74;v`QF%W
zv>)eowNLS~d|oNH8uu5C+1}V*Is7=o6`xfV_2U?R+Ya=^7=9eE^J@Et?Z<iZ%%FS~
zKhCMZ&n;vRj_=1Idrq_;=kveYdbBP7qx?9}o|(*#^VFGZ!;kZa)Z@7`;dmCS@sz`l
zvjFB@ou`P}r$p^zZ+j@&KIQ5&)&9%hr-&bi?1kz5IBhr&1_wLdk8?JUhvcIbFD7=}
zwc*E!X~$(h4#}+;ejJjI(SDque6;;IwtP(P$N3%X6Meg`__w3{I7TiG!gG+}IGo&%
za{}^JaX-#@w1?&UagM|L#*Z_OpR@fqWB9)9$07TAAwSLokCwxavp=n$lKnV?^W>pz
zC!x5F%}Vs+?38Z3i(Zt%kMsE%TF+g7{5Z5uZ9h)mJbj1cgjtuCA1CkmV^OXQ^Yt8#
zXTxjo;|AA1$rYm?9h=u4@`3Wh0Pbr)&SQb~p5BkM?2Kf7oJY@y<Hw;mBjd-o1jpAn
zXBPf-Iq!I5b|zoTI-ZW#-c&kA?JeN*)2v5&Ja66%@~3ILhWHQmJhU8soL{~TIF;Uy
z^CZ2$9{6$gJ~Yfv0#%5io@IVK4%mmZA7^uwzem$s{5X{mXQAv%G7p(YwIAnf{9c|t
zSn)U7G1xBvcE>B1wzoI5JWc1`)%`D*wzpSxIhWc~-<{qb)Z6F(hy2R3*)DO?86oy)
z_5E>cjNMcFqbI<7>N_jG4t{6(nxOx>&U${0^*q#>*X<u+J>U16VEa&iL_dFs_53*N
zdB{tppFhxgezx^I#I5S*_pzQ|YCR9<-1PH<tmogeo`?OEe!jo;e2q144$qsM2iVDa
zex&t0@QrSN2aspEHMs8-dlvjYxfA)#wmrjfGEVc~kpI_%_?it4NamO6%D7rAzUC)O
z!`J1!r4VnqUHE!b=SRdpv!8X2JjuQ%<7`s&JD}gddLIz;J9jHP1NaFc3l6;h=>y63
zSF29X-(Tr<4txvko^H_*_#f_1vF^h<g8Qc+eTNYL4Z`6&%jh_yv#gq~yL57#RTV+G
zviuu*|3S!CoLi1|m^wcnayO!*@}o?&)&ab~jL-D}zl%NgnbU*c=?%~Ed7zrkj&qid
z6WqXYz*G+7SON5Gqq@#@T_4XomyO?JzsIsh8W+6x6x4O``@fjp<L6-9SZ7MfQ*1}Q
z|8U@a*~ieit2E<ZRAl^ftnrI~y;Y6Bs;l&40nLLN4<Kow@!T31&k=d_m|Nui8w2l4
zKho1<RuOtc)z!K@lpfRb=&`)WcxD8~vu_?fpm1X$dY&D4zjS(>ScD!?c@9nvrN=RO
z^ynS3&NaV}3yfzMq(_%Z#~Bm$UdVbI6L|k<d>`zraFEJld6RL*P`^^hkD*2Ab9==4
z85W>Vt{wW5aR#LBM{SXQMCD80Ezpk#xF6f5?nkd8{fIipy>*};&u~A|%k|14{Wv#b
zUN#N%V>I?d+cjs~`YPas#AkPQocW9oYff_<(HG!6Ke*iGJdb|vv(p^MqjGG{Pmt<C
zJ8CG7sqYDneE{E6xPdrE+X}?7D7)(?_qVsZt%PG$mA9rI?;m20_jMTW<uuTY^S5^R
zKZyB<f8MAuSXV&w0<U%))fvc6ru%Aqh>JWvz}3T{e)jd<u&%9_9f{AoH&s%d+v`zm
zI$m}d-S_dg3&~g2Zr`th`->Idkp3+Dq$f{<b()?pe{Rncd@qK+@fgh$?*Hp5FQ9%a
zd1cpsz;P&jNBVz<_5Ep3H-f(pd@0W@w4Sr+y#dxM7d<RK9cABgBhoQFPG4>H&!%J4
z`o13M*hX|Tddts{|0d;*Li*NcDPK)Pj_gj2*~{>pWJB&qvcF_kuYngDa%1^=4PTGp
zYlr!a>|kEDlCR1B<z>6^HQB$s>_omMyO)<8OxLaXb~k$-UWI(HCCo#8iSsa_$UH>p
zj}t@Z;dN^sD4&p-hpVl5SYpk?QfnTT<F)J0!wSBZd3cGhWghxk^U#m4X&$`nN_<|+
z3wu6tf%)hiTfWG;=#TSJi*(TTpwRU#`%$%ScRUTx-3p(gAHdBm6+Wfw7M7<fZrIKP
zCvspLY>(e-qV~Kiptlan3*2W9q79t)1JG_A$LqNQ|7M(vaD%JmR4AS)IVE`3tq5O5
z=~Y#se1&B#)cU6UHHNQlwD@W!&a+wHv-w)q_gv;1S>N;dTKH-qUkhK=SbWvn;;UAC
zz7Ss>6W}Y}7sS9V;j4G10&b1Oc`<U1=F`yObLJP}cUvwI9=ray2(Mj#+>E<ET?lU*
ze7ccbGjyf()zC_EwGh9fUtjV2WY)7@m<n>3`^|ja*z;5#CylSZXFXnPeuwu1_AhSl
z>8Xy>cm*Bwa&y$b#-8+HH%I+%?8)}w9F5QGIS$)*b2NUhC+#QP9MQ+?NpyE}tk3iu
z#?KRdy`Hf89LKwv*OkPH`sY)>-WYyQvyNJ(T6&?SZ$#~9?_Lsylb9|-@ek#FGW>I^
zwT{LhUz_<J$JersCh|Iwbu^i;WgSi9YgtF{@wMROD!vweosQRfUD)#ZBgiM{<K?i#
z^7%qsN274Q;;$oFH_~reH!?0+H!^O~Q-v<PPJFr%P8qt2JRyE6Wj#$Q^Ljcqu%1Mo
zP=C$3qVbq@MdLN=O4gaID_Li<u4J9bx{`HPY+cPry{`5yvaX``+xv&ED?FALSl@8|
zO#5GKeO~1HPF6n_LY%$Q=jFLR)^ql{m=jnR2P9q>SzH&R*Ydg`J~HcqaMr8~(X&fm
z7vD@NFV1{EMdOUD3+k^~7c?HTE@-?Ry)N8l)`Qz<9cG-bH%f~?zn@YVf1>P%f4VOW
ze_loY(l{7*o&3t`$4e3G<Z0_Ud!6hMSSQ01ualoo0X^*SwY*M<ugp53{is<dvR^HI
zo&2=S>*PAUPFjOF=jN#2X1&n3%zB}5ukH2Xw$QrGI2WZ}H`6RWwDq<qJL<Wi>t<Q%
zb#tQC4+n551YgEm&)MtdDXe2E_M*Ot*UjO$ZrDDq;w3}ZzuG4V{*8eC>GP>py;R&^
zD7&ic2lkr+=LUJdtn#zi`(^pgUhp0D9PTsNP6_*TX?Kq)j^oXTx0Iii^TPOiZpmT8
zSG`j6)ehD?*?bjcC$0_UtLIYlRS&Blc&<EzuQmrdO=UZ-=zUqT^ZNU*EZKMS^!_`r
zdyd;g`k?rg+{L6Xg5CI|p<pjb&zJw3to$}9`0}&K>G<-)$;tTg9r#WRzWm$dQuy+j
zu0U~(&vETNuR#BlJ;Ub9W!AX{Ff76R{r=uCJz-ls532hSDkqfPN!IVvRzDzqA&f7d
z06KLbUoI$-FI!9G%Y`ZV@}~*;@`jjvd2LC2c}8l!yx8Ign=fCm_!7>w0$*Mh%9o#{
zmX~K*{ebiLVSG8IgZVPMcWLsnu0*~(EG1u#NXVDN;5#wo<<OG&vM2GS!i`XQsq`7K
zkMC^p1M(%ur^30Vl@?#hxuyQ0eEB5trRqnhyj1-VdAX(44~YMket^Cs&sAH`!8l=^
zT#EVdC!!x1;wj)rM#lLyMyR{F$#~z(E=T``o14bhEBJakUz_vubPk>Bo@+dr{|&_R
zQ9XCCuWknR)-2V%hx6wH6}`MH)wgfRy@z)C#_W7NZ>H&k^j7C%@mwkAJ=1go|A@Po
z^bZ(sx5I-thx5(z2ET8O@!?Dl|6JA86yM;}gW`h>Jyu!tpg2S?`ySt)$#kN)MK8OW
z?zc@NKLq2Tm!<Ez*HeN3FH7`yuP1-EmnHhU*HZ#QFH7{-bhi0-<yYiCm;5LvPKG=M
zaH=b)_uzY?f2%zA-60-Z@g?pnm=8s-E_6=s)qCJvfb^H_t!6wNXW);Q?8t^5<R^A>
z5|2gpSvN=Y_OfK3b#p{#FH3f9H%Ii9^Z0t-f#aky;Z7IG8w2)u9=GO$$3V_D^S*<}
z3+G5+J;}IXeTh7{^HjBu@Z;e;oJdW-xa)f1sloY)yI=b0smb)x8{j)J<m|PlmZF!Q
znwkz5r=-L5gmgGNCLPWwi4F&*ro#y->2Pd9I*g4;htY-T5V3ETeRam!2I=6<=|}#f
z=IJB{)j9)#D{=Pno*(ZALLKmf&kxph>V(gO{BCDlgTL<Lnbhw7^nB60u080vx=xbs
z?B67}M-9e)dZQTsrZO%rAbH)8TY%s3*ss)>orCW+wEPtBH_o_{u5<JGIr678W@qDl
zH#e8>kEHKp2`}8-Y<ZsVhs%2y_gxRPw|g_lFH_a!4IGHexCZB%5tsYW_yB+5dKtNC
zovKa<Z+IX6xy>|QINuGwWSrNipGDfU+cEFI$m67ae`9tO<0AF9F?$GK3tdF63q3^c
z3mw>RH<kT)3kWB?kT^Mz??9i+Ax{X~fqZ)WAV`ns{y&sz{N6@=ao!9a?y~6c0qQkk
zS82??&(}hS_vCk;|5frkU$4Y#Z|Y0*cg70(yMXK|h4cczaiGi9!@-|y>wjdpaTgJv
z>voo7K5H5mynmv~zZ7_m+aLEpFwR5fqYlq`l7FLaL*l=T^9W9eZU^uhzO(C?uzr&L
z%jjj4r`_mf4#sD>zMfi1c_*0vy%>5b#Yq}Hb$F<r`aZ4mGU}<1k1njI9=sInF1DUZ
z0Ud@O-FW<>x7S$o5Iwaw-?#PDzI4Bp<@7Ak<46v<vn;)I7K(MFx3XR#daXULT7U2M
zbx=>;=v2^C$zYtPzlG?jPYsKwr$(Jiyy))sb~8TKQ~mL=p6ZW}^;Ca+qNftQJzriC
zy^WqqbT)b_(KqAV$?G~uf5W#lPlm7gJea>9p>sA`&qO_4?T=<dJdWBwLSzK2tD{Z<
zdjjoC#Ln*3h@YSNqelGv^j)t;{QP_#t%m&kT91SiIigR4o-E%x=oF(zHcpp3?A2Xh
z;p_gRo-Y06e8JG)SuoGakAUN}^!Gyhk^Nzw6X^B3oszHD8^3G?_S<dZ_2t*W;(f7S
z2kT^#`**P3FrMT|{iv@{Zq)OB*Q=%du{VVG&uZU=^icDO`vIm8&}DP5SB9J`#Qh56
zw%)Jw(BlfppD6Ns;r-$A`)7F0PyExXFoRiMf7Sd+yxt)t&R^Gr^Y@=0<<DQnc^>;a
zsp$fom-<>>?~BgCYi|gz_r<5v^(bENchEd~<7vIuX9;J$@y`<Oj(U;)4tWj#*4O?C
z|K`y}%_H)!n#VVWB%8-S>hbyK)$Yadxvg@pfzLB<LHdrb|4^8TuMbA+KR41iSl*>?
z=PGQ+&C&U7(UW~Yvab)5AKB=^>_=wY@#e4{gvaIENpgf!f;Vn6oeOWAO8U2rKd^3w
z1AjC9t12Et0!h2+$9ZO%==CFuUZOYixO}~t{qVltEc6q-S?I@l^Bm@HpI(e#EyO2<
z^ysZ14<>R~Df;xNGSO#$i$0=H3w=bN7W#-jE%Xt6TIj?2^c>Qsg%7+e>D7i_@%8K8
z2Zrgb3kWwt^lOY?R`y7!`z7?&{44VL!zJPJ`TZq2zro3odi67yN88r_yOR9y^^1O%
z9y!?3BZuL2DSGwTP`&ztM0&NXW57Av?mHIfsQjCVr;5%uKpm4jefnmL4kIl(jIrn-
z`t&%yAJpf(>_ocXL~#u6ww6A<t))+IYw6Q0uSLG)jYr|iNK2ny_#@D#`x751{R!z1
zqE8>aUr-;@I3@N^(6gfAOM2Xeb&qhLYR1Vp>yMM=kUvhwS$~|OR}<ZhUQKj2dNtA8
z=+#8$jI$roI}d-AUPAecFs*;V=R|+$4|GxVL%M|MpHcgaf87cB4fbIEApI#l&g8fq
zJ};OW-zo3Ao1=IhgUb}ZV{n<`cML95{EpzV%l+{E6mpJO{1`dn2jO40nc{^C;qw@f
zZ$3Uh!T4M%-DZ@DZVlXy&`t1}$K~U*&{6DKLPx=8p(C#kpN@jlLN~!_8h;_2?hAgK
zl5x7OOmrG;(MfPx=p;BTbP}8vItfk-od~B5odmC$E<Roh-QweQ?EztUy_j$y1h4x+
zJhH-(uOVMN(_PDF!Rs&X3&-ov?u&=lzd0<df88O?h_d@kW_pX=XBuDgzBD@>uS>z}
z6GHL&pJl`A2|&jJc)ca$OU=XUoJEJ379D0=bP&9r%lB=(X1Ulz@nHtX*#70?81F}X
z9Am$&k7J}?<&8(-^-K$|?>rgsdbikkeZsy${EEWssJOkY?*zQI$C(zdiS7okiS7ok
ziQWdUiOv~^`~c;|>!CoG7<jGqn2ghv>@|GeKRvGA!+s5pKTM6!i@6<&i!}I5agYX|
zDGt)$GsQs~e5QUFeCBut;ny6^zrkmUyDWsy$Adh}!)HDxo_f5Omx*o{T67b9=5hJ>
zEOZon7CH((3mpZYg^q&HLN~!@rfUIz)E@gAoJjANnp7q_QNBsn=P$u$p_AaV&`I!F
z=p^_obP{|PIte}tzsY`D=oTNJ2ksw+e@jU2hv4&M3!l3d!RJm9_}qSPJbZq0bXfnk
z;ksdL|IJcfLu1dUx=hC2zocY*J}nfVKP($Qp9*y=3gGjmKM%v_dn`IEweWd)1U|2b
zz~`6feiOx=b|gMSJrA%e$T_Nq>yzR0)P3UNb5uNVZ5!aTJ<hcFOmsK+OmsK+O!PMR
zOmxmTbr_#sPJBKX=n?~;wce6(s@U$w@yDrg=24Ef=eXw7?JVJTDBjxOGsRaMe5Uwn
zgU=LSZSa};Vepy8XYiTk-{3RFa~Hzr$@gk}ew_EurP6I)ndo+<MK{4`9+!{LLPx=8
zp`+ll&{6PN=qUIsbQ64Lx)#9aVc@4KdH;Myndo$~MJK^$p_AaV&`I!F=p^_obP{|P
zIte}tzX?7I-Qwf(0mH)Z?+KFoA^42-JJtTVDxw~e?4LISepa|6=SemW;4|l&P|ty#
z6Z}2@z<k5Dy?ZCDKW6ORD=l1FW#Q6$cwNf=d3q>5e^fSnZX8({pHGE)4|)6NM=d(6
zw&*~0Ta2C}`)8`l;^yt2D@jhbEyTPO=3Fn)-<<p9{c;KCoL5`;{EL$SpLdPDe?D*T
zc=#NZS72akInFr~y$voCy$vo){Tn&wO!Un-Cn0^yiOWX=J!0Up)>kqP)q{0&t=Jzq
z59v~xv7+ZM-9?;7qB~BTI*0iz@lW#-`pf&xqUSmN^PzH%@p0<cRPi74_n808dCup#
z|8hQ2&U5}6@0;_SE95!!a~Pao&iCb<9@&-L+)}>J=Sd5k=WMtK&U4Z^z^X1kXWXX#
zrq@$$!SAO($9V(2@1NTgyq5Eda*k8zA$Tox5WJT06JFcrINcVWmjd`adOygcPv;QR
z@1NZg>Cs@(LvUH>A-F8`5L^~|2rdgf*#FGuIsN=ajK@jNb&lOH42NGJ`5uD9E5C;Q
zg*n&xeZY?bcI>V03CH2=J$j!Ujl-Xh3hUnxJlSn<xEt&FV#luGYq4Wf-po>P_{X6*
z{BhZE_!7t)Zs{Rf-?{U_FdSZC(V?$J2dT>@bPyaK%+J|&>|u1j?Iq&Z4vaT~e5`t(
z{PLt^IQ-+G@o+dQZ^=O|<-lR0x4~hex4~hev)LaLeKSr2@=ZB$xE|;c1BbO<l5zU8
zU2rANclmJmRUDt&yo&fJH4Z<I?G(r1FS-9V4*wVL8yu!O>K?~W7#v>B?~A+@9Da}Q
zi`=DkWUo`$FU-8VBXIamq9gBn{PTELd`9$nye4{oJ;31!`<4TTDb6K5Jvh$Cr^ot(
z!xQ%n!?{0@d=J6lZr=oPcz3{$0yw<$-QhUA<K6LaxN|5DAA$iH28Tyl_%nvD1%Jlj
zbtyPJFBFGAK|YTgS0R3=u=8Knk0^}8r(rw_+Xei%-``twm}t>qvPB2M;c0x|#^LF7
zzs(_gP6y)fL<@&kO-zQvHx7x1!%=yVj&3do4imi%4imi%4ilXX4ikMd4*5yTiNj|D
zJ!0Un)=M%D*TKwH;(V76hu@-eb<N#~k5c3Cn-oV@bU$3n{kL&=N4#%vxUW2C?T35w
zeH({s_<nI5zV0rK!<X{9EOkHpDA6%B4&P7j`?$02_QT*`Dt$kEbBXl0&Z5WqgTrU-
z6Nba@6CZ`(@JI`X4*>iqfWt%Y3diBWcWE5%kKYT^Gq*S-tbdZ%Sp3E_E&Q2n;m=&W
zE`-C&tUMfcd}FW<q~zgP%{aUa+t+dx^CzftOgb(p42KsUR2YZ1z_=nChu>lQm(YRo
zff)b!LW>T9!>xSZ#^EJ&zm4i!cO(u&-V?na{^Uf!Vcebt@FeOS_M*Mw;c!&mxcWQF
zfx|>^gTq8`gTq8;gTqAMjC0+8VB*%tIIA7^NET<c>xn9kjN_~%4p8zF=yeTwcwqmy
z6wcL2J_OE7sh@*9Qt;e^cLwE$)NNm4-Iuy=_gMEKFC?^cr*$9ltit^k>ptWuhWm@5
ze~Z{3Oz9nQKMMI1yzR*j@3Nn;t`nw9a@+wFmjL@#dXBE^I^i)KXBmYVVEzU;F9G}y
zPr&#7v>TjL&G)xsJA7WUt`mmGIPMnKcldl|T_-eSV*3z5s@s1F+E@8Zuw4qXaOx_k
zJ&EH5{{j8Z{jcCS0Dd3hPVN3b3+?lHfB*fSL?^%f2JW}C-_vSe#ar0@UkdH>zQBLK
zm(@P!%Q3%O?eqI#{l6R9SNbB3U;HFOpGj8#tF89=eQ4kA|3YX#B;GLX{Mz)t5!>gu
zMs;2zZToirXJh-EkE9Ik+x@=)+h==48QQn|KW#Tt$IAA{+J0MupXG}uzw!hXPtNhk
zrXB<1vY$7e<H`NJ@f=UidE;fB0G~(2lY1wax(ylUP&~J*^%KNZ#ji=@eI6Vf#ObJb
zAH5IGIJ4M3H<<S~Tz??8AC&Xw=lMamM?7_#d0(m4F({U>9^r3vo*eOmX0aW!@8j>~
z`9a5X|7o8k=b9Q?j>G$A-#3n*6Tg?_wHd?rX+LPrJ&ly-alcT=5BgG@&TDf63PP#l
zq1O+LTku2l-)Q^kmstNa{l4#0dcTA7*|;q{F9rOdcMXMoAMKyh`$4I`d3t)hWYI(R
zePS;VKdA7B_(6p)#1AU`VEaLZKa=OTSu!+iUq$tu!uEYLao<Pu1byYw;f42o7qkWS
zHaU;vw&{HzC7{ZaOKRVQd2V?<!*^G<LVa<LTUYnbY=ipZ2jV)=?Jb0S+R8qKa?fs`
z^$uviPk&P%QQ|rEK4ts~uusYVjxA4L?E?9s_M~;W9^}EecR(_|{=pyS>-Abcmvd+P
zMa=WwZ4l3SQQp4Trc+Yf`TL-FxTE)d8Rr3%r<yOq`holvv;DBV&l#sV{5y)@Fh8#1
z+lwOjxd-wy*C8yB@5FBJxBY^4gyq2hY{%1lT!DN{idJ6x+&{og;$znT?S81|q#pQ^
znDh(FPn>ZsDoQ`h<ErTAMbPiVR*(m@VF}A?)2)-^=y`#9lRzJ-FL%@rp{@$mS8S}N
zc(X}4s=ruYy%VnMh8)%XYpgyIuP5cGE?|B21pb}sw>4H@$G=m3xBBX<_?qfe)mPK`
z<Axm7scNj|x(GZ@(DSf9v*IJzr$T=vkL^A`G;#}`$9l}_dD!pj=LcEOW4&YbJnWnG
z^Zl*ovCgr29`@h*`JJriXF^?M^*qRR{rnEr^GmGffzS2x+gQ(IU3S$z@QHrD*AGGe
z=5y%PlFx+C30FUg^Wn-l;p(M)&F6%xm+&>86RvLMYd$Aj4cShieLg2#4b^txn$HPW
zQ(jp=j;MML|ITql)mQR0#}QQn7sC4-M^rtNuQ`sWn(BAE5=T@$jeqAjB1meC?{gec
zwbX^<c<k!&{5!`PS5u)|SK^GT#lFgM#?_MdisOu{CGQo**L&5H_lo0;t10i5AJ<+D
zTngji{5I9BXGlJh>K*xa&PT#|VqM8cQVqLBc%So;RC9ia%PB8}?5kxz?&l-n{d>lt
zb0~4-S4~X$6_&?3<Gh3W2dNXh3^t*Vzl-|;b|I8I>fDpy=v{E$$*=by_0eg3x?X^-
zzu>-0>>4WX?&HS?aRBQsa~+F9dBB!8!MQ6sKUUZE@w|E{_`Q&N<`2WUX}|xA={<f9
z#*O*5tZ_@-3&7ob1MkcD)7Rm>rO5boT<aqnfKEqtxP@x`#^1ew=249YR#c(!+!z?o
z5qb0giBRbMs{`+sP7k*TJ@k2HO^=I0=|S>G(*yCT!2F&a7!TJ8RrEx>D)9c)!26}s
z<Jcnf(Ee&okK;q>aZDb6Af6T&&zQh?c0vB=Qt1$`+V6#|w~>MOkH+_5e-E0Pk$WV!
z)5wqAi_k~MooV_E4$voub=xyiA4$~(k1NNvE7A{rzEAh#2Z4S(!2KXYdYXQGuSh?%
zolEzlI?#`2xF6}|x>KYdQTcT;fqsm}e&~JiY={R|`V*X2m3=Yb3TQMSr&mu1>X~2x
z*ZX97?w=DJ$GZuah4T~o6Zl@}{EPix;n-X7J+&SX$2eax;F#X$X}Z6gYj1a33CF4`
zZ%sYkS7MI$H!$AIX`mVBZ)9&JwaW2Ek>0b6)FQ{Lr95mN*NN5R)A$PX9s%dCuBW<E
zp46GWiR(_?O!cJ<?&jCKp9p#U)x54?zpLzX9-aVpiuC+=uQfkduPlb1@gU4k8^zbx
zb-je}QOSqdRvk1PhthMT|F>D+ci=r$uS=f$Da?;w7fIs#n65L5)#;-7T6QVTue+G$
z6Xs|7uArAv9AI4n`pdrUa-@HHJ?A28{5Jh}eTRIH@DJ7p%rx}-Qbm8G=iG?T>3P8V
zu8M!`d603OVfCZim%(|E=O%a1JRDr&Jk*sq4~JRfx94Hsh<P|NbRHf^Jr8?Z{TLQ8
z4}&^r9;yTL(3{q^lHXDCNciLXI1jWx4B%6kJWzNc>-_&Fz<QLrC!9CWuY1CA&&{+?
z*Y*{xo2cp`N_$&id;DG#wddUgy(RxT99V7~NE<z`4`{)lf33j38E0!WoayxxihD|~
zN!^sr);!w$6lOnzbzK?CPxoPebU)&*>rclA@poDTKYe69XXDsdIKSk}$?qrTi@%Kr
zoXU?|4IPK#3*oCbp?_qyK|R~%r@4TWa=t;;!+d2t)O{$<FY=ui;XBH1hjlhtf7k6k
zHy-pO=A#PA%PDq`jI#_6a_ISr%QsJ0^I-E$lz#a1LW9Q!4~TCj<*vemS@l_pS8m8%
zhu4kS#TYNrkeh?oUY6`r4Y@1%n(R*vx!HV8_9r(tldsAC<mRUHHRZW;bJO^m^3=Jx
z$$U-rCpR~dugN~8<%`XCol4}pc_s4QoRoZbX+plcFecwkFUWV}QuEyzMffht-g0&*
z-#wjLUL9}sqcuWa9cw*j^UdQ+N|RTImdG~;LjO|8tGyHQ%|Q5040+YRAm98K<95=>
zt3K8|*zzjM&ahJ`-#n9=Z>p?*tc>8BZq{=)-<%WR8@6*L(0?{Sz9IX%k-MaK7`eMM
z%0D9qX@6qmB<)X(9OZL`zMK`gDsq_Qs*%$qSB)Gex!ll7a=wsWhB&J5SL#Z?e;oMJ
zxZjMYjn!0WX;O~HS6|I>(KbISy-eEs>v4|LcsV&Xjo*S^blGpw==(jyZy|mS&VTCr
zHN=l2ehs3Z@oVsYo&6foxIHuVI{4*rK|RY}2T}If=Wh?g?YmO1gNLksR6^ZMwVxI}
z=RWH>dmVHStb;y@^}R*Mfxbujk><C!`ra+jzZCNG#^aLdd)LBuY<>;V_pUrHTHkY<
zc|EoepJtqGQuEOT*1Xt!6lE`+Rc1aq&FaVC2tGQ+dd}vf=b^s4zi&v+N8?N6qa&ez
zDfsBngnV=md?yAU4NJsFuTor%va7}2N9=CRi_J$-{*l3<e3agvv7ObA$q{_CmGzv>
zN3%-gqwkf-M_r+RDfp;ULO%LxTs%Jd&$uM==!(>Q^a1oo=|46fMfpuWxh)LW{*fBj
z-n9BLKZ1{5v!1j0XmE*qv|?OoxV9Ynmx7NT9hVH(9)$12kVp3>;-jId`6y@2i_J$-
zexT-1KBDthS}um_70NCrde2;|A1fmG=qjK~2lyNI*;)G=lH=j@68UdhO8%RYkpJpq
z^4|%G`0qWE9|g_><9b*77qQ2VwdNi9Px&Fk&I5rx_88#5X7Y1YZ7Am!ZqDmRDF3N`
z2>%VU`mqN1PwkK7xuHOBK0oDhyad$sh6M<IAoyF=8J8no!#}r)&R=;Pr&hN?CwvaZ
z0dYj~*Ih*Cu-rZHHKz-=_eh4@-GJL=*ON!brJcG=1-6&r`oRs0Ybkzq6z7p!Oy|iO
zM{%6QVm{9{iu2Pf=DgXXIKRda$$!Q1ueB5(+t9otwOgRRS?i+q_NooZL0gC)(2vFQ
zfcEu8?d=WCeEwYBzYW`S^XApox9s-D?G!v0*$@02YTn`G8+;e!NtIKDgw5-(Jnx^^
zJw2}<arx`>W7FZwN5>|^mv`YiG4SQBW0UA9Q&Nxn^_1iOZNhP{h&k?O5{>)dym2Gn
zDZY^N*<V3?gVG;R-m%|9<Ve){z>GuZG&TRl<*T-o^lbwAwz2<(@fglG+x|L{d$+=O
z)N@h(mz#mUQ{XKX=g^D%co~Pzm+Emw(ess<^o;Vu&-)qRL%x3rdZz6Nf<rTpRsH32
zvRc0eJOFvI$s%YsXjjnBf!+eoby*aQ(*eC0?r&h-hkX~^udwdJz8>y>(-dq6>_%|^
zf7X4ltHS*?)_t(k!~K85IVI*>m}iV%Eg_EBjx*h@Z^y>@ZV&C}rlVg>$Kj=o!?pVl
zA@(lEA(W$iJ5F|EY=2~j^}qcG(El-IYv1nwXV`vC+1j`1|1P%QyKL>-{r@AjPjxuU
zF~4^Ie~0a}{?-9;*3bMP-g!Sfm%{5D*8QJz;d)hL6X<DMhU1$$mxSjMRC}*Rv^NFY
z+bVH;+t&v5v@sES+A+t1p0;&(`wEXKu8Pmy+4~XooZxmQCeG+{Mj2-SokNV#{(m8E
zEQVeXcJ3tO^r7!4I}hL`%xg9@@BP!5G05c6Tf_b=(dQj2uY9GISAHSt_xgK~PsYp6
z$NO-eg7Wvw#p{|1#~B{Tqepoa8*(n~6F6^<rW5Y(6o0{akw-S9a~l5q`1MrDKLq1#
zf&AbW9Yn8!-*<<6=&hW`r&9KV&@#wH$>Y<_$}eAI(S!3tXM6K~$>T$Lq`hoky5B^8
zypF8@(#^^*|HU!D|CF#(^AqY%a=xaM<Gj&@_BD3`-zomo`)|>IKp%}dw=(rs$O~zY
zlg^KrI&^e?#MGgq^CPAXoz!_Ex_enVkK*Qt?p~Jsq;8Jr?Pcjai<=`ld)c|jzj@<b
zgkk{q-N;Xto(=pkW+$)*QvN8H{ghfR!-g+@{QgFq*NOE$CEt^^Q^D=fc^=7c;7a_M
zpT~gC@0k1r<R_NA1%CXO)BzMfEbrIFPiyM7(0QRk`}X^Dx^9cqJ>_#jsmJ>^ucK1w
z_6Kf9=ynOqH6B-X7GFzURN*V3qwt;3k@;Bs)xyUTmnVGN%>M1E#MfH>0N(+hUAepC
zETi;6CFC=Bs!VkHxkV?*iy(B8ya+-k$%`O#lDr5)C#l;)^XK_>TbM3>-4>D)UV^$U
zSM45_C!ts2I^}GS1G=98c))bm^8#`Xem@rYS>c7u*U`E5_Bz-AIUpaR>y+;rn$P}q
zs{7{SNzyvy$?-K<r(E!LM%nT8amf3v=!LkV=>0Y1InTq_7c6=dt5+`gYS$|leC2xO
z%~a1r^3C{ijPpeKa&8jodA=N+6s&KaHy)*T*!9XcLVV@=r%GRo!q=yEi-)gK=kqSQ
zrM=zsm*tT^9>!IFyo{@C*Yo9*U#DE;o75>6`6qSC1y`j`d5>87YX(o31jmW=P<ph~
zDZdryq39N6{|eJLGS06_Znbi~6~=Q|rm#{Y^9)IzH9yZ#6}8hwbx(9&vx4nNzB9j_
zO|Ttr0qf0kSbv<#cJSOQxKH)?Jec5kL(9u}-{dKx`UetUWbj?;xJW%qw!`~%Tqs^$
z@ZRQQkZ+GKgggxQqa1TpyeH}-WNwR*m*^A1O+JU@=Y=P8WQ_OUW!$B6U5$*(jWYy~
z>HJrt&yO-*;a3?apG#iA=aHw9-ssJV#@z)2AP*76`KKTM?@Ap1bJq9?ZyRR_&dT@&
zXJ!0?voe0pKeT}AqIq*T@6govb<lDH!tiuA+W&;)n}s^!ZWGZD_~{&w{{`^$jD_KN
zI(1<@JRKgIm;Rp^$6@d^X&v$8cp9uDE_mvd9Zz3|{M`lc^m@owo`<J@v*=N*p19zt
zT~A!_l<SE%Q(X>&A0)>NzL0z~_(O8f;8S?L3XP|BJ@MXkuwRXjr?2fA#F?o5YSg*q
z8yA!VPo<8y$S0{IE_f<+#05{Kj(9EQV^aHV8z%$#m<l{6c=`a)BL<#^=@%L2uOydR
zxo%2oJl%=fX`}ij>G5<sY$qB|J8^zK!4au{R)O~oo>Coyd_0wUEFxb8Po*A<$k}i{
z2Ko2$?d8DJ4ACn!o_>wv_4B!`MLb>7zZ`h_59)vF@&DNx|GLA|NBW21=|QyL3BgmS
z`>pYG4#@ukczWsW;dnap_IP+YJ~Y2PB@{MznzZhBay$*z{T4jEpzL`1F61RIfT!0$
z-tjy<{SVcj^Y`n;>VFHK+V#H$Pr3egGu7AVNIbRce-Au58J>QyOFTS{ihsECr{%y?
zsrxN>Ds{gFPo?g+;HlL89)|m`LO7WePgejvV&G|*evxthO>(J~>z|~?)BUNPHmXCC
z9#1*XZ{+@T0DdQbf7&1K8$6|Y1o?O>byaLUmAWd$@$}u>%7Ld_61`I6Nq2gG9qdnk
z)vp|Q`aklAryl=j^u9m-b%&?F=@*8l6KKB^f~QcYTjS|MkpBhn^ryFl<LOPe#lzES
zdx!O}r-dI$>vSi_(_o!$!P5)Nj;CKkp78>B`me=dc)F=Yk7D(@1yAjI-GZlFue+J#
zSx4fjU9WreQOWSsiHWCCabU~mmjh3wUbo<>)aw>Jm3rNRr&6!`7~GeX6HouLb38l^
z(=Rg4#w3?pIj?+bJUy1=TN~wfPmiaEV>{7!dJ^_GA5SOYeS@bH`8l!sNnU!%S8wB~
z<f|`^r(gf99C+HlL_FEi!V~htt_^!H)Nv`@-ut~0$KTZ&|GLA|w|5J}s|J$KA$Usl
zwvD~_VUYg?@btc)h2!bnKZ}Q_mxt!T-v#4u&3-Itz3t?98mzZ1czRLU@w9spJRKT}
zr`ucfC{}k{@YJrmEqKaxx0@%EeD(c><+u0Rb+=DCG8vv$1AZtwXq3G-DjxQYo6CWx
zQg>VMRO)UEo=V+q!BeTbeLB)t_rFwo@8=M&5@UZFre9>7ZAmV*PNR8Gji+bex^Ua3
zQ#<Ose=`5+$=FUbp3cMe^YQe0yl?PyE<b1E>1@7l<LOMkUmQ=nmjzD`CVHjbpY2EQ
z`}?!Cho_(JS`Iw@L5btv#v1>+!_)un8iuD=kbDloQ>vS7@bpE<Z(aaTe|c*-p8n$2
zczAm2kg)z82+LC8Y0|pc$?-H;H(T)ZVw}fvp7-4m=viQY+8N?-^6b5PS@bAYKU?tB
zuAeP<%Js9G=c8QdNIbRcXHOrS3{Q6k{D^_4QF#GAyr~>`D)qAkPo;jg;HlKl7Ce>u
z*_R-G>He3BryIq@(=h!a;|wCX)Vh%7JvE+Qigj1qwpMB<HJ;AEcB1k07mRzh|MY3R
zZ}4<EKWF3VQoe8F=@PzQ98Y(=751m^mv|oOheWT`cv?sAuLC@-EDN6QQ{wpdw8p>g
z@O1M~JpCET=MX%l`qu_e-x^pLPycvJIG(P&MdRtM$d5LTfWQBNy~6NR>a|F`NYeV(
z`FKk8ucPB<g7vQjPpMvKqtw4vay@PQ%zi-60(c7N|MT(m2wKlRJ&M)A7Cg1<U<;md
z9qi^6C|5cXPwhI`*Ny=^rM!50pM^NX@?FQz8~|}?itbVS)2RF?oyvlzQU_b`RO(<0
zo=P2T!BeS&P5fr+VDtInMd#qTUvCJXFJ62)U611P#dn-c*W>B@Wj&wg_r^bq=bOAy
zFVf#3ui@YN+CPP#ds64DHQiv{t@wU;J_C%)=JVzmXEe*PVEmP-Crf;0>dA5*X`fFi
z?_u8jsea9F59Wh_$}7;nWk-NMP5dhH@m?>f)5QGUOY#}gcfDRxr-}1e_o9LXI$j>@
z$*O!J^1b_ya2)SSikEMkLI-y<PCp#K?tiKJ(0e<^voD0{hZ(1e=A-o`TDPh7p-EIv
zwrwS~lUg4dNA+YQ{okLm-a_$%=6v?Q@V?Q9xc;xNH;KLeJ$|3`Bol|Vitme_6n&no
z%PpV}{k24WXeiMuwLY{vy)X5^^6U$uFN!>o@rt~WaV9^X{m#x{Um(3P{rT)IOB{c9
zYy7r8B;%L!*)o1PpDp7r{e1REJBR5T9`Q$rK16k4iGCoLmhV|uA9{2_xIXmo0<8}b
zBjw2zB^NR8k&5>ovLHNu{H_HMKTZ{B!t!hkv+6)X{Sb)j_4EH95yV%NZ>k?UpAWnT
z5)$aJF}$brn7JUw)q4>CuAk3X&o8&0hxm5=eEZ=rPn3_{)Q_Zm>~ZQxLcR^%-oFnI
z=Hs#JM?&5X{ro4^^LG76$p4|Af8ToEt{(|`MD+7-ThH6|BOxD&e*Vwa^LG76$ZMjX
z|Go9RT|W}?qv+>fww|}^hXOz9=U-6IYdnRzZ@?eV9S-=-aiV@bN{)Z@>rqO*MyW^1
z@sEBzN{)Z@>rrz2qhF7b;~)KclpO!a^(ZsW^CWlt`oyFcxQise7U>O>7L&f^-og8g
z@f25IKk90<Kh*Pnz^f&F&Ktt}3#FIZ>jvvDsP(&G`{Mc*&{y){+<tiBJUF1w0iAb>
zkT-o7Kz-sG9DiOvRoqz8^LsD#ji<ka>EjvaYpfSutUoZWXJURw=cUUyzoPaBp*Rn%
zPl@tS$t|Jdv2bqH&%^s9<#Sf?T*c}co(*v%{`->mAbs7b6JdR+e%kdd!{YaVZYSRe
zc}1nZ<wJSnC|1YtxWG83<h@_4j^WtA`$C8G^`G`FLWi((qCkfO6&*~y55`?Juf^&Z
z4hoECTpm48&Z~LCeO4p!AM|6l!26}s<Nu1#Bg`)e{n$2?9#mIX(*tp+z<8<x<2g8w
z9*9c?-rqFve(Ci1^030|By1lA^k~1qtP{f@hvURSol3+@dmPL+dVW6($c^&Xsr*Zk
z@rA`5!T8<|jPDAr%QyhXr}M(vxP|=7`$3IIzbVp>u=8cmk5>Zyn9u!4U#IekBK-*S
zBS1f%4)mjq`;lHg-&Ld^XZ@X%gK|Dn2mpnCED7{u_tbS8Z-MWt{E|_1DsMUr@=KCD
zDy2^4HDTjrJ4&HCmGfY{WvEkmVa)MPhw*kmoyvcKpR)t&R8Be!@?fOr$K$N|LHjh@
zE28pU0zaOB{781jQtDJ5VtqfVPUUczpAN_yy?t-kZ=|nN*&pejUQgN48oy2dWhy@x
z<R{*Q<-x9s{sxEA*Qu<r`Vm#9vU>;3!>8MnHV;mT^RQ-gP#>`8;Wn#ICCoUigRkd>
z<>OCZ*Wq2OA5nEG-x}R9>*49ZJS4AE`Mc2|kJ8tvd~P)GLHX)bK8fwE{W_KRTJvc0
z(|r;A^k67IrLR-@Gpip_bt>mu&!IlYdMohxSCD_!my^lsR9=mIk-kplWzau$zA|o|
z$_rusL-Ghm<w-stzN7S`s65GM!}{xhI+dqd^I-E$)c*bS0(@iYrG5MARNhk}-|bT(
z-|d-_?{-bdcYR~>-S!3fE`6QKnj(A`wO`ySl<(5lsqA9)BdShiC+j&|UY$}R-+XZ>
z;8=Qj_3@$U<kh=}CX-ixgYU$USARORki1G?r}Aa^zOr}N@+!*C_Qv&LdQ<v3mCLPu
zMAfN$+<MODn{5Jole|vleaJW8y*iaQ9$MZym2(dLZq=!rX7QE14x;Q_=Z3C>^mQsv
zwE7WMr*gdYoV^a7g7aj)zL&h7(&4xc=v<8U+r+JlF#`IRLf_jjq5Rwnz7s=!?omK~
z+Vvz#sZ;p_YhG+Vin7!1TxLG1w)zoOr}BH&b2cBHTOuE2O5~%jN2TMVFGeN9;nnb+
z7<}~4QPDV@&qwL&RQ?6}QvjEv?A>qA4a4R1_Ke?H{fMelxx#wR=A)fU<fA7>fj*aB
z9z6v8OCgW$NytYn@SPZZ)Rc&i($}f{i8U{_Jc{y@EePeK^mQsPv-%NLr}AR!Ih&8(
zhWh9w;96sed~_Q0F9jc+oRE)BfbYcMqvI0sQTjTSqpf+d`6%q%2iTp)hVoJRI+a7M
zeni!&90+vj0Dr@KTWLFYa=mK%68Ue-l>FBtA^&X_lmEIV;=lBDD!)1;1P_%TQlAF`
zKa2QXD}evXSf}!zRzITZRK9Zv@CnyD`v2=x;y=hI4(AR)E*$lfbag5pyfOSd>>=1*
z@;a5Bw+hxjimFoy@?>q)sk|NdD+RvH2YyRnC!Yu3iGeTI9Fj!eO<$*SX3BB93CG<S
zbKGYp8h89Ul`Y!`=NI)Gj_1(wEbJUfDRnB3PD$UxfW8UpR2~f9QE??v{+9!QzGbLW
zd0|X?M)~3Qxh`3q%AF1=d_Gs|R6YXd?qbxbeBj1l+<?@nywAEXbt><+?n|A@HtW9B
zscg3HOP$I^)_ti{xe)rz=Y%_=PURnZb!?r=-$MHxSf}zA*#1n)_oC`DrLBW$*GYUB
z+wZtKm3LzM9apFFHf+D+>Qv6d_B*al<>lCZ$JMEvf$eu(oys$NrK?jp`-X76YU>+8
zPvi4Z1>zp;x|b`r4C+-;btN}G1oSFeNO|q6cm=8}iRnrUJ|}f0AKNY-&W4=}$~b$6
z*XL1jPIg_+i4pYs;s&4}pkQ$SB6{%4p?S`KYt>Es?$nVy0qQC!yC$AP=6xLO3qF9n
z*Litmp0()l?X4qu&q(0+-H9KRo{w}0iG!a6e5}?T>WjQC<a|$|I+EL7`|YkH*<~xR
z`@Rq!=dR>~toxxc*L~Ret&H;|en;v#YJ7*p8S(2?cI9?Tt-C0Bd!_Co)#Y#{e$J1V
zmimEGcSGt2QoNg~v&eO2Bz{in&Pe>6<SC3%uX4f-9Z|3HEvg?@GTq+fc7$&0Prb_B
zcQA3p?nx*HOx-UkFB_xo*OO(U(?b@WC_dYjc+K^wUge%UgvD>iuU85AfePh^s{nph
zxCHiXz@u;G>G<vFdX+0f^Q(V%>s9^;@^LGA**M-3isRp%dX*0y3^*RYzSiVz<KcMJ
zIlaEulp{YJ)dw|opySr7>=LdITlkx#UgZd&hthwd>|kN%Wit-fhbg&UWe<{nCD*Im
z7~6@?hqCVLRsLvRIr5i(Tw;B#cj$dT@5kE9w>td$<;b`C+Y-nBD{K6AJ`~9dDEUw%
z|B2*7kvxE<=R-O4`(bz*zh33mApZ;GTkSb798Y`1#M6&M^Q(V%>s5M?kGlY#4u$#^
zdHdq;PQA+KM<m13i+aby)2Q>y`(9lRJWX4#a;sST*(7*+JkTQso`&fc8Rst~mrAZz
zSxfDdT(5FlY$qB|*L}T8@A`7!=>|lv)cM7}!hC4!0#C<pUk*I|JM};H`2S>$f8F8f
zr0v7-G=9CxJwW~!z|&o>569Em>*MWDHweYk?{2-y>mmPi0X!W9^(*r5^t)59a@9e}
z@bt!Q;^Apj9K_LAl><-H)~nnd_g~shj`oNW_NQk9J!0T#n0}FQJ}0?Ua=l8f&sB20
z%0bwlXgpo_^(wEQTMj(UmWU@?Sa`Db_NUXfD+iu_N#_z$<LRgLzP~?TcX)dKc42rL
zzh31ikpBhn^uW2{csguuJUq>Y=2!pj)~jrReB1@_^cKjsorkC2oqCmD3{QrqcWxaI
zPov_&rp_q`o~Er=c?j-H%8945fgUmNG)%w9I2$pZmRhg!7?N)#*Q-1X+lj{0bziTt
z<+^g<X}=Qjq_2f1YY$H^-?kih+O5R#S6bs=cX)cuwqbZ0zh31;kpBhn^tkK7@${JM
z;^Aq(UBdeJ-K|&oB-8^afT#cXNf@4fcj{Gck`PaqL!3s8b5K!nu`{nM2cD*_S9v1h
zm+pV5`_tQi9x?DVOuxuDe15j%dX=YBovxDWRn}uW(RjM<>s3B^Z8`9C1ko$?{%l`*
z-`}6DJv_a&cRBF1Pl@B-+8Y15!_!5*!|*D8y~^`I{ujX0v#t%t)6=hwho>V#>s@?z
z>s7uAdE*P<={*qFlD9wo?$oQ??!aXG(>MMv9-c<!2e@f=Iq)=Xy~=Y@uP!H^J_PiL
zfu~{mMaCIOa;fBcm6uSRr;_Vcy4X%Mp04|Pm9Jg{cv@<`%HxS%sqyq^dVd|@=>yx8
z15fuZar}E&<6n1p`sg-ccpAT6<<%hn3*hOGuL;M~ORmv)8eOmQ_?^P~_uZ{m`Th?I
z<0+i~&&Sj6PQA*(2LPVNuUGjY#Jk1VpGM_Lx%-N8;Az@=l~*Btt&jC8&#n&7YXF&`
zByKF@9LjQR?boZEvOmNduf2Me6ZQ|QSGgOGU-Mt7_Jw)C&oT6&F#Ry&^q~1DxnAW&
zs^e91y~<;;ooIb%-PfzU|7y^OO08Epgy@x89~waKuY-D(bGHV4sMLCu*%HUUg*AR#
zA6k3$DsSF8Oy7uKuW~BjcL9B<{_1djXyVmcA0kG|lPf9?+OAjm_p8F=$m@W=OQ=`*
z#IPW~qI^^Rh^kllb9hhL1&Y<Hyw7^RSiQ=&VK7hSt5<nDd|&0|DORuYr`Geu>Q&xg
zJzuO|<u%sx#p+dFVLe~0Uga$7`C|1dJ?r^m^(xO*&x^hQ^{u2{Wy3JQ?{!_T^4BDH
z)`NPL!>fwxTe?2jA;Svi!-2Rih@*V{s&IMp%2iOWvL}u|PtKHZes4xLp8gW1k7t~(
zV%MuYBj$H>e!7hFOKQKG;(y(3p^BG-bcO%hrF&PrcBx#N<5Kz!jPt)`lRH<zk6VBF
z;w4-4hp2Rjk0(Jdas%iM740(4X#8F7Khnu@9^IJg-W-#K-zm?zmX9yBx3|}Ha-1b^
zn>uFD-nPAHo*(1)N5i-oUmmG&C_X;B8sh{Xq3%20f;Cjne!+VbKdAJ{x!(lq2EPY&
zfjR#H<TDtz8K!)|fAIYo101KOBG@m<e*nLqorV3{#x&kV^j;UJTMXl=aGbCHV#Wh>
zfKs6~8#vBv^_`lG<Fu-4Xtzs0q8H@%adR)xc(P;gubW%R*W>tl6<<%pzx6X#@O>J;
ziMJ;@d44=T(~0Btfu5Zl$7$qvez>0A$#LqlBe6ZW-Ujj!WQXB3jBn0cW_(_DFy8kT
z^uxb;UD<R8`p7zi@jl(d;E%{ln2$A9y&K7|`1+6A+x_}-+Y{Y=z8*k)y+bGBQ0O<@
zf%cYsFF3zf4N`RO&+YW!dE9{B^F~$Dcy{3X8OK@E-rnww?}qn5F7<}>bJQOAfLpT}
z{%xqDh1NKp>-^54`Egq&;d_$~qW0>?6FsL4r#v&KjT(->yFGg11Ky~<d=1oh9B&lS
zx1q-m@Vapn(S6zX@zQ~QuWWB`-{rvV@P^xq>QOXwA4ty+A-?ezFh4CGOa18%S)m-K
zehAI?l<qs@^=U&!)Azemp<8bVkE8p3_`5fR#@EoD^3gR8p?nWAFUP_>wzs!eb?$~M
z-y7v%dtG3?1AliXdEgCMgYijTEzuS7fQ><ZWBMz7YK&FSyOQ%e9`;~+dqa-KRaHUs
zaa(A-64wNL+t*re2dZ->-i#XTpZ*@`eXxEXXF2p_FUJx7J+{JeI)hz6<>mSYp6^WS
zX_xJ(&R$i;=14EMfdrW3`EVQB@q5=e^t{_hzjx{4(E4Y7uIdC|aU98$=I&1I!ur{_
zo9Peqvqs5v_<accuJl&aV_DzRxO&2VCXdsU9MNr3)6v+!`aVbD_a`+Gzts1E*>Rjn
zO~k+TwM4fmO~k*a)&3v8*U&`#+1Q8Yqlx&}>qGqPHW7b&eTd(uG!eg@)`$3SQWNoG
zeIMdaw~6@A>qGqLHu3uEL;Tpl`b=XV=Epf(V?VqZ+u&cfiTc@i6Rit(5%HrpkmBmy
zMa+i-i7$aZurfVbKF(>?$KtrX^JqT3J|u544#{O-4#maSPLA{IZ9hK;8eKJfQs1q%
z4dN@vFZ@2^b|HM7+AA5p?pYJW*NMQ_YY|_s?OzyQAun1-;OmyVDY?H6@%5Uugs-o6
z569PUEPR#vgzsOb@RgRW&)1Js5-tj^g1iBa1vzuq=8jW`S_JVGtc(m+pL85=Ls}<N
zFBRnQeSi8AjZY^v>@>(DapriJ)BiyG!1%iT+c$TdWz>vQS4nso_FVhUYJM9)8aj?w
zLx0@{YTv7&zitEftA_rHeD&yY$A!%rz7Hr5*H8rx+N1k!1JwucYUsY(Kyu2fq5EzF
zz30`i{Ayslt6@D@<ZvgZYiGhepy%J={J^Q)&q>t3&3S(!dZ>QBd0z){199^_dQbFQ
zXdmg>+057Zn;Ut*Y#a{D@kUYJw`DBvyxP?i7n@y0=d%?KWBv@zCj|Z71kMl6>IUWm
z$IDVZM)%4}ymqfZvqHhTseLW|e8o3}qtG>If6l(ZPdqNA*V}d(o!0}#yO7_%WZ$4&
z2J75&y+Y6rH-FdYvyjglL?L|lip#+7#C7f~KR|ihkUNs}mFz;KOG9ofU$5ZnF?`*M
z*KTekUoYY7VSK%muLtw>OMKmruUGQ5oC92r*LwV`zYgwejsiMLUboJU1F9>G<D`8t
zPbs%MpW0FL*%{hldg%8i><jxUo=3mVCeQN>npfQp(*F+PC%1|CXIVX8FDCwi{%pEM
zI(~qa1@DhUe&9TjDfnSn5q_w)_yM+<@ZEzHKU7spU3tzkulixn3-Y&`7a7NHRzLb$
z^B~XFcF;U@{hpqOO5|@npHb^l`qdNos*U(IBY8EOX}-H`Ncq>b{)zk{a!;+#%`7_L
z`egY6>vJ1xK0pJ5`RK0ZL;7Ln1=-xu{Ry2H)gKwxSNjCz#W<K3?ho`^p8L-}j^noS
zI_32P`x}5TkHkLW6kJzzg8$Mr{Hv?z<l`so_hCG^?@#Sd`GWLZ<}*K^GUHiY1>@W-
z`fGlt>pBY04&VkL7>pO5fc`Dn%yC?mZyWOv_rl?r_OG|v?`5^m?*lFYiFEsmq5T}m
z(W(kMAK~VDQ@*3@Ldu_%tKsYUd`<Z|z3g1RuH@fm<6k}h$X9AVgzJsxAI7)&_k#02
z+nRTv2RwJczM!8XxdZaJ5}sFndBi7WSA4k(z5jX7AYbZrq3s}1xb)DafVZsQNZ!R+
zgpa<Rhv(V112JC+zxw$XbA)f6pU+Y7W;XGYk4JO)TJUN<UAM4)z~cnIf*IF#F{Fdi
z7Zz**czy;lj_ZF<^3DqW5q`M-_gJs+@l)_o@Rj6HgO9(0$AZs<p9a4Pe>H#D@&WNw
z$p^vH>9Fo|f~SP*dft(56rarmToyj)>^Pu70w0|P?X)rd)Vdl9^i%RizB>ivl6nsF
z-E%%$-R{ZQKkAp)Ya-K`#@pCy2wxLD8hh=<*F>+zUaZgNh@M_AkajR$qPN$J^;yve
zda-_-V|}p~>)Sb+Pp=pA<&`7{KyOF+$Z{j&kVUW1JRlCKc@X(~FwjG-H=FL`EV=`|
zfbPR0=ng&AbeHc8vFHx-r|B;3?zs<~mk1xH;FGMsjB^6gRgXJhpXucId1lY-={S+=
zOyOjdyx8^9_I97{WNvZX+(eR>%6^6Noc#cGoy1;6;{jZw-|4!J?NZQB8z=s`DYQSi
zNc)t4)QxPP?3iIV@z+g3er%mbKYRT~@r{#`Z~nV?_<D`vo6q(RuGc8O`FQX6eB<W&
z6`^bTd3y-wZE)GzxADCd+V4R9<W^{3$;Wc*Cv!J7`)0R^<fpr>;4tOMbGH>7ehK$m
zVh{APEBG4O*735-@j7q)E8IZ6Q|TxF13QS?x1rvka6<HxUH1X~gzTdFdC+%2{w?n2
zI4-H94%i_V{#osR*{=c5?SSn78U^(gd*5yM^Xe<w+Z$T0MEyYbf4kXm?r2|ZFHD}@
z0N+vLhkYsZNAT}TSWgA^7h0c#_e6eQ0`Doh+2=B#|N8k0;CWl0QFI1G1^S#1@*qe1
zX|Lx}8dr|&0*yUMkr#cou_rO6n<KkGV^2600PizS_nghwgwtNnnRxBpJe~etF^zvG
zzVmtl>X`k6$n}hK7t!6Oli+73$N6Iyke_=LeGcj%z&LM%bCFScp2DB7eRIayt>||o
zpZfJNzZ13}%sAW8cf@YV`yM@y!VfoOf&U4|H2%So06u`f{(g<zFODmIX2HkK5&O5!
zwEo=zI6eM;5bR2UcFBzCc<jfl+n@q}&p7|aad=tEm+PKG^XwjAwU@El<0afsQHu|H
zS;C2iiXHiy<a$E|>2F?k7|Hnx(%-x+<?D4TSbv*FdZWkw#k!32?{Cz<jr!92XER^I
zB6S=G{G>?74Y_|AxN;o0hJVY5?Hz9p@9U1F`*j;i`>$jB?zzPG?s>Eh8m80wXmGE@
z7aGo=gMS-mjK}927aT`_=dho1D)|Gw@#IJHYRO;avES5fqW*ie<d<@rh+d7gocF$o
z=+#(Da?EWadNtPazNm@w8`sJ?V9I~*u^-g+^BuFFY9sPr1>}%r_eB4=I!^#{7S<p5
z`P|%G#0%J`1M9f0L_g5$&`-qt?(0QLFSg}1epl^B#7_F>p+Px``jo1B7^PpnH4Exb
zQT`9<SJj3ewnM*kKM*IBd|w0mWz~=QELUHIekeTwR;u&^)}uW4+)&5yXnF81!f}=z
zL;U288cB9e+RniI<F%I^lV|_L{TbVDfZhY<!TETxXAj2b-BZ~PI*II_UbY|I&&}j{
z>5^wZdk@B^#yi`xYu`6i*|n9t?rr(Gv40}JmEEkxny*#LUIBKqT`jwroTIoK=BsTL
zuHU+@P1JAo{pnV}aUAOVVwb<!`aafaRX8cn&9k1f>AeBay97F3j&x*uuo_2PI$mV;
z&!*!Z799Z+fKM(}bgb$s_Tc>eY+QPtVfAClS3$d@&~q~I{S2|o6MuSamv?i-mtHpC
zK96+w?enxAmR(Bg#a&G61;*8DbC5U5`C9Px=o05+v_%JdKEm`2==WHdk5=MqV+SU~
zyygqE)2Vf7^S6v+sMU{=YJI^vl;;Kx1$s>+d7$>wh=UROL{UAWWiqwL@>lH2k?pbG
zQ`cE=l=KMQAJ`8yG|$3z{qL8sU;KDub1ucVC$oLQw>Pt&)%?!(1F<)Y{134QzqPUP
zUsqLd-Akp%&xZA(aBdY`D|?vihprw9`=N)B(KR2Sd=R<T$>F+Rv_H}9hOS@fH=G}2
zdGPNc!TkxYU&Uv`0Pp2{$`1JP5WsWBC53wcU3xt7o%i57>N!xUwA>Z@;@d+U$D0pa
zO8W#n=g0o&j6?g8G~--pjniIFQR93$;W%H2InG}d9Ov;x=Uw(66>uK8h3A3i7x)$^
zDD*9at544)I~&rur`SnZk5_V`Tz0mLVEyIB6|vWl0v~N>BmF;Y{hhrr=qLY2^i%81
zo^O<&YCVWtyusoVdmYtS>p|?OR|B84@jNJdj=dh_JD0<E)N{~|%onUPX?GUz$(7c6
z@a@^`kMDqaIt1s5?L}p1-?ppmgYD<zPr3N4Keo?!)B*k9VPm7eyCL%s4@U*}s%ih&
z%JjDUvXS^n%T?j$rqqr#-iGEk%Z8sD0$r6H$NA!YoR6Og{Ixb;e7TXvPqO3r=c2@4
zD(9luUn+R*WvSkPe=aIJ9p#M1Pt?m4zM+1^_y+pek2VeNCvp9&{ej@~{2_qPbdFlL
zZ{xH0Pe;SKadqAT^;)K*v=4GRN^jp}Ce$4!Ld*GeLkG48$oa4=pTlPP=4E>mU*t&7
zlymWJ?meWB$LHo<KOd%?-(SPOlYPQ%X8FeS@^MD(|8e|kU;5c*3dgI7VKdI|*q=gl
z6MWmDM?8EBqg%$=p1z~>FPLwb=Rbhmoy<H1?a32xo{8?d9s682>?5^a_55BzK5Di0
z$Dn8F=bwe=3+w|mpTc{BBTw!Hc*^sl_!NR*V4RQc1$a2MD80pQ`k(Ic=pDA7$vFQe
z{{S6#c9yYxl5@teAAo*qI)Xm{`gsEGr^&xiS0VdSvP&*&LpXQ3bd5Nl!#E0b5xdX=
zi~e|yg3qZG(uZ!p80-vuey;0|XlLkB={R7?v->T4zO0e@2je&>FpkdnzHjgH&qeQ)
zr=QsNF7%Tq{Y1ufaoD(&y(?@TK))`7aq+pps>+Y@>|C}V8vT&!`(nR33%;+`f0UhT
z>Rxa@mgtgkHq9Gv-0w|_`Mu-edpFVd{CFFQAM0=J-()}2$#I_KIEne)VV%5+4Y*^-
zj^>VIdqo}DCH(zhcWTcSK4&_KJoLI#KfF2gzPAzE<;LgRH<o}t$@UGHCm@xZTM}uX
zL;X|X*HX66i98sJ>z&t)!W)~v@VksZdfn`9@mDwKAIo!CH(~1@`aKxeO*iUy*FDKT
zr@n9FE{;QeU;4kj^?j6k{CzF=wzi%VyYp3{dC{wAUUO{M&Jqr~Ig0=BvV?<fj_u)D
zvJ30=j`ZVo2IKv2by)m4i~{D5z9ajW9Xbug^SK}gfOCM3%Qp|kcYUPd=uDmw_P;JV
z2j#angyf^U_;k7+wG`>?-f=Qrk0-vV=lD8rJl`M1&kvz?>T55+=Q9pDa`Zkabe@zP
zka_xea8RGI_empxZ`AzCe&$_xuYmlJ_TRFe!+n(E18MKigU!0nI1`ZmlbUGU?joLt
z#a!3-4xZof{C5=3KgWgD*V21JKfTUy{<+^U|Igrgjy-9<Te*FXLzTZ(6*R}1zSxe?
zvy<cenf;ZOD1Yeuh~_(7r;6_ez&d03Q03z!1p?~#aNUN;39-jKJUCj9cUx<SuXz4I
zuHk-$&xyi!;U8SXKX(zWdw(C$X(xOh=mh%%`I|=v)ju4k&_&^RPVs@zp%8wzTm<I~
zsb9Xl=KYEIx9t5<IqZt{UE|m_;-7P|_eIBcRr}2r(oaOcFE&5EeY2D7H(w-qF@yPk
z4$H+M<S&%C$%fnz<O7fWu#H?_yP<6_yx+Kh{EQ9$c}Mm~=AFZ2zh&NeO*tn^>rwNs
z$n#GxZEvsYN(;c=7t8)v&WZW{Z`SKUkA(ltIQQasZM(GCpNqfWOz-nKqsHtXc>HhD
zI^pw8jdGqQC*$SwH2!&DlIPwGmg705cb4R~H;3f8rUR@CSU)d;osZ?8*wy2Y|JqdJ
z_co$)%Z83Ww&*~9XW;`w2RVl;bdb91!TGlN&(I^^?`-3X@W&fffWx%U2e||)U&f&T
zX?GFX12jDW-`pk|7tpm0>Mqc-3_K_8H(eUc%OLY{`=vS$44p^S-;sUhrkljuXI?uv
z{QQ%B?g!*L$VZXmUk?iUs}Wz6Tt)p!$yLGEFW|ibI1Kw8pwGVs(f%F%_5S|lOyq++
zc`o1KbD$X~OZd=4=i0qmwks^6bMGF<cTZY;0ojA^;Chkc>2Ligx?j(B9Iuw!8A9*t
zaUy>xeE!`g;qy5;Vm^O#DdgGU{0Pc!jPz9FdY$oli!BWO;^5M27Y6wV<`L+741Ra#
zqV$ygdFP1lhUw)Qhw>=MKB&<C`^>qZS48Z;ZF(sFirS~%3H+t(F1Y_z`_w2u|9uyl
zeQI50)c!gBe)8rbd@uXld4tUU)!$FTqJuaYi94iaui_3Vu0xL->BDvhnD4KlPPrX-
zcscJg%Mf?y4FdUBeE*02Qu?{r7aGInP3`}p><iNa^R^1*g^63BbND9ikm3hS+ynbD
z{J03VgZpt4bk5(zRX8Ls{J0B>pD}S66bGR9pVO@KAyILMM-2i!&We*ze7q&JqxK<k
z&T};I%TzhvKye>(z9DwpAsi+JeOkpGezOtuN7iNjd7WbMZhIj=<exLKaRT{)<)_xa
z`-kyEk@J(l=K~c#m~#z(!SQK3r#&xG=ihr<{TLQ;u3<~-IeY!J!TR&*nLK`QbKs9w
z;=fYj2RF3(X~z%V{||M(c>~9ROf5jyje)MB|8qa8x`@3L(|&^<#d^EMpGmw?E3X@g
z_gzBQ%@iNywox3D+d}bFF2|+m{SxTYvR?u|foosy=5wc!=S-vY*T{B6f9E(s%daK<
zDCIoJ-Cd&h!R7F0E$jkvLE^+n?wL42I<M(vUlMtSf4%Gqz83v?IbVzZOm#r@I<n&g
zaeXL#Xe02eDLJ;(T0i2~+Gh~xp&Q{2O3TmQ@Vu=DD7{GhT%SPx7Ujp#az*2R6pq|?
zK`C*9v@XjRC&+lt<Ai-S+Pjs%3*{)wLs*|b!Se@poS@*7#0d(1NnE1vhpbzPBb0SZ
zcw+EU@KfRh1z#o3pYc!4gDq#H;shH9YWySI)$@*gqx3)YV+tRr^FdRgoi?VQI_D4-
zCwTI}kn<3%FY0zr#QssgOq?K%*Te}DJxrV+(aXdMGCuopf)WQv4l5G}Nasx49P^bQ
zC&=--MdJiFpmkJW9-{E>0HB9jZ#Lbd;sl3A&>b{F;ZvZe>;w0-=pGgC)o);dcrRXe
zZZpv(<4noJd0Z!=U#K|2DR53aYMm)PBT8QEctJ><pyD??pTKdOZZoYjU#=&J`vy(`
zy21K~b^ebH9mnPI_;yC#AJ<g?b>VmN6Pe%Xx~_uqMQM82_P#ea1U;VfQ2BCU8smV-
z1+sg%KA!XWhhp)`tt59eUxxCR%$GWk^vRweANV`GzCAzwmilAX74=u*Z?zmiK2!c`
zvFE?NC-51sJK-yTeUc&9tWVnKcrMXZ?0Eis=Quv31N4SFVE&7olauw3L_e|lV17Y9
zqj5*`8CY$ModVXK&Bs?m`w{l?x{A|@k0a0Xz^s{bozTAB|Cz|glu$+MAE2MWI%)&E
zxr{^269`V=yD<II*ZX|^@By;JZb<y#GGB?EG_oBE=T+yY+OVC5N{T<y{VCVEv=hoa
zpEkXZ+|bNNRR#H{!stE&>5kJ^@chgFV7<#e!`Ykop_y@A$v-;|686bJciA6L-qY}*
zuSY380{8)*7hF0C<qYpnnt0!`i1#y#IWNEnjz?U~_&$OJzq^?6e+0)fF6MZ}5ghNh
znBx&gaQxz8)+a`A{Nm*t$F-PoegwyhE#~|JBZ%*1pYDy|JXtq^RC65fJPP3P<K;#W
zoxOpShtTUoh9s|=;?;cnlF}2R@bXfKbBKYLVfH{+ZwGoIc**mdaX6o3fqsY`^6V1&
zk#RUrCgUZnQ=o+AQ`k2^fBzWRuSeMfw?YDIeJRwwq4ZR-cU1vjs(q1dr;O4&vYxS1
zmU5mZ6Sgjt-YfP<a5c+$8lPYMxG~xn%DF4AR`Siz{!xz)_hZ~X(D$^fble!NYj+CU
zu_n`b6=N@nZ+{a1#QS?Fd!)@*YW?edBFF)mpTF%9GCwi&!gpqXorlkHRXk$ZBWWEQ
zdnD<FW`9NU!`LH9z8F1B^18_WP4;uLzmxr*<fWngg&x11_aSOO_VgYh`!U6@yIcEs
zk++ZSq4S{8y!!UYIr-<1kp6z074eUpYjYP9e*wRoUJ3n4Z;xz2en@YRyuAoNM9ICy
zzz_cUH?f!fp5%t&OM70T_Gi~x{lGX;rOyhET?zBo!u-JNPV|yu{%5z1`Knd+EfMkC
z>|gNPCH2MEhkg4T<Gu0cvRzHtH&D+hAs))sFNbA1HowIl8LjWQIG>`IoBUfG_w482
z62H6T-x51q@%&qM-iX_~1mzQ+YgBvy^ni8q${t`>dy4o?or@a`>sRrgjr(F(yKJ+d
zJpk7$&zpP?&c#IG)o|edl=-*HWlyv1W^ztK@JQAP&}-+efE%M|KATvM){-1@n^?{=
z&bdu2hie(Xn%It3%j>R*_sg}ko*J6i{$0y*zlrT=wQOf=Vmn$b$$hO?*zy77wkPsk
z=@%l0yTbZ!C4Z8hXZ!ps+R@a0TjJp=;Qcnnab?%o9rPuoC&>5yw|mfzhI*CaM``zq
z-C>_idZ_E$$0z}W<jHF6#pftEFIJ;(FB5wh>^=YwSWoutWsEoeex3CZ-mm-TVK~p8
z+23PxPR1cUT+_>57ZM+^E#}{2`oz!+-gZGR=(s#mO&b6`isg|?AK!M<20)+u_%@p_
z5w{dS3LZTI{GsHH&4*}LRD39QnI*f2^C4IuG#|=$?zH$2&u=O|ly>hxKBRf~@lNov
z199mLm?yQKw4Knm-$mL7*?!0GhuJ+Q;XIN3PU~xcA0Xf6fZr*`{(ED@4bDH`%zUo)
z-C$YKdNk;Rdf)BBJgDb!zLee#{n7jGMwn-@uUGT_SnTW7G=YtmQ-hLUuaWn$B1gPx
zkt=LxujYO4O}tM&kM_y_y07N_vg8HfeWAb4QT%Gl0oji(#B=lcav)3}%s3a(c^kF=
z1isbt1o#T`wDHy2Uo3hfpRZ8%`MCSdgJC|D{vLO~IU3}apVv8RADsSN%pPHUqVPrb
zp}WC)<+u)ierWofWnyPPhWCxfava52j)UNH9bT5NXK-A^)WZ7_ua@&mjUqb^%u6NO
zUuhrWEuj2VbqV&TBB!c$SNqcxaYmbl&8LbpTCVB@fjtN;ve5r6U_Sjgqs#FAq}<VH
zf2_|=Ks)~=_V3kaIbPcL15kW|$NN~bPo;h9q#V6ppM3%2J|}U!b$#AB8p``+&e2d_
zFylX%jqjU%@m#!iC7)Nqd32j-9!>rZGoQbOeL@NQ%0CT&dE|X%ig|o(K*+jO^Ek-L
zrvgXcVIJR{ZsyVCQ=ty%euUz);D@q%K4bL*^Fwey^m9)QKzdPJZyD#|XC=<VT_w)L
zB5V98AJsfO5wV_HL+4?0MA$U*Fwg2oH`u3z%)>R-bGR?#b1uLiTVAR0V<4_`E&owZ
zQ+O<O1Vlc~LV5~b`sV{IKOn{F+VaAdCuUvC`8u&z$@x36XVJQBXr+CU#^1R5;#A~M
z>X+L>^4aStdI8I?o?Mql<Wo=5D}4FY^JG*EMUMr)0qBikdgSo~9H;RLvZtH;grsjs
ze7@IH=*a7)CjpmtGf-Q_DRUl-jPvU}{t3l-wT{JZIm+S-n~$T;cO4PR$FF1mjQl72
zg^~O0=k)!+oWH}L&*?0;Wxi+9b(@^?D!&}*5s)K&67&6b$oDian*T!ODC@UcK4yXb
zN<RzbTeUxu{YZD<+g9RNIUfsrXYXHReQpZhQT|ipPo+0WyOjf?^V+!0jKeL2zZvHw
z;ycy<P`*?B7ry&n{}3GG{(yaGFAK*Y^a13Q1ALcfA6-W4PxT{|{;D5Bmk+FdpxsQ-
zMV|Xdf1o$%6+*|V3K&gr{_OE1F7kJw|F2yTURQVOg-}=bSJa-;yP-YEBRkQ`BMbk;
zzX<IvgFM!LTqwy$6E{lhN#Z@dtgI)l`;{gCLqjvgzi2w*c)0)2j{vT59WVI)6;St{
z*Qd}=>XX3lFJ2a6KU8>vxW(%Op6?3wQuRB^CAEIUUb*)GuvgZG^P$XlC&zh%;~`c<
z-Yd0FLmcFGrQg7RfpIE*c**%8=L=OoaU5#CSEHRp@QU;L`|?fl{)_)b;*n@R{5Z6b
zbq;(f_#*xfpxXl2Z&>TpZ6mn~`_^EdD$4Vz=@Gha6y0S#Tng((t+%*x>jGRy@#WTe
z@SPZPtD%1qx%D8epCWpS!6}E%ZTRyPp_jDKJZpM}(nZlz<nD1mmmGhG>EqRip1}D{
zYAn5^hV+s=`h?i84g>m3xAY9Dw<WmB^|qq&n%R7naY#_=@uIwt@pW>XS9smcf_yxz
zU&;CaywZFO>n>^^y8rq4`M)v_)fd#?kITP1rR3l5!#uSy|0=s&6z*;f-%-y+;Vzi4
zBlBlPtmlkF`H1!SZTgG-c`VRBWZeP%AL&AJLHGvdA!;Al?fmxk#_4QNkLXuN+O1!x
zfOS&LZk;}Uc^S6PdZ#+)RjzYY4?_EjAA<H=J|`Dx&*gJ+qQ{4vV{5_wlOLla`hN?y
z&;G44(8oR(b{)3Q=N8J)zU}9|6x-)>>t$%)?*IAFKI1>gw{rWbPlNVZzWVL^=XsN#
zv$XqvVugv{&yy=k&$0c>t_O7qD9&2sKj<TyUjTIpxGpT8cXyk4pIr^J1M8X3t5tLU
zDm6aD2lZXhr}h5n?0!MN0s0Zu^PrFE=TGkk-($aeH95HD{H<5Lg!@DLQm>lM;pzS?
z2fa(RZ~G-C_H&%Z%UM2hy#lYA&wENe13q8v=E!a-^EWBScF-n{BV0s!n>Ud58SWyI
zOWr`Razj25I#*cVhYnKISChXd<2*-x1EuHMxbS<%<!d2sF9H`d9z^ZO4nGg#k?%+S
z$g8C~>0XxV_5!W|N7i(8oYkr>s=FuCV-Mn2ZwS?6mwMq|mg}sKqB`suj4Fe9qx+k4
zodB_OiJcbstsn3M+x=ax&%QaYkE%+lFT6SX@wT}F$>=Qm5&d-+)Ay?WAA4^fXIE9;
zi?4kqdu9^wGf7~FFcN0~0~mWuco8v*f>gx#5>SpPieWMwLLhIG3E<9F34+$wUQnx+
zUwfMb5Y+ZctyONdcWBY7_x85bdvA-iR<yoWv}mn@Am{h_KHulN_d0vdBr}*)Z9V_Y
z?7i3Pv!3_$tY;1Q{)FexZ=P@FMVRt?0*VX$yz-f>H=^+{95Xa0{+aOid>(1wxXXKS
z$2k8Km*qhIri^#aKS20Ro3HLscfVe&?=QxDz26}y7dYoO!1jk2W)kvSIo^>g`MrdX
z=9~I_{XWU&B|hJ?yu9YAaqzn45)RGte7+u!Gi|<pe_E>j!9ASk*do&Z`0yhJFW?I#
zT#UDmbbwzR-?a62Jy+*ZvHlONtn{rRw;Qtgygz=(^KOm2*XN~tD}uuS@k4&m=Jnm{
zUcy1^?eJ|*+|Ttc;{phed@u33SS<Q?x_}++`MjR6pyIdn^4e$2_p)B$@+u7vu|LOa
z-Gc)@2a0MQ#tSuaAE)yCK(AYR_Ih)ctiGZ6uggy4{8IC-RD2Y0e6i)Hc%cDG{14;)
z?>_E<1=z=+JrVmW?s0#`9g+VV?R|cbe#<}c`ahjt<+H#%F_L1Kc=~bO2XfPcHqYWF
z(oY<ZRKMThTgY4J>y3H7ymlY`laJZ=z1YVtfFHs0Dn#ezaBl?eRet0jqjRo}5Rg)B
z>AVo$9QCs_4dM3a8S}n#gnldN0VVwpD{rN*tMXRvA^%Yv)A&x(iSWL>Z_xQ#c^}~(
zhm+^0DeZjEXM$%)h;h%KiD&H8E59b@_tvjg^Hbi=;wI+njP3k7-0fbC$ltMjUWG@o
zKjn;?KW~Bi^WJo2bT78w*HYs3Nt6%E8^lnI+vG`)ykyTjzJl|V<304F2Roe({5Rk<
z&BGagjaUQx@)OAyCQczCO|DViHTuOaXawUwS!0RmN%`I}!^g2xDBs7P%JFSnb*Qy>
zh2KLmv5N5&ll^`!Y8B%mihhreIGK#HIMx5I7`JvOhu7QR@t3jPT>iNwY=3Oe27X_{
z#C_vua~yyR_@?v-<x9i5o>0Tbg~Juy#dHh(0C@cgr_Z;6K7Cy;NP^wVFcs;`kD`1Z
z?Z)P@<ZoF*{+Un6{&F}^bZp%32rQpZ^83Jm-^=RjocX<X(x3B_*)He^5YTuqPOxtA
zJA4PkV!f<O--+V1e{E&OZ&7c_-U|Ql{FK^rv-bSL+VgK6RkbJlRX#oOU9|i4<vq$N
z51Zt}BCb2ie>o~&43iJUauIyC<jc{%>_W)D$bbA<=f`&~uJZUv&ZD1q9bJt}_E5PF
zJ|46W{*3Zp>{Re7<0>SF{2Za$L7eY_vYY=B{L}TO1JQon?zzj_=RVtkXuocEe$?9c
zeZ7c|9xHt6<44}!Y3t$l+-C#i7x`txuj2>kcSF8dP*`f&sH*dI2V;Ei?sPin5B41B
z9{AhBKj_!>xU50I2#=2UJiIZTzb)1Wuch3ZdAwgYz9V|9@R4w6HF)0^_(^@eUT^(;
z$?6NPD2JcU_3iJyzJpioym-KZ`2Xg~Cw^J)MgO2H#KnG`&6oA`eJ=EW!&Bx)|A$5N
zKXobxpnS-=>+^Z;`m4)>5%)ixK1Q8Ee7Uqw+>XG!zK!)Q>l5xnUSE24T>dpr31NuG
zvP1D+_FIQbc@LfQ9reE<;X1+xW9!)n7NOf*OgXRh8(-n}2G(;hgyv%D!OXv^_8|9g
z)8q3Jwlg{WQ^SX=2ZG)A^t^#!{(#AymHmPyQ^RuLwZqN*85b>P;t}y}zy~HtRnFn#
z`pcyJNV@m@IJTF1K2MFa*Sx{8n~O>J7Yz7327DenDUT)3uWoQY(06RU4!6k_kJ^0W
za*)H*%Q;+<U^mqRZlG+y?ST-&WX--yt(DMYT)q3lc#tQ2($@|BK$^|8KCmMJ>HM;8
z_>Z`KaQcMft*=Xohf#iPnA%l+Ul*?*>lv_5<9egOU$@7LH_d>*H9C{sT+s>Xa4vNA
zT8wuNbau#W=xl~@Lf-_%Wc}3l+WifaW5DMp9Tn-}PRF;+ryg+ieBxILclT$Y-d`aP
zFUipE;lr<2xu-<!7k=MSvBCM4$1}zJ<a^B!3YUZ8yJZ|G)$`Kc$Od7Rgpi-fb;}Ye
zX!&y_FKC!%19TjS{?sq#@yCyLI+@4arp`|QFZ|>OEd3eoSCRi}Y6r`q9prD!+%6Zr
zWJoL@>A`Wo@3->eW7PG8f5lZCzt$}c#DCC<wZ~%&p}30kF8ZtT_{pv);pco;d`a!r
z&u@V~F``!D=Lke^E>|`T@O$%kj$7-od>}D>Uj9ST*KK`{M}5R2<t@(F`*{5x&|;13
zVfqt_74#pZ#+~Vhuz3x$T&ypfUVV#w4g>Q7{R$orf_1sm?0DMk^4I9T?&2!elYdw6
z%J<T)hu!L^fZwiVCp~QZwbh_vf%gCG@fH2x`JU)maG&yfLx*^+M+yJtbJ)7@ZPxGy
zqXu5_8n9nz_`mre!~ezz-hlt^=()1*T&_g++LNAG>1|r4F_+`*BsG6WJDG2GdOKN6
z{+Y0V=qL5~Nt6R;Z6}LNQfA4hd8SYf@;CK+qwyUioFz{%iq4V|qkNRZ`!tY&x08h?
zm$PJ<aVC@pXG1w?+{#0X@4!TShy28M_!ZL7H2lDKcw+G#8Wp}{oT+)2@cw9{+blUI
zfK%Z+IBIIzEx$t}!FOZ=$9HI4X&@ZNj^_U6_!9obcl=U6H;-p{=+f|bdyi*uvNX`~
zif3@XG?2mI87md@Vaz+VQLumNYvl7Nk9nsyD}Kj(#jhog;8z020sq5a;K`GZVtK$t
z{#3Mw?<K!Yg25%VURWORNS!O-JK!?z{8juz_*C5wK?VRnDei?Bzv=DN(;~ay^6^IT
zId6xa67jLoe)bO#7sGd0ee{oCF?^>z7sI!+-RK-B?BrPgvHN0TziZ@Y09;->Qu%FS
zd3EIg*531eME=&7yT5f!>@SS{tx@~tZ;hVO--2Zo|19@Mbq|K$8y))xVUOw_4EfP>
zrl~jn50I4iK{HL3J>!?Vzp`*S-b!aU_xwcX7tgh7)jiIprH4@7<IK;YIG_Ktg7OOb
zeUr<ncjTk6ZbFzip8mgy6S)63aSY=@CXeGpC*Q;ko5`y%%MglwmM>n$`o-C7PkKpl
zs>{)7{zM{VzK8K@mEW21Z1Owjdv-hCD37+|(GtZS5zmSxif<-<mFKEF4n=abPH!>Z
z0Z(GT*B|~`2;=YJzUbstjEfTe<h-sR<j4AaPjooC-?BK-*XLNyzwmolRIhIDiykMA
zCOor*h@kp8(R#n@oVy$^UTVt|T44tKS?=TGw2ZeKUb_C2iGR30S5UnRt$`Z;jQYHf
zcl_BO-YjvvxytdT-|^;U4#!hDuHx*O@Mg7541DU(A0wZ7Tl(+Ar@o2&>TY+%eCodb
z-ups7E1$YDvSWUc>FVr#(3R-mK+2^T{X4C<<<sx6-g|Am{hpEoD3_iVt@m8zlK3Fx
z+cxt{{^IlF&XZ^6$5Uh*C4bgFyyRd0M)H$f{uAF1KK*6X^QO)tzZ`LUQhZSMU-LXF
zGI+*M^;<5#wNKxC7t59T(O0`a+4Y$r*{h!K8t{j|Uh5%0W^;-6=lmD`HoR#K@cy)7
zDJNXc?`HOM(bHK^atd-6C+4B=;0yZu5bj;}t(#VVr5D%B9Wq?$J!t3BOWWJWJ)R2t
zfLC9()sp13N7r8|d5`y7N3S-maN~~lsO(m}zjSOP%U?3OL-s$~1?R{3utFH$dmrg^
zT4p7XPuIUccw{xM;^In9VEn~GmmiJ~XdjyU6wP6?mqSgzd+!m@m%m_o2F7_`O;1F-
zu(KB)=0NjtUK87Kx)06s>IwhE4=}H%VgJ+dPV0^Lr{KN&uX$>(TCe7jjt4$|<Ws~O
zjC1%~E|k4IFvH>$YU8{-8fQM~bZ`;@lr^TuC*0@y@~flxD)f&Uh);MRf*<td6Keh4
z67`3AwjbqsQGSZcdDn+?*OS1%Ft6e;j!XMBxj$!pKl?b(sEzZ#MB^-u_I?+0e9!~&
zD_p<VeyaRaDzA0KIhNhgc^a(i2eGb^{RFrwzDVthpP>Av`MA%8ew|j*FpdoT1%=9A
zSH@*5rQTG=Z7k)u%eW5b4`uwv(uz)iN|Q^eKNo(#IQqeq%lo2yUuEWfFfyi@_rVB2
ztUpE?@3$>`1oycL-h?yYdZ6|#7oq)wxNn?V`v-6Q4?P_1ySiWV<IZ}D%iRxox%(k6
zrysJooOq*qa$~y&cnA1n9e`)MpBw_*+jzd(|F+zJ5c8`q42B>%F~wsem0XG99}azT
z^}e!)96w8Y$nmqZha7%xM-{$*3VbpAJlgTo?IFB3{B-}9<eTs_Yc%XT<_FiK{Ic?^
z;5|%b)hqe5!#DTwDb7@UsTfuqDd|W1rd3?&T_!hjpKmej>u{pmHy(GIpXhdv`;YSz
z{rqhYfAOxGKLq{}z#A4W=JAg!s(5YeCjc%JV>IMiiSIY8=eeFT?qZA!h<2n0{Qkq8
zPQIS`J*#ruXo}0-_HdOqbJFvfi0=WuP@Qz|%ETDgtr`c%RkhD?#qIxpHVy`wR^>RZ
zxZHcX#=(B#aXcS#K8m9T98q6z`}m5;9*fR1>HO#)t%&f${bl(W@i<F(E+|VbGx)`R
zFxYLP8?}pddOpt0yFGyCcMgS6EMVLX<o5%QujIGz0PpXeir;&jVkAcpe<M6Y`IjFN
zm-qO;l0OiCOaAVDl(;?YPsraQc_V)e+8;f<(t8vyh;k+$J<c$0uYTV%;Dh;pbE%!z
zBE8&BzfHcE{v7%HP!4h+8(?5@8i)rmylp>4c9yRr>e>A?5xg(iC%oxbnhtOJqvH7x
z-aJP+9p3ay;r$(5>&E*9WBdfg3w|hn*+p(l*n2-Wd%63+F86x@-Ch8lfujiCfIn7U
zcoUBo@D`szIjo-e5c<6<(u0IY)p`<N;`Zw63HSrve=w)@<bC$qKbSr*^3mC>^FP9V
ziPrh}eXcXt6Z7t-D?gV!jjjlHl<%f1zc2D~;z4ma<2q69h92t}w+sFquNzi<HtWXq
zCH<qHZ3k%GuA0-j5l2Oz^7qGl`JaB$=}dSWn&LVT&jGmvxr|>cd9KOzQvODG4NhM8
z`VaIoA98Vd#V5PrOTIB3zP_&zttard<ZJWYzPO3&Ufjg>1Y9rf#os9IL-E#^8^4O%
zHU1OH8S%Fl0Iu(Mec?9k=TaYt@zwa7+ueFEJ{H6E&Yv(&e1G#Nf7<u_d(C@Wk9p5!
zzRfw!*Xg^)x8wQV^b?%R_(W-k@2=Umpa;o^7=N%;g7+{Lv7Wcq>Vf~M9`FmOr}}t*
z=tA()-{(4)a^KK4WC`~{vgAU_{RnT#&#8x_-){czayu%Iodoe)lt1T+nE$(8@A5mY
z2Mt7eDEPGL!9Dob{^a<o?7+zJ?;$V5ZL^i*45Uc|1$8_x!jJMUeor`6^0pgJ-TOgt
zJ;JHt-`(rcz0VZagJrTmxg3`VYl!*zW0k}AbkQIA#AA`epPbWra3e|agwyBcap4i(
za-FL6=!UDy(WpGvuUd!h^_zJexPG&jtK@s+&w$%wm8-iB&^o+rPV2CLx%%KkkgK$x
z9*bOsr4`FnXwtuoa`j@s^#ID%|NYP}wp@MAoaVcKx%%OU9-CZ+T@U$q!qDvGDnz^Z
z0O}n*6v<Whi{~C!*%~;`<XFC*_H}Wz`-j%^ul%cuW0rqNae49s<>Ryu^9}SL<d=9p
zlZ~XCiOc9G$j9i9fo}*JX_m~lzxjIlWit6Q{k(?uZKR(}`8_6>*Bc+|bf%b|Eok3G
z`mye}%H~tn>U^i-QWgKIcF|se_B_5l8{h{1l+ML^e2vbzj;&`r0_x*8?&Zck&PnjB
z{3x7v+~4Mh;P(Mnhknk6a@XJEa+f{S=^(z_;59&xn&4m6qaQD>Hx}`&$`7=Ef7FFG
zF0N<Q{&as->!Hd&3cnzJ!XM#{@I`o1+8x@Tk>Ahb>En1LJLl#5by%Nq<ic`41N_vO
zahzAt>;dJ^h|W!IJfXS=P3KXH70malyp^$CaR>ZJeh-D>1+-77eMpSwC5K|4fOgQ#
z`vjEZ#Sx^hd=L3VafH*E;%JU=Kdj<tJpLK-6ri2-Jc5Pi1;l&PKLx+Nl>b?S@(kx|
z;L^?aP+y4g;t5#az0~*0_4W9kxZIH_r+C-{us;9@pnd3VfZyY+efQHIfc8OQar+7A
zInsxK(dhRA^y~i71JQ4NUO#vc?UU~vi1zFA`o@D5-8~jMde6{fqazHY+|O}3JP>sB
z?L&S!>FAHK&a<GSJ5cT*($Ou}{=uW8_dVE~j=pDj?sEMA&~KfN-eT<^JUV(^Oh;5d
zrqk0nKa}{s#^uI^%pV@hD?2YQxuNq!?pgrfxg7VWM0ufiL(b^DoYNEd7kWhbcOKtO
zr+6RBDagCH{M(NQeY*a&p8HJuqEFl3(s*^g#^Yfi=OA}5jw_8mDPLxmbM7xM<(%7>
zrJQqrZ7Jv6|2Jnj$NUP@<(%7}(Z1T5z@NReV=FmFe`8$knZWPJUx{_Wyf3cdz4oX6
zi{T~pp@V_<E3ADU+&K{K*X73(V!ZcrCe!3d4ezJnd8C&;GDp0A+8puv#Dj#_!@s0>
z{f!^b4zIuR<KB3k&Vbja9Av!yYmECK;`QA>uJocYk7sB%=7+BjgwSp*vOKZv#%TCr
zisxs9OU>?je}D;@H9ioKD$4TleixoZ{=g>?cb0}x+i7h#7TURtcH;@*v-8o;Y2j1z
zQUBKP4V-&u+#bF;z;>2@r@I}Vr#ZsgSr)!z<2p5b!Rp;=dAm^mUa!CP{_gq+)k-}w
zt=%{(eCiPNe@eLP5cdB+?C<Si>Jaw-y{~uIhlP>a4kqfIZ23FejWw1>6661el=Z$|
z>zC(b%<Uf9jgu@-P`hzX__+1AH+*hB>wWZ}yZeJmkcNj0knP5a;VU-Zv%{BdzP}g#
z(dXHy^~ZVs!0W9FpS5}ZdiV?L?{~tdeSV{H-X4#uNyB%%-dW*WeSphN7Gr~TJ*Bp;
z9N*Wy{By!z*gC#1eA?&Jsm+JynZE4h&kSF*dAuk5z0c#E+B~@4U-0s0Se$&;cz5_S
zAOCO0aeatuG<f|VFaPZDf35v@+Wj&Z|L1zP|G&Nbvn;<$*0{m)Froa}weiE^Ov7iq
z{ORGJto`2%U-j|d+7n;@%*#JB%v%U}zCC=-$G`g9-Rq4A-ZXr|%4dzY*}ZWX$CjS+
z{Fs+}Yq-<f+gTeg>Fy7`+*`tZKF<GH8z(aVq~Z6y+?&H^yuB-G;~TbeJUEp#ej|Jv
zIkRv+z9(LAV=-&IDSXE9;qPkW!xmK<e%JebWB3Oj-;-+V#B*cx7iEp>!`(i<57)*=
z{GtMuHLeT)&)a){tv%w^Z+gFPuzX{f$5FNMk&c)UFKb*IzUJ*s*5HQ|cWJoZ+uIdV
z?B6v)7^;nr=l!m+a`^t<o^UJ5@2{<WXFrH^WBaeDjf3mMgZgOyl-hUX(MZGAvi>`3
zaN&HfD8FA<`%bvg@rm{islkiq2k8LB_wU!{&+)A*+y6nWefIy#^7~)(Y@Z4C(EgHI
zeV!NOfgyaqsn$R7V{O^~*){lbd@m@!A6|nW=f{J<X#av*|Ktx$42bVvsP)h9$Rfe@
zySG-Ka)R+CsQ>EP{7KIY(8l+V*2YJAVgfIGe`(MD8UKavFYd`#7?+Rl@2U0w1j8RD
z2Eg}k*7_%Y^1K(mzp>Uo;m<r@_`b9Tf6kBRSMmM3wf-q@=&-~0r`6yWpI^oIPxb5{
zSWNi;ajib_kMY^4zpB<h;mdeoeE-eb{4p|}U&Z$$YyBhS6L!&^k)Ac}yhknX!uZbX
zr^RjHoOf(bT#x7Iz8brKMsesKPl0Frbe^^F{pZ-8#`*m?9wfG}EgnCLm&ZJwxU|YY
zuYCc$hdk+(FA(|W5HIjp&#!(YBm59|lFMH9b9m)Bu_fFmkl(h-qwD+aeotLqp0Ct-
zOP#-@KW6+Y-=C2GSohy~T!sAbV>})m+Q|ay$;n~VlanV>PfpIFo}BzS_2lF)Oi!-X
zr;3XTM^<qSX?P{|++;EJ<>VOZ%gGtkmy<uIzMTAp>C3&^8$BX!j|YF+$<frClV?$H
zPVT1OoP5Ug=3ebATpG7?j*n}U`g8J3>d(ois6Qv4HT}6)JFAw&?L6Dtc?R|9<Ym;O
zlTVu--K+lYu5mog>#wFhot#g7I{9<cr+d}EtE>N&UjOOTtCN>duTG{+ukKa<jxKmI
zF-JQ&jrw(RF7@l=lcrzys(()uw~~et?|&`z?Bq{Ovi7QXU)Q`rLBO{cQ{PVRG<~~Q
zz0ft@MPBbk)Vq_9ncm&2-UD6r7I?iEQvXgqYWjDtdJDVY+voLOKs`M9i0R?I>RsG5
zKfBf_w39W|$CEouAMaIfS66@kX8f(4JfC`b^50A^?^SPG*ZjWc_0FMwp8US)=e_FP
z(6xTww0c?cA=A@)mEYAhudjId51PK-tNiY+`FzpKf57ziUgdA-ng{Qf%97hnfA3ZP
zj;`_lwYPtp>G8eF-_<q#&w2Uxn?B#G{C!>HzuU{-YI=RI^7nL&|4+UAEvDc1D*r&&
z_<3S5OKvtjzgPJ)y2kHzP_ozb{a)oS?i&Axd^~$h@9$Oq+^+G{5sZ6}p#S$OzpZQh
zzh~|DDmU6C2X30N+`_JMlt{hWJELoy%!}Tu+^Vi}Z=12-Rb6mpLh)Yhjdqoz!?Rbp
zbGzV<Y+b$KcSct^+CjbAyQ8aL1|IY(cTZP)n`i9zt}eK6f1p=;_jRo=?Vw)e9_Sk1
zt7q(YVOPJen6X^wYL5vrdi6WnHDB66y~=ItYLEA~_bPWoS9?t0(W~69u6a=3>Q!!c
z7yM`k^(uEm*Z7#nr&qZ<y2i%<lV0U^ca4wt1oSF*SJ(KcsP`&&PuKY9NbObbfv)i}
z|8lQ#_jQeraSy%9g|7CP->_G?bGydp`5#Mrq0&dUb+yL>zrD&`+%-OK*!3#6D}rAf
zKYVX=PB}jBfuGJ7C~i2;J7DoDevWR+&$q(<=q!!SKY1P+<qOsM*Em1b?;IJGSA3Vp
zg(&_3?ZQFVvgnKM_^`y@o4ONHeXqrbqy9Ta@SXN!ukRPycg8XG`aT-xBb~*({$#kC
zm*$UgylA9)FFU3lFFxV>(duWw^UGmh6EkR@!h8c+gFZ~1pG7`!{PIPN$I(7vYSw!Q
zx$jqMe#pay8Ml%lgW$o)kA3?Ot8+GpvjPQST#BQ)<%if;v0>Zy`ab&ZA6EM!2Qxq7
zjXyjv`4Qi4?GVp&-g;m85#M0tg}=1XesS_6^4x;fNAYg^%8v*RgnSeB*Y~sGkNMCC
zKlnkc@&`Zo!A5gC=Zo+7DLzqol{fVHxu1k^%rD_V8sxjOxcLit&H+{+;tIsKiZ$e)
zI=2fxh@bdayiacYtCmj@^!Y~zIgj7_7FB)}^mkkIEI#m`IgjFX2O0jCMeqjvua2H$
zKK<~a6`zjd7=Tj3>oTvX<8iC6%B!*a$I<>0_BY`7><i)C$ZkOYoy8SCC@;iJ?O)*Z
z)av_J^GnXY{CDSA{+n|w&wS;xAI}%(*#7^UWBI?HWBJd`vHab0EdQr-EdTL2mjA;!
zmjBQk%ilW3^1nC7^1nUD^6#2s`FG5*{BO*${Izo|U(B)mm2)h=b&lmX&api2g_%9Q
zUo^+|FPLNb^X6Fo1#>L_+&Pwiww14+8<5>2I|%Xs`zg>-I-Sln&10wMC(^#np$~S;
z6X?;%qqHiLC&;68S@aC~g1fm)&R~DZ?H1S*kYi<j$-`*Z<_s4t&p*gMkv(xR$GxjI
z?n|O^=L=yKMDq9;+BeDz132K`pAwE|xm|P&>p`BvGSWF0o$E;5UIrecMV<SAyv9n5
z*Ym`<U3D<w@V*)x&WhpS_tL@piuKD9D!9turuD*nG5-7*>dngY+M37b7!NRS*p<MK
z;yHw?@B(lFW(Zz&I8N`+*TwV70w259<^10L;~1mi;{opfV9i&0dOphePSH%U`(yAX
zPx!u-&>n{!V(|66a>xsSFL_G*T=rB%AB6H=ys<^Rw?lrF5%&kko<V)Ut9g>IKfxMW
zgM5}>2JhjC0zM}v;64!+9QS)D)t=7bX#ZUK_VL~5fYT_~J5R_jiWB|3`6|w%SjhLM
z`+StwF!g=?az1{4rOqRj^YD0c;2D0ZFMJ*H{EC<le&TBwr_r~MQ}@A?`QY52lm_ax
z`6B0c%Db!lipn#!n&<J$JX5P_SC)CER`_{^y*_`PJKXE}w3G*KFYAeZlyAQ-7pBD_
z(CiMm6Id&yUqJINR(L-b`gw2nr)Zq1?-MKk<TU&HC5|_ax6PLjpn&J6hAOxgeqMWu
z$L_-MeoqqYe=JdPA<ysYehS4^%brJjm;RvB$#3;?hPCj+kw5n;|LLgzDIVhs#R7+8
zZN9>nVh!OTIw)>pJc07D>-?nr1<K<%<aDKTY?F(br&{OSCKtQ^!_UD@E@pf~agyWv
z8=MaO{9m!1^i}x%A!B=ZkHYw3#`R3>p^Tbb%s8Nu@A>%in?3Kx?acdud#SKe`3E?k
z<{P<gX*k6G5j~Z9nER1SyOhPF`xcI6J>`k?bDt9)M^U_${btGO0m4-NSme6^ssPW>
zK;ikIn(Ntt=(Vy>m)VEr;ryP4W9*+PhIh=o4nQ!>*YCTLo+3Vxaa+4w_uT2E@VuF=
zdA;*gPg`%luSn-&O8EKwO87Y+Ds<kHVTPgAr~K7FFrA~`{>0J5Bju}~IGO|1IeO*i
zF7v=0OMJ>taK7Z{p)NXndOjA*|ET+Z-^#ce`9(o**CAinbq2<e-_Gx%zkIjzv0F$l
zY4{zE-}M~v%MuRKFB}fl`hM3sDAxG7ac+0)cfBrfIp3Ohztva1Q(U(O1S!`U1Mz44
zrq%QNf(KIfGkUvCIJEawkH@hLmjUszUb>%p9y$X$=&E<|zUvhWNYBNEo}cX9HoP$8
z`PC=1jw^f}oo|RQP58P9PiCZB&wm1XxA8@Ja6k5a<iRC>*Z0)p_{;X(|1SA0zESEc
zy60=u`5V!-+@Ha6;Y*os*yS_wHvvMe#^2b)mCqJ@4dvBt^IC`F4E2fyJdahv$Ir9t
zyw{N9U+(upjq5y`=Q~5Y=nwSq?(cUx($`ube2l}(rQwGhr}(3v6Vf@bVgn~$!pF~p
zX&#01uR?Kz(fM6Ff9i5DzlC&@?<RiC3^%{$-Qx>|7w8`lYo6e6<DZDnd%cLR!M{Ns
zcJHk7Io&TeoxW*N#B|-YUVcCG^!4(3PG>q_ioBy3qV(2Q!^e$A!SDC-oVo6^C@$o)
z?jKS=<vs3i<$1k)uhWg2#$~%suf^s5-S5{{p1>jTbEh}0!;t4y7Myd6`!fISMTc|1
z@jgNqKlc0LfoGpbepku!a^1;y>-vcJa$Sxn&a%==2$xDP;rvRy<PF5n;+?LSY<GK1
z=NVo9FO-Ksc9-iPX?WmKTMs|)I2GL&(Y5|B_4S)ZudlcD6kLat_t^aoy0>2MOa8mu
z+jITD;`fZlm%J*@boqFT>w|tDn(j$2&gA+Oo;S7R4}OnD;rUgEq&GO7%Z^2K-%Nh{
zJ8E|MAaZzkp2>aH`_`}{qw^n_hN>qy4nI(Me0RAMqH_Cc|FgAm{ad6z@2lQ@wR+#1
zWxWS$^}adFdJAiCxNnyAPN>!U!Yu2ZQLFd)S=M`bt=|8dWxZ{+da)g~uXT8Ht=^x`
zvcKK6dLNr*y*q35K0M2M_tfg$KFfMbYk0k9mi1QE>fIF81K$Cq8y!6^q9?y6PWf>p
zFLbX0%3p(g>dyaSJ`TC4{HBmgxX*0D<wUW<^WpBKyl(fOY!+<0zmIus`YC|2{y#7|
zmj*IE<YxqFXZ@cuPh;xmKOnDp-hmfb;Tfz?aXIn0AYU-<ttL-s?<=p5^e(^y9JF~@
zH(!qP{LjSK>idzKBRJ=KJ^$pf6okqjR`PG@5l4H!ZYNask;}VC4>38SdVas{^m^Z>
zUE=mR)U>X8)A}1U%P<XJwR-LTXIS~Hzp#jktbZr%SGO~I`5n%C0D3a#k%r4`Ceo|Q
z_yYMM-pX}o_b)a)$ZsZ`+Wp%cADAd1>;J#hd)&{md@wP5NW&s)f5`nC=m(+{IfC$m
zJ!JT>lkk&0IO1_lx$eVqxHK0l&oLcc)p(xdaQJ73!$OOwsKzsB<Ei7D<T};`;{g8M
zkNny`Pw6Z9Z5&@b53JLS^YA>TBd)(|9?hdKvU%&?fgzt~A^mxP>z{_-HI1X)|7ttW
zm-TNb@AKOq{R})N`uV77s%dzy<JC*7-{L0f?^*xj5~z&2$EAX+*7-{|-k4qyfhoU0
z3^$xl6x?Lb!%l)mSH}n46Nqb9fw6VCO-69Tci~ZM{-M_1G<-VE^{S^60hcEy7@pMe
zLVi8qh4}9WfESJjX&_;WzH|@Gg#5DdYfMmo+gJM-H}LLvW4tT-aldDcZ>HhR2Jfu@
zw1j+jO9H&mx(MHv4-U*4@85y`<u~bp@8JAexB5D1zM|XZ$;}<Gf_=?faD9CjT<NFD
z`j?m|9r6kDN<-W5GV5QLz)!DvR($3?29Frecu(icjM3HMS05MPzuVwHSGm)6x>;r8
zlYc9w1IWLb<<_S=7+@Msu==v+s`<^HZ?$6lnPDBr{a%Xwt)K9x;=9`ozIFPm^DWU|
z9UpSPr*3&NVDhOB|6cU=jCekdkMNU%f@d0s;3qz+@uXpajbGm%3w)mxk7ow>0?)9X
zC7rnZuftpMx$v{0e0@HX?vFt|eAhg({=ZMaCxu_~XHAf;m2kgk;)jM$Gr?K@Na-iQ
z|HnOC-J>per{Oz4GhR0K0XM-XrdwEtCH!jo!DENpA00Hfed8ww2X0^d$;^64FSvo<
z9(cID{h+~ZYF}`3|I}ll(~s^0ZlW956WF5ZrJtZ{!7<iPU>QuuM>=E=oPI*TR(>i8
zdU^8yX3Z~u3-d1ZhQBgB^FZn+Z;9br_CtAD=U+v{zaZzuzv^<~boYm+;lF{+O>0N~
zHSP0&Pkn7!2t&VN)2sGDWj}nt{mp()O35#@zqp6`nDp+M^v7(lNxXM^PX6)f`rW?y
zY|LNB06!mB1;6`^ze>;kS@6CUuTM=r#dr^wbuYY!9@z`;5h``?@t$^fek$>QdGg<8
zjrXT^;XU)l97w!h5yQ2H_Z5Gdy`DXa_G;@B%RlJ5S_i>B^>eyaf3w#M7sun@N52;T
z@|f-N(|gkIto6fbd~f!8;*XFgR`$BDPo2(Z&yVQ9m{D)?{bul?Z}#XHav7Lhtag7=
zjo+01xTu{q%djuR@+Du>zK-*?l8?<<UwpUO!6hGadwH(<V$8=ri+RgmR?-9cSbe^;
zg}eB6B@Z6%=_lz0zhfeKAb8c~OgY};AdNy;p7hU}zkCq$oe8fTp4#67y>`jFpIHvQ
zs(bxhuKp}?=muLq?$c{t=>cEA|2gaR`{$!7c|QB~n>~Nn-UDB!;c4VY>RLbd<H)a}
zc$&H3&-$M${v3Y5@#ma<;Llw7Q>*`oE<c^(2(t$Bq2;%5A2>gY`f%}d{>{&#peo#t
zm!CztE}qW6In!f>;^~HlA-~1r&C2(#XP5O{|0vsKfOwHJkgIqS&yyEN@*V)~qe`!u
znXi6n&UW}w$cOH6VHJJ;Uu&o2V;;|`eS_KWQ+&}9pD3=gF6SWEp8Zg#qquAFHPJzq
z{KV?(eB^BdjQ72IAXvsR#l5tX2OdEjFxq?Xf@<HY8b9Gb_wnD&{%5_<@`|5AF-gNG
zSue^TZ1=pHSBUX`(7Q0+`;lK&`b14%O2ap1-OfMlvz_6e0yAebp1(&s)5fvBXZ>D&
zw9m)mDCPB=_E|sHPyQ$Bm-Sv?aTE1%_v-iVp8bAepY`K@Khf3iqqDB}(XM(cX<zw$
zQSrHctUvavzfwEDX!nB83*nq-U)Ii>M9;vJ=Aji{%ia(i@csD_-s2hcAikk^!eTY$
zu=1xBD;WQpA5H#~zl8bAixtenoxjBMny=t}QCWgpT%kXDy%WgC5dVve5cPPfVui;=
z`u!G)6V|z5#RtPba<A<ZbKk2xSHGU^>s&qbLQpd1R~!}04}$Z?kOP>3@)%5bfL|+N
z9tfSYj?b5Lou4>~j5_sv6|MQ&ALRI#EoI#4l=}f--`hPJA7Gq%{(g<ypIyGIKgHj)
z8qC8XK7{>ONEY$O!s8ZokBj2w6`z|12G}TWANs%5cl}@IJkTyA7vPG&igPShP%fq6
zYvk|iU4D6d{`B)c$gUZ>;?>xn-wPL=d*XY>O-=9L^SrNMykRQ&vWIw83=_}tJ)Zx4
z*z@Rn9(v`qEAj4T*C##R5BPw2rgmBZ`04lGxjt1a#^~Vhp?pt0KS))M_E1$$aH3<d
zD(Cs^%l0@gop-9r5e`*3&wKB2V({CW{p<Vi6`lJ0R|_s|KR?gu((gIV&(l3M%wu1y
z@VGsvW9|Pa{<ZLX-Li!76S{8`{OD76-)%{)?!No(zWn_hXLHQV>(W1@c*Eux1sLG{
z!TA+G5+9iI`=gE@Abn&5yzg4{EB_kmzxe)6r&vHZO*_A!JR=@Qi1L3B^;g`)dVnK-
zveT9w!41*;W`0-v>csVw|HT^O#l#ya&~v8K4^unXPW~HC4{vdNc@y=&V%-0}i|>m`
zmQ!3zVNnMmOup3Hy@mZup2dDahu|0D8=w#H=T?L982N3!e%n27<5koHwN6>T_q&4a
zw)+#SpN7ApzQ^=U;kH57j|N>oay}%!3^<P5-|0-bzgzg)nh$NHiaU<WzdnMy;&*i)
z7TP=G@u9reK380%!zUM9Z*_XO(B;OhP7fZxU0g^%YH<_kQ|BOx%bhOQ(C@2rIORE=
z9{023o~C>+=_kM0<=8Exll)fR^MG+1{7nmEoH8&c-%ENEUFzIc8Mo>B8|rVd^5jF)
z@15X0V?V|ZzJqa*uT=L=aK3T5?|!F}+hfij+KqmTV`w)Hu@Sc$OKhJmYfv6UsgEq)
zB@H|XhVsY^+iqmGKaKL>J8^mD=Y65AKgz))l{JpH{dbgyYbY)c%ufR^Tx&NDw+uKa
z4-7?l9C?Y$W5*)({8(Az1jg|+R+#@cE{Fa8)bnGZ9gHh$JlQyPTn_!{o@%s%@nnr(
zGfo|s!#q>ZkA-$Hj;ztN{qeXQ);;z7Sn+$Xma)S~7g?X{Asz>x1_rRj<+=Y)ff&CB
z{8H0ey5RyiOW%mgGv6<=Hg}f?Dx}I2?EX6Zz<N@fRd;!eJhj%k-!tzx^`f{P=D`Nk
zy32!ADF0Jjo_W6+pBKMp{2d7;evdrKtp+7;l~;+3Q|EtUI(YkcI-MzxACP?1`B01N
z^&jY1_L<IIDZc({*B3YV`Hi)HE~}k5Jtc>do{}R;PYLy4jU!85W$)8K{jZ%oj`Wlq
zNqS0}1~HuH;rdfwLVZ3nZym}TT_sN<T_r0RH<l!h2gpKAyO4PCB71HpOG#hJaip*0
zcw14_i}3;d@tJg)B~K)sCCd#zP(H>7l;<<$O_m%(dP|Nq%s}}VA5fmpt8H8uhtXYf
zg5d|s$M}HqeC9<m7>Chca-87@>H{Cfk0X7dJbr0-iv88|_^JG!dj4*_CtZ{8;hB8H
z^VanRr?+Yy$S+8j_)hwwoW?USRrfdIne^m&>-vK8N9OOwehAhFdWZe>_)y4$Q@(>Z
z$13k!{rhhXR{9d!B_E|+$1~~7>-X_|vGQEunRG>c3eU_tj#fCHEnBbNGQN<2#Q0iU
zuGpgel|uRhE|-TraFy5V3)bVf^R<%Bn2tV7(cCNdrA2>e9}sNbNIJ(e{T@^-iWQWj
z(&M22nA~ZE@b)<0g3kl+`?F!#Z`JsdMhI7Ue4F^E;)F{*;jPpg&_6US-OsK4M#*jE
z2iJa9vD42N`+i5UlXhOQ)8nxszm47dc(Z}c>@E3mFjDCe`5tf2^OBe6mHqr#ezUjl
zc2jw-Vh#16$*b6Yv4r{OisN{2v^dq_c{UZ@a(zg))p`KgF#p;-ik+@Md3-hC1ch;O
zn0b8SJYANz%k3?k|NHBRuj)MP6ql!*cP9Mx^;euX?26kX|AqV^ct7|EWrmH{?fq&!
zs2|1f$GCtucSh|2?tdKVrSh*AONig4-M57FrF-^@CB*yO?K|Z?pV&iqOfI3mUc%Y&
zZ+YJWo2mS-kSE|wI9CNam}0fi@^hW#{#g>j1JFmI_(T5>wAY(g{>1cl!A*FseyjC#
zeR!wq$2;ABvy=K|yk3T<WNX!Wx&L{JVklZSDiE-{NVgT=!t>-3;@f0Nf7);J@i?B!
zuTv}`zRI6dEFs>O_m-+X$8*J#YyL6b?26WTe|UrX_{k0^^Jzx(EBv`3Y8UvkIl>>&
zvEVPihSneU8caovx5?w)W&b$;hoQ6*9zf0g{^58Wzyt6*{D3$3q2K$DsM=NDgYvwc
z&#!8q_e|t_=x;*(Coiq;-;C{(x8WWG*AwMempv#yH0nQVIFxxd^d0X9mxi$UH5|Yc
z(YO2#dW7DEIdnSzau&+J0{!`T;m^nSw$sCu+u4FI_`po(Chn=N)7jBFq266J|0z%&
z`rx-}^`0Ho(|LRCBZ!~PeqE_w$ex|ey8hvu)|L5m<8^%i_l!>v@bS8y3phK!mwb)a
za~{@H>*anFtj}LzJS58!Z#R29l>7lI-)nuBEoD7hSHt#Do^#gz&FN0(Jgr*gHJQtL
z4@T=Ym-WVh0nF3vftQiK<eyPoo$`Ma!@MsN^!4kY$4HNR_}kFqTrchM{Z#{1Klyt4
z<?=E2U%t!rt5q(C<S$y~a_C)Lm|_+G=6<hcL9-*|9;Z>Pa(uW><voAKb!?|tML%AC
zo%*9*4*mj?yJ8g`$ya#(81bEAHT@sOYWEwizSwBESj~Gfb6kD`e(HWQ<r^y2(0`LZ
z(Z{pK{Z$-hkY87MO^TiLyG+WDxq$o%@Px)#@oVZu@%=0>hu#tCTd%=$EuUz<hwF#+
z{<Y}7@hPSgFY{p(t65I>&lJPwlyVpM{Kf13$!~W$;+L)dYW?fwj*8d+#?c21Uc(-b
zf8$brKF#{cZ(QilXYl!5jxX<YeDT1TQg4~?^_AY@^k3>NI=|y`IlqPT%g-df7fT#(
zbY6Ff<Bgx^EtWXm_<7$c->)u~5P$M(eSMeEACzCK@lb)tuXX%b@+#uVTfKje6Dje}
z<LV6WfRCpVAB!cRw(7k46>p-Tl$?`)yO3Xd*zt3i_?gY;#ETU?ztEoFFnR|b+}mH#
z<<xr#k7@hGx>wiFNul2Bu<o38$oI0{7MM`P-{SKB5clKrmY>?@?{a;|w>usA4a#y(
z@96ipA-DHB-nibTeVY7eUx#7p!@1`@l6{kVUL@&9x!-?Vwd4CAWjT*iE!%ZJY}u~s
zl{){whxjXc&i4?1i(%iNaQ}O86YUqQA5@#kVc)m7ob>*)(>duC@cQtBola~1-xwW9
zkI=b-DZ1xMeNBFIj0+SI)A_S&{Js8tceK7GzI*<yk{&$YSV=Dnxn81!f@EX;8$b3u
zd$Yy!k}nM3NWLMyF#HyO7Je{4X2}<ZbNfDdldpsG-Qp&<Pj7l`{5IALUmxEStaHH(
zQz_-E^k&SrE?<Xg@UMU07Q_EW=Qo1?jn0n*{~H|+g1^(Z;9sqW^F{Huh0Yhn-xfMw
z6n|Uj@)X1j{<V<&3(t>bJtYrOAM&rH6RnT$W5^Dgt2~U?XHC35p1)}>^zp@Sb?ZNM
z`gmr%J|(=kP8B@4P8GZlEPViuXt9K&>l-CJ4<NpeM(`Zt@r%&z8#GT`yKl%e#dhBl
zOe4<vC{SgGLyvyLPbz;0<OBVv3?x8(Jh%In(VyIRy7|fC`oH^7cYXT(c;6=K!4$~)
zo<YBI-?PoKkLw>=>mMtX`aLu4zN6@0?mON58(H6(<{ypgKe5(7@Im)&W_@SS&)oOx
z#{c7b&#U#zeIRaBW_@ST-`w{+^E|}$#%ul2@5znKtnWqiJNKPup2oP||LR%qLX+cJ
z-?{WZ_nmL;#r3{a^G9N5C-wU_;lF_<DEf@`P~<g;+xbYXf0*8g;~71w+N^;bd*D#C
z&;8xF{++e@gctcvT<+8wT<Om~o%)LF5x~1A*2-~zfQ&jW_mWz_Y>)SC#^uhgmE-;f
z{q=FVO|^cZv6XQv(fBT`mE-v6KZ(oT*t1{yL9jmH1G8D5t9!JA^$E50`J}B6ur73s
z<6mp_d9N}3X7PBxTq{TXb$v3L|8=!;Xi0G-ak;))IWz%0dRml6U;e6Uzu5Ux!}(Lg
z`BQ`Z$>f;9jrsuW>|M($JWa!I+x$`A_*29AQ{#EYpL*5b9l<dT6vU`!{HgI=@~6i0
zjV^lCAMNU&@wm9p9C(3#AyKl%3k*Md)jzkZe=6o#V-5LJ<Hg3Gde-aecc;xeYrM$!
zpU<;(=~Zu6SAPtk%^K^-pBm$~;=SrU&{c1f_qU$>sd1^{ORsuobk)PH^o;K!f1+O&
z>v%&nAK3@7zv|8?&aU2%=ty=3+PmlBO8&?m!TWE0j5acU%D))*^I7YMc10TKkg4~F
zcJAw%*Ua~Foe|9|-N(ILtGdc@qoh~A+q(Ll`ChJzyUNXcFW0uNerLXy>*B6*GvCW~
zLs!4_KZ38{6TMg5pzIsPTNW#*@5g$it-I&9MR{8{j|W7%cgE|vg7#uu-_~;l*R$fg
z#Jkkv6?(yWVb^@S_Zg(`0uMr0Ir7V1?cEj4U;MIHxjUkAq675PYyS!L4IZT)?)y-@
z?%n*vwm;_a1K_{!IHdA#>RuVZv6sH4Jg~ZVCrkQFUqty>uIhdryzeFVl-~~hUmf@F
z{vgZ)mdvEj!{A!|&d`1v%DwM#pj)>Gqy3U^c^p0bs4ZWIa(}bjUvv9jekzZXm7faj
zV@S#ytvD*#DX~BM(+^kiPV&?Dx~J@lL#p^*wF5Y8viDp-#i_`Tt++sxJAX0cE2L5A
z`Tbb?&JCJg^=~*VT5peg)x9=~^VK~B=<oh`eLUY)uX&w2!@SO$<-B$++V{L(Y~N>|
z*DIrWX+9YLagA!e@%w*?%F7R<zZ0c>^f>FW-8brX5#uo`zTx~S^6S?1>2o@j+=1PM
zrcGaaLae9oe#UlRzuP}gH+dNAPd|FJyB$PUrOr>YzGbG5WPL{)X3S-Le^YB$`u^@N
zK1PO-^*!G7ka%3j^q8OGxaKmBSJv7AYd5>23r^gij{E;^ZT#T4;-_)BzpIr4T?0S9
zxd7$Kcrae-llx!Sr`E=+b-k|(Zj5u83mg{K+J)W-INTMri*cV3(WT<TuJ-tmb~4|_
z(@u^sc;LQsXgTfVsWw0DYh?)&4kPXf^OnA=eX!K;qirVx7D<Hr$zgZ5latJT&yrV~
zo`?Fh=c(_aKA+!gd<yYqu(#XEiDvO+$;&KK4E10ErGW`-QIF5mdl7F2N!w0VnZBMS
z=NUv%kMUE?|A~5hrrwM4pwujRkwr{p$&1Y*Lp{7t0|R<dkI&S5+sR7OQL=_~m?ZX`
zT9j<C@}Q5@@1sR|&|#LGZFUsOlP>)p+7SGi0p%!f`hW5qvqw-K&uL)7L6qmS`w5a~
zQ}0jCFg}FxSjRMQ-vZ_N{7Qo}^0EVyv*cM8VTtnelepdrT(bHtFaHdqs4RJ=*<&bA
zzX%ibqCB5@A8nRAo&KF<wa3{dZtuCi8yJU`1_oSZ$<xdaktL@Yr$YO1ai``jB|Q1e
z0FNwrD($S~RN5a&;`ID18!y@?ebY~nB_~@%Tb7(+_otyeBHmK>51>4s=|Ieq6V2|z
z`2n-XlEmml`4~~2{tDN7gW}bgj~~y7a7;t991r6InZF<3AyVZhz%x7n;?sBr7f%iA
zIDgvT9@iJ-SEGTAXYj!?uCI)f^|-!3{Y3W|;29bIQfrm%gJUY*7T?iwYShW^^nXy`
z;XC7~83%)B`jKEgvph8T)JpLgnuzZ2KzaBvQd=c{N5rA@6@14%ce>vJ&-Bw!uH%{h
z6Y4>DMueo~vhLX{<IWe+9~<viJ>eUb9#+~1?ypcgGriY$(8$h<2mTIo{+lPC_+`D9
zeyVc{7YuU0s69wMI2)v1HgPfGCAegR{gj)2jzN4HeEgga_SY!eCoTr{13t7#dzF88
zBLsvsVuM6~bzY?vRvTtPZv`KcJ%xTA`g)w#obC52_lmx1{}JD>+!4YRM*t$h^zh3@
zw_+<fjBebrP5I5CpSLd=H77uO%Z43=-y@6ntu5`>p!~M>_zvB(f_Bj&#)lQe_`d%2
zZhw9K``OXBifz8`K2PnVXukyS;jfZ@j<}kOBR#_U!*?!MxvvR1jq`LE7wE3(=cBSg
zu4g{R3c|yDjIl%Sa5~M$`5ou@V0YvvahxT-`ugW5bDc4c&thHtJ^HnINBI*!h3}pR
zRCpNcu?T(9`%<6x^I37Z$puxpoa7#Iw*&K&InMlKt~2HXiY(i8y}yh*^6_H)e>1<g
zJ@a{czkhq?)e9^B(92$VvVEUf@Bhl8YMdIc)~AGf4?gkRU$6K?1vjpX%42>njNtYw
zJ?mF`7Jk3dvwo##{YTcb!1th+iJzAH?~(%)6Fuel{a@R+9Dh-x(k~`=k>5(57s|8h
z_ZOD^*Zoc&KZbZ>NQQQDj7b{U8Tjct<T)g_{Qbx?1i7s91$BR6F?@o>xj}Dv`AFrT
zDTY_sd*~I=)QVxo%c0zBBYV9VX51X!pVn2M@pEy1@WbkSINF6qrt{;9hnJj%AN8uJ
zALs|>r<oVRNB^nv3t`=UIEXPa4g_`)^cdtBfgK>YpxkktPDlFVq~Aj{#WZjRC-_fQ
zUj9euQJ;<aLp}hE8|@v1y!mxMv#%5C-C5JWPDrabYt(;RigELN(iGF)+c{$!hvL&b
zFF)G5D2B&8t_#}v%wTm68fq>uO!WcB7+!!Q#t;8WeSF*IRpUdw^>KfFJOiQg)~J7P
zZGM+U^)aq*<JnQFejZTkGrsdLE$%5^2lLlE9OL<KjK?#N`YQUt+3DCH`Ipf;Vjg$K
z>le-c!P@xGok#kHy*D|`dlBPyzlnCK-pvWF&yC=K^C8gFrLV{K%6N^BSh*;^`BO>7
zM^JzA(knNOd%O<lZ_DVUCA}XXZ%-<&3h%dWYg^Rh*p7``WiOQRHsyIL-%p7Ax`v0Y
z_s)b5z=Nd`-D5qDui?S%(fq5tO}zhGar0OgfEM+C{cErf|GVJ@p8wY0gOB0)ucK$}
z-=ID;dhOS=lLh<q2Vy?=eWT(dSu$mO6z~7>>(zU-3wlb!C+vIW7aTRa1^zww{j%gj
zTQAgqiE%3aP@jIfKl1vAx?gaW`vosB{|f4TEyC|K{Jxj3`vcE6|BH>k)(`zM@ArE0
z2foDpfi3gPpx%Ft`oZ|<|M)$xCx75ejqjuUf~1lQC{O=|#~GCV!1K%lgYrk!#znn>
z0koAraIMKHl>fb2dA1LW3~+t1@pJe=A@@+eSsM@JUFvaJS#qxX17BkOqWrUJ?Q=am
z&LBC@{ekD3p9tkYR)Y`yWAwXb$xGcI_%eeV%73!fKH<sxC$gmF{=k<TUqSh6YwffA
zR-f+$?hm}s@EPTw5aDTsj~l)GE8HLWD)Td;{10mF)4w$C<zH#=&5~Es&)x`OV{QEK
zr>24TPvHASweR$wF<>9x?~TT%cmcfU4IBJbbin)u`2L~VIJqt_whH)uMbGc_yW;!f
zYk0tU@*Fk3pIjR^+h<%BzTZ*%&Uw-AitjI|wNJccd?~&^v-X{M$T$Oh|5g`V7?*|j
zjHIdHLjNxPt@wU#ZQdLg{jK=^x!QO3Tg4gtpW3{LU-Y+H{n~f(4aQ~R`@3rG6K>Q~
z@clPy-@z^AZ^idVYwgGWR($`r+IP+$vmkvhtbJ#FjDp|i_54mh6xx4B?K|;;{uF$_
zruH5CE%E;Rbpw?h0C@wsBfVVD^}q1jVg+U@2RZzz7+)H}BJj}8zq(vICfdKp`-h@u
zwHy1lo{`Ysj9>k`&Ld1w9GHL3^eXw?`j~eM{amxSJHH&_MF6MQL~=dO8`DUu{*+fk
zamv~!&vW-HxgIy-@!hA7QMQ))o#zRP+Xp^Y_35Y6y(!9X6PMqxID{dx!%)1J{bD_0
zxRicuzh`ua=?zQ|gWl164i!7-RrposHvL?v!%hA`-1lttp2rG`r(Zsh7~h7Thmk8k
z<86J!BjmMsw#hZhRORu4K8u!$H6HJ;^VOb*P4OifpW<EW_SH1~Ejlj)&ZhI!%4gH^
zJRU`Pj-Bu>@yYKeg8kv3!Ee{HlX#D_?xO@At&8+BJR{Ez{(^o4f1KMyJD3OlmiG#K
z<Fkf464C*_WP88Ra0h2Qm~h7tM8O$<fnRzSd<6fj57Hn6oh!={^7Z^VT=!O^iu1w`
zbY$x^z&t0S+t@Do%db{;b7s;8@_-H#t*hdV%KR0+{)$7;IXLho^d~zL^Y~O(`&@VB
z*QmFrezXsz{;PR(^PhMgf7I0v^YyE}qMz_ldpgG_I?;R-mj!-*d&EEEIJO%iIUqVO
z+pWj3Me$wW-{8x4M(qMVZ;R|gJOe^nfBfD3RoYFUL*)xBPUL*@WB9keU%0RR0UX8A
zy!Tb^tVoVxT@9bye}Z%LSc&Fxe#jdACY8mXTa7{bopjF4$6NS$N%fEQvvwVC<QGXj
zpJV(U92fitay9k!m7h&~Js%_9BCig9x!+@tcJWjG2+bRL909@H&ruEWctDxo5&k&j
z4=C?RPnbU<ALGHdETP`Bd~lxe3E`>mLF<z>7_TGwH^kwU<;r>vhw>g|hkJETIq6^W
zx~xaC3YnjuY!5!Zw6|}G^pLVV(IzO*XIbCxF;2rjoBgi!DUPRHE<B%x_C=K+BliD5
z{}7*%{|ECBpWC>oTVJ`Wm%ie8k%9mB_hG*dT1AAn?q7@P|76g=zi$Qihx91-t_U9S
zd1u7If$sk_qHnYh%^!Ztdm_4p-{gVl8RNVxqT@Q>7Ch?vacCbY8k&opZ#zAVuXv<_
z{~*4LZ^Bzq`9&dbAupiDpq<I#pISZm=Rhyd8wlYpyx-~V4JbZ?2j4{>(vL1$OoWr3
ziFpB$s&Yh}A&*a(bp23zL2(@MBn`Z1d0+Der)w_e#_k24R~qBBdF<pqweq!I-Qaw1
z|GLfB;WoMAQJZgE4)(_Mat@b-@fv^|EDpd8j`GRj3O-;Jl26me)w@58=RUOK>xO;+
z|C!bY>i|gSml0lq|A^!3=@TyJq__Hg=`mgW?xUSfRo~ae>&Jd=B<POoJ+v@{A&YPb
zp?DMf7e5vs)j8h$1h%Vu_*p-o8$!FkI{&>irYG4ak>B&KuT*(2>-jF@a-(rOIxnty
z)BR!i_!Z<JelN#WY~c6{&wr|U#CDeaj<FqBmm9$IXFaYuAKx->0r;cO-{%EAdayy=
zAHQNX<FW1iX#Ae}ti->I)ovH~ed^%9py=YQ&ZnZh3(ylVo)=k;E;59A9v9s|A^H-Z
zMZM*ZtMZUYjzTJ){=<&-@;_elxl>CxIUP$*DGvqolvAU5Vji&I;nf3u%%=XCwff+2
z_4*j^+ai5O`*gYX&yIKa@1R^4eqns;YwZIw)xPkz<$f@okIfQ98DZawc{IT9PrIA6
z#`iqGAM0)Jvwbh-;fUYww)ge?8eC7bds&PRo|jy5R{MJzr_RmR@j&y9?Z5>l59tR>
zJ?<`N7;Aa%H(%`VaykNBfJqqFXNMoO%Y0ASblY1lTIhMtZmQt1`<DzJ-)cZVV4Sti
zMN1w)E@2-==W2jAcT7d=y~6Wq`T3f-9yp8gw4>f&3>VJ_T+9M5z~?Kwpu&&SW`Q5G
z!H3T_LX}7821DbLK0&wOGn3*!ehw+NbKcxz9Ke$<J~zyKb}{}VZ#?Mt(~ng4N#zIe
z^3i@2^yp#@&-Xx|>T2Kf3`<Wh)(}o*{(L`IC3`C#2lPkfmBM(w63LN$)ib@G+s;-G
za6)~^3GnmVW4MTKJ3Pz0@2jWtZ=2^d{?Bt=CMRM%(z-Ywsm}}J`ApY*$e)CFSf{1&
zI6dD8_zdV>e#BnuhkS}9AEJ6$=4*_{5%W3pcW+ETrM>HLi0s|lt^FDDI!18+P}ls(
zhm<#6`H%|FZ*Tn{g!!V~+y6Y`3p!5`&8H5Bu667&{~Pu-e{Q2t{zdbz(~s~@`6~;@
zBjvXg-;$mo`=QJWwVM15?_oiWui$zp-m<)J0#0`0cb>m{k?U2S2On|@Kj^LaDPCIs
zzWf&E9i0TTh2FHs^M4;sIi&jrB%h1RnZKrG5y8RqY$)>iEnNTB0QZTe-oy5q&!@aA
z^UHfaANg%Zcr3*59wTp_NqaF~Kj5R_0J?$>r96qs$3EqLRQa!3jgyTpD4(<FL~zdL
zabH7u1$9nw=sb=a<v?1VMkY-8`z*|}^-w!-YoVO>F`DQ9$m|-yV~X2iq18Cr$_-I$
zm+;YjOwD(@{pSAk=GpWQrh)u8_xlm#kJox?-(B?-FD`g3<2C3(ei!9;RlQb1|3<#o
z^OfDg^&R4}mG`}jcwS7waoIT^r~T$}y|ODO4yXNxa)3)V?;{<osOqJ`^Kkk+F%Oi>
z{k{kJOQ+nQbJ3a1_YeOEe!}0G@D%cXcaOLe;cphcYU7qaMf$M(GU~rvf49#x&Q`+x
zS<&^xdJ<Uf^BKF5_PO$D!~X-lTX}1X3rTOSKJF{V=f++e>BSk6`TD-w&geb(1uzBY
zN$|rnN-B>}{%+U1f1UKJd29TdSAMh8tDlD{>%Y_MdtN))ab-K&NAPuP`8n{J>SH}7
zYvadw)n0xx;i2`P-ahwd6)&!RE7S)ZR9^A*IuC>V_68px=j6^Q(xvZvDX(Cx=S-QN
zL;NgOyS!FD;&+m-Dqms#Zr59Xi~hv18@RDG@!NDrPI^9_@dfl}k85A)Lg`23=cPWP
zbLB}04|d5(%7K_4Ql9yFbGNg#p5Tv9v2(~|`1N`-tq1BI-|2KRx1R;q$>WIMlb-*&
z9#6Kfb-%K<?pQCayVgbhw89T;eMCQL;Jn4J^26LNisJsDKMHSz5Aq-C-kM5|xgLl8
z)!MjXe5~;3%j9olk3oDu^gcy&2rX|*@r~kpE#qnx-&1+<8}Xl3LIIw8yy2MNM+5l`
zzR^m!j{CCrclDT0YF@0c&wAI?>VczZeI|Y1MfV=n`QyYG0ig5wvWMkwnS2kw!w-*k
zwQn;Ge?0GRzJYvaY{L1c>oxEP8vpb>;H`$+y>F$Q!g^jG%_EyP1K*s_amWske97k3
z_^A6u^BukUsQl8c@K59?e!r3MQ}`&mUwB#Oi*-L=8op@tB^O$*kCgpy@8-jp=NqDV
zitlT^%K33Rp%s{)TkzEP$(x)H`u?=;otZTsEbpsv{cwl#!7H5)ZgW0(wevxbb3E95
zu)Yp;J|VbkJ#_EcW9AdCS8Kh~u&0|}`2LmXLHi1=gtiL&)2LAL0T7Bm<5%(t$=L=@
zGlCy9jGiXO5EaE|{PN3)FFMbs=do)^PvR$8Lj78K{_;0W$Fq}bc!rS)&%_@muOfY?
z;Txm_$Lo4~8b9#&jr(Xf3*WVNs&+{qz;pb@SJTh0{l5)<Pl@g;f&FFsF{jW^X#NQ7
zzntQ6-kyJ=S3Pis<|&NBn!f+w`x$Qc?sq>UD!0%548MN_`l0P-^!a{<&lB?o-_w4+
z_9w)@bgowOLOZs<(&zgyt9{?Z_g}EjVf#tipDOS1;J(20dHa4zZ9dcXOZ<GmO#P!D
zEMZKK*w=u*apa>_e3$$kvx%F!7k=`{zE|AT#Yb0u{CM91C)Pzz@&3a6sDHi3cz=a&
z)qdE2Bz*f{Kdtah>pd5|d&?a04wNOl13v<4O`b`)2tTTRkf6nx<kQBt?3r@4P#$W<
zVbsr;t6h&@o7V0c-{)}ukM3*H{U)U!UHOhZo<jGYwgwr0l%MKx6aCD;rh6;$r5vZ)
zN0<R5%7%XOulz{Y1Lu3ZhWme7eUx{lp6d5xl=}KRx$ma?G9-Umo)06x*1voH_n5!H
zE~w-@HyGhFLXQ|9MuhR$-+so4Wc_sTq~SZ1XMRt0HlK0P@%*6q96vu;=7$mvp4SQO
zVg9-Ad$#%*A5fNCOn8l5OTIfkO#5)c^Xe)O)tKkqmEBm%*Xud&Y#!yf_!XWpztr<9
zOoQk8nc%5=TsiNG-r0T`ccb`C`3av(y#cUz^V-V)dQnOSs&*7#R?(Z^uj79C{958?
zem(8tY+h9#KRk0@gqPY)58C+LKKFe9?Mn#`LvELp_Smt6!_4@HQyBDF3jaW2z!Tvi
z<X1KyU$K777gyrTBI?=A34N#E5^=C#Ayqlj*^um)!#FPaho|9#+rt%I(Qc~zZ0t|^
zsrXoVkCO1<70l0{H5?zU+M;s5XY6@y&-u9Icb0!ROE^x{gGWsJDawC__sD>v_hozT
zUzY#0y5H6J?;R!MegQA}%~FrcSAK8BWwsK+H$TVW=l<JrKiBUCs{Ag*Uu~^Guffqq
z>AfxYU!|6PCWQR?T+h?rLwz200D8(?|5u*IVgdah6D}_lcYyJOLbTsL;(kZv2Ptmi
zK3z8Gd3pvfu$7#8pP^U4J*QYA@IU;$+W)Fv>i6#f?k1OfKT!K!&4lBZ-&gklDE|fK
z|2aD&Nqzcff#d7D;7Hvrzux=zxDLfh>%K7Iv+NYW7xS#=wa|G&;k)2j;v>OT+WWd^
zNPK6AXkErnVfnEC*zy>(AwOT7-%7q)p2vid0z9~dd@v0kHhDAQ{B^@T%9YRfU-7&4
zyzh75pTskMY4{hbH+ClN?RY;BLmNNb?Qq8*={ds7$sH8*;?G)V#Uq#dXu@}j|B&~<
zcVu8{h0oh~gpa~6`~_UH`QG1klz+;P2>&0(TgmIsSv!h<AwL2AdwxmBW8HrXd5-n1
z;NWuZY^Ptpk5BVPc^l85<I_0Dqj(Fgb2T3BbClz8eA4){<c~TynWy@S=MkKA-*$d0
z=^69^Q?wO+-{zTL;`r?G9y8%{E4<&zqksJJ+Z`TmcQ1R5&v!rbksg$JoGzXL5AjLO
zuep@_1L`jg@8Niz{xtuY$4mcQe!KRsIRD9|jt739-1t)BY3lypY4;HE+RBnX#dqrQ
znDj#~D*f_;i|p5uF92C$zl-m)h~DLgk-W>_?dzlXJolT)zErzuc*x*0#W2s1pXYdf
zKIJm}jOe<REVRFhKP%6jT<H4&e(nT(9_7>UY8!9<e&45;ztr=IN*@Cq;ir52@{9zl
z{YlZc@_XgJpP8TUc;ov;sh^jFegO)ZIF$`w&`<xuT94P$`6I~RSRTQR3r%e*=XlmC
zzRCF=<QU>Mn}d}eWBsfmV}l<ZevGw_=U8W`T+kbE!gVdxsjmJZ*VSJ(0Q_1MM%-^P
z<bL&RKH^#zmFot$7#~RKFIsjMH!|J*T*?RZj}|}Uf7{6+q!+*c6Y~dzCZ0ybQrxNV
z4C96*obr9&4f6@twGN-<;q#p@+d6ZfGj10x%FmdFuN!^|-y~14E>^B~@9(m+2&f5?
zSGhkueLk<V`GC(N4z_uw=Q;HF+UA)Y=){RWKaX2RJ6Pw5r#gP5T(=FW&(G;#;zVCp
zuc!BrbGEK#2OkyIGA(InrB~QGiNBQo$`5$_!+S`N(ogc+sed)yp2}}?I&pnddK&od
z$L#J~D)1%Wnjwx-=jFx6(?EVJKB0cHLDG-j*ZIV3^@Y<frhPMUBl)BFF3u?!eL3DM
zAKqit7iQY8EBTt+(`opK;hRF`f!7#^?w8L7sPAV3{lq`#3y5C_rbsWp+VNBMV!a-}
zGQP>{7jNZyN=`{GjvYxvuHs)@&J!KN$GsoPvkd<jKlE~kxttdt_kG|>&Qrdn;m0;_
zwWt2G<eetxg_rVEsJ%MAh)!GKZDo5lp4%u7g`dm75auvW!8P-7;@RZ4;<p_R%_Cmh
z)o&Vh+H-y@=_B7wIA;ywU2~LlDt&8NgX2=X#nek}m|@8M=qfkC<JIO@H$K@%ehI%6
z{4kqOA>SzDXFP5}_rEG1M)}_PhW5$R@OqA0_NM1o%QKhDel7{{hRIjTZQWZdc@gD#
zvGcf&2hgXXe}X?e?vUzyhV(em1HQjA@*j>ZqyYeV1qpw3ExtPb4$Q;%czpFZ_T1x4
zG_P{s$mN*srPVwI|H&hKe;$f0=*j6waG0h~IlbtfA>pz7OTyc-{bA}glM6^kqR)KX
z@8i3~@8@fK-k}K27N;qCi_XKo^I@DzVg90gocWFNOPCKSZ!`aq>H+R=f4I|`a5|pY
z>v|T|s*p8^7~sFav~oXvFY)^qWj}qc@d1jDlij5_gqhZ@#1lV%rFERtJ?3w6IYn|T
z<1XZPkp4KSd$c|7VMaWnm@4%e-78k&Qxv}r5ntlZO<b30;~3<?%5kjVI`@jtwEQ?V
zJsf!Q9pK6Po!@(Y{VbuMMf5EGs5pZBHjW4TvKYa{9`=j-2JqAVIrJC$kDOo2&(>p~
zexLiNG&@VaI#W9u=l=Iizi0drdLaHO>7d`?X|t&KqVB(tKP~tB&T{Q9xPP{kmp)Id
z3ywa@4+Q)Igs_h2N$b=KM_I>O-~4v!ZQ0-<_Fi_2;yZ>seo1lpT7ShuiO#hzGU0ZP
z;^wC7v&T{%a+%EkVEVbkLv~EOZ)*Cv$1$QkEYVt*r^_2jpnlGMWbA90y^?n8y=!%U
zZqzT}GsWX{rWc!C<n69ioGH#DLhoMA^QdL}uAgXMcCDYQ!Tz=B&4!*wg|%*nWc~Nj
zzKQxbyU6>K-W7kxf(VYlw+8&S?sqJ1V!RacE@9k=AA!U}UT*xd<iA_~5Xfz4g32q5
za>zfB2I^~B@-aJ^j(mB*ALQvqMsdZ($}R%^9)f&gIzQ%iuI?4a_bZUkYT9>h1S{SW
z``<RNXx|#oYh7=N-(v;q?*Z=zIwQ8v5BSx;V?Q07wEiCTLg-wB?+{J;uKW{mzZeh7
zw_2^%h{omj%3d%(gp*G``DE;?qe-kYo`?Lq^j7qP@eR3u1oei7hK8^&l_W_5zb-6W
zyoWt~+kDR>=X^a&c7_E0l3QulG@naDJxg65d^uVVVc8q0=cnO~_N?`iKTL9V$m8NC
zd_KU_E`1R32haykdabpieV*ny%#Xk9dO!tu!vl_m?pt*^uJ(&H+#iuXG~#+`ndiad
z*2T9Z2V1%?z;YI%pBGtwuvbk#^S|ws@ikdWKaKM1kRLBH{$%*;@yUWmmNI|-l-see
zhry5A=`veK^ot+h@H*hX(`{A%X@(bB%6l(#FAMrLzlG;fuE(#4kJiW2>cg(dqSAjX
zJ`BDL7j%A$?=$UXyleAl4hZ@%@Xq)*;%APgf{*v&_n@$*$0_1HFeUYS?XvU;E0?85
z+I!5K-{}C+csF?7YtR8Cbj&B?^|*%Dpcp*CApt+|A;>jgX7gO)4c<e?5}tq$8NA&;
zEO^VGAb-8!R`RbwpMN7*=CLyWi|1d*dt?|>ds;u?TYfY356MU5Nykrl2;?^``IyTG
zrpNe~l1~6W1_%GUyz#+Kr?b$`D_|Yc!1&}LkIOIjQ{B%xB712!`S=jYIplj-Z`nfn
zLDG<!{s4G^64UUy@);^t8VY+Z>Cn#wOn4pyjMM1c|F#=%wtb3H&g&eo(<#p1-w?&=
zfUlns<!LSThMUQkvOW&Hc^U~oa(dZy;ukdV%JFepVMKP$9``@j_=4=Zia&6}Q0s_w
z#uV%8SuBwK%)io)HQyoEBPM(tb@*uf?Z&rz!|8fM7lYI7H8?#!f|K^+MNev1d=YSc
zN@TB=cAw7Y`n}ero+tl7gZZ>(*7ICn4m`L6KNa+bG57Pf=excz==#EZzdvLC)2T1a
zujvbe(idn@Wb;p@zA*np%j=cRUqycFav$^RAHe>JuUGUQypj7Ci^~1ZmfxSDa>yG1
z%n{r`UwB^Ye!%#>=?6XD10#FAH@(2iLvM#?hN~G${bZfXN62^66C7V|^ZmoPe~hct
z6EqITYwY)$p5W&NVV{_u;NN9G<2%Ny_o!!j0{9~IghAI623=1WbUnfEgBM@azMJ$&
ztQ+|S=@8H07vLjU8SP`wTE3d!Fp{snZ>RZY>C<dIrpwoi@=E+(@>TaZJ3O*<rHwR8
z53};6d^I=WqH=v^l&`h%wCsMaMP*!o=w>><Aic~eALsv^<fHTv-~Si9rpZU2x9|Yv
zO+Tp1$N8=wNIur!FaA=8Ps`(3ru-bB{1?LC*~`a|)Z`=e8u>ZJr^~nyy6-IZ7AOGS
z0eNIDT1AJV;#}|zeynE7^F)fLEBD8ppUVDT3Or8e<iy{Vel8JldAoM)vfY3DRh|<0
zO+M`WSAPDb*r$H<(MQ2Q9)0xDM~8U*b;&2zxm~`_{huw*X9PV0e5ILsz9F|8hL|=q
z<WAQg);^xMGp#@O+ui2-!|U9Sy3X&f*FI?)n6J6?i{C<gKmB|<I^_4Aa=iiPsPC%D
zHJC8q>+oZf9xMBB+4)p7v>qe8E-DPUJ|R4oJ~s3wa@+~KIi|`}hy4pM<7HRT!K{81
zKOlRwxr^sF6-PJXc+&K9A{s{)K0!T+({#C0>9Iq+ZZ=Ht`m5592R>`#cq8{G<j+_9
zQ1fE$KPWC_h-O#SzWW&p_ZJtwe!_3S5gb|YlwT!2cYbdKf5m-5?*d&bPDFm7IL>;u
z=gxV4oOm#obLTwQMt@P<?;W)~0srvhDsRDT=KJ6;`F#J!9Ot|A7)MH5PwM}_OzXQl
zny>s7pcCWM{p8bAPG2LwU({Sq!e5@g(eyC+%|~8NegHcaBCmNJ8JqNf_*c*_<Q9JN
zGcH>~g+l(v5#L|eca2MYe28w0lAh5f=uqd3bgn$><GCH#MbPi;9#5agklVW&Piove
zgb9!H!*-$BTmF}NQwZ((|HAk%vXzkfd72@gm*PN>HxGQa)kpmq`XB5`*>!dKl?F2W
z3FkZTPg?)}SN`U9{}0$d!5Gp&`p*W*zjNnf;$PSo2A1CDaTxHwVCZXoUDq*<cL@)j
zE0Vk|>o+(b=<!zH<2}~-{($@eIT!`_v(KZfKkNRfNIus7A!lIEU$pc~CO4*>VM9L#
z{AIrhPvn;v@pw1*@vNNV$5Qk6TT`JEI$@o|4R8RSuX8wP{;<0lQN+J1-Cu|D5OKnj
zY(DW`>zMV?|0DSh|2W1W{Reyn=ZczVR_CtptaD4+=apS6KUOx6iizq=&upIQ_QZU)
zE4vN$%_9+=s{btcTLXgP_F!*!!PD&~(UbPAQjfnY=h<LFTRo?iJs$oN`g4Zd|0ewr
zaVzKtaV+=?IT!1Fx$6zu?<w((Y56+X4>o*tzOs(!8HQZHQGQF@D`NbC<XWCrO~b$1
zywNY#A3yw^!eFreK3?==_@MTETsB^}-SBs%e@A)42Oz7hBmFO`2frCs2>F?ek9gim
z=^qpBcbYkl^+)6rK2GJOm?p>9oMw|MR<E+ZSQlv3%~98D-H$!wq7JaccqT5T&0XhH
z?fxVnepY_#W`i3r%gVf&RMd(E=U9K-4MZL(J{QAhl;gk;^w*UKX~D}m-pkLmzs+OG
z_nJ>60yfVgUZ>%OtdBfnU2>Z7lAs4bTzSrl9(m264@sXxdHjlD=52}frgNh_Ht4Tc
z-kV-}-WgWU<4dD+cBk2UKSw_;pAh3ai(&WANA*@2+<A{^^H>g8eyU>iHiH-1J8cGd
z096hgJUFlE@SvYi`fogb!egd+PoM8LgOleuiQupcdTf+G=(-<OdTbq^Wxq_v<3Yn?
z(a#jg)9B~DQ9h!qj|AQHdm)z{%X3JnW%COqp2v6%76ZKga$luCrr{P_AL&8j18#QM
z=_=C)0`&seL$=T3`>oYFU(9wq&i(XbNf)sl{!`e0J|FJ4gwR|?e36}{eQnJ<u8)$Z
zpTV&!E=cDRV0S(k;TQPLdmilpf1USmJ|@5Ui0?;&4`F`gdMOUn^(ydd@*&b?ef>6H
zOnHLx81IzFXO{b6&!L}T*%LYM)VOg7%brNb;gH+=6VCq>*HHH}w;N54!}HHV&%{2U
z_8*}4+P=5T1GobKxwX#sm-lPmn+gZo$M=baR4Cyuu{d4VFXit++_3F)dpm3WK2hkU
zw$Hu6_tDkfA_{^sK2(15`aZYfpuAn?J6=@gcQSg8&zCoNo=E!+Snp$FdUN@x{gavE
z*xG&fn7k4m3xCnxlOlRk{4Mw~R&IR3Cc}4(!_K8QAfdRg29TLPg8j7y5gzpb3F;|H
zXu4b~<-r>ANv(e|%zR&%_w5m0EB_kmfu0W>->mHUZaG4HR{TfI@5nc4&)YbobAr9(
z4*6!qpYMCSD?K(3%9ptPP5YEb)A{nnCWl@~KIHM(`FV_6E8}5a=I7b^R@iz04~<S;
zkJSE-^w0d|jDwr<bFCJa(Fx|?hu$T9Qh5@UH&%HXnkP~&PPyJEeRJ7j>eCatZ^1z^
z<aW`7j|X}f@M)RHXQ$!cY<|sisb4qWh}$PZ$;UDr$ce_Kc-dIbMgtSdr|$P-T(p$y
z47vwAr0<pEzQyCSZ}<H%*PEA>`LCHL!t^-PtKB|KI9~Cwav#n4fXc)Efo3PUr*p$2
z?w^KT4Aua<7=Jgvi+RwYZ==6u$8lWp8^|7>aK0{iQI99ud>9#=?8Y>F-{5=Ea?<lm
zd<XL8gkvi?3V!jff2-sT?1yXIegK|KjA4`^taZ5qe+PO_J<p8J6G(qR`wMIBfAXhQ
z`|`UgF1c6v_eJG}r`mr4e+C?3AL1|Ij=#-gD?14z#(T`8c`OC{zUpHon#a=r!F6nu
z`e5q%A@<Fl?q{>`D^`#m!59BL!87R<&!4jIPJg#rajU-!!1EvafkcJ>{mSUQ;^@)e
z_tL6-+~3Mte<Suhy}xVbRrS#yPTruuzmDEx{U@UPjHF+HzD5rJX$SU_!Q20$9fNNg
z!pNbN3wUlmmv}-s5z6yMz~`@~Kkd}_+pw-*P3hON`ihruJxh8Wu=y{}`Dq7wfQ`fd
zLhr)tFb=D)xI*Vgas5}H*t<S7&$6D|ed4QY6(8q(X07iN0RMphYvm8~^=zeoNB-^n
z0sQZe?|-Dz3turr)oUK>_Dodo+<)j@@7ymfi0bh?qUu49f**WZe?Gpfad+pw_cyxA
z<DU1K%l~QT33oP1J_q}H;iKR0fDhR^_}}Hpot>daSq{H6e2j4L{U_zAF5}3Rzti`X
zfak|9=*CmT(<uI-jL*HCd>Q%!ev1F@CEqO$H_FEbxPZ@`QR7Rm`BA4cv6u2gak(0|
z?!l41|DQE3S9Br&3E<DTN(zJ_(c5mW3+NU0r0lWDbHRmq{|W4m`aZeN@q)jA^p~ge
zZT;nU1l~bU1z&)Nym`3iM|J%b>v~SKj{<)7ktlz(_Qfm)%lQRNi)KQ(3x0ub$`_@6
zf5Y)i_Y=qZoz2hVBQ(Bg_ZGVzgmI!NjB`(H2SoSPe(T3o{+C}ycwaw9cw-Cx=LzpW
z=>hLC*KaEP=Elcd@mumzc&_-(gMsI*S;3wA;1!<pyynjX&)@bR1n$Sp5$?qIpC8;`
z)dTLi@9S0gP6cGH_#WfA@$Y&2<KK+q-WUJ=$-|Mopga#}P`*s(<DQ4P<l}x%xAW(J
zPd>i#mkiGT`!T|q`26#Ob0dPY&dZFQM2DgLV6bE1X>QG<Jq-OAdTVtbnZLJvs>+Um
z{(zgT6(=Zr2J)JE58~J552Ief_w;MeNI&QtdaLvy->1_4y5jO>A1gj`d74rml3!(-
zKEw}Y-bLRpn?@(|?l-+0bi(zcAL77|*Xe)8@$O%L+Zp5KjPsd6fAfC#OZT<$P1E0;
zf6PXIyW>Zd{`T1M5#E+i<|9+Tz(+(n)bVjT|7PBH;p_D8+-I5ddi%K%=rQE)v&Ba$
zRQu=O%&%JECG)-g?Bm=Y9`0WbJt@Y+$0~<@4*2-$2p_?>;28sa7aku%Gb1Cyd;G+I
zkR}A*wSROx^1$KQ{lAJcQrv*Wm3BgST7L*|RVq)y@dJDw@%@$f9>*`hF7!A}>_3@Z
zG#J9okzF)&8OOEJ<0Y@y!2Kooe^4HL4H;muAJ|pTT?iXJZsCdnI%wd>LSEP9=~p|Q
z`~EG(GvKj2SrCv45pc2dIvEYV)J~@bt7rDA`|se#vhh1TfDc3BOu8N=KcV1h{2cH}
z9X<|6^bL5yXNMpBDK@Xf=M`%6a{h;L!(S8Ip*9}hck?i;aD}%kIU+x;`a!%+7u<aO
z`)%LjMX&Jlp)-v`d=z>m<~rizEA429r}!)E;;#KM$4l_NG{R%?RoxE~^T(TG|D~T}
z@HEt=KeKL^ea6q#shxJ3*m{e9BF`E25kKtX*F5U}FN_oSf0p|Wwf@yU%Kc`Ka>_p$
zmwQW8Zl*ji@SB}f^P9mHBfpu(qxJ<ijN=PYeqs5$%5v_9#C^N?$xm0_Tj=+1p#Q(z
z$9*QLpPK=l03~PR2fSq;?Hx!z;0ZN<(U1T2SLgHLC&oG{jzNB7@LRmE;}h`cs}UaM
zzHeRTLD9K3*Q4rqDY*zddQ%kF0sj~L>u7&tO#dFAQO_T${V|jukILuAIsSqP0goN8
z<2)cU<y%>Y`|muEMEie=%SAt5`(Z@y8W*>Z_Bp<_(fCAnq6^RoMl65!zWn7+tI<7n
zP6c1^UHs%9uhUJO$K3LuMEB{zPp<PYSeG+u{Xlbv{J1l^2L|x?&JQ}BxE=GqNB;d6
z)Y`##(ayy+fBaW}@SiWAisTLO9;%}D-yp95Z^^B4|1D)X<?qV+84;*+KCS*EZJ%7{
z`eA1RB@}O>b4xnk-&{_FNnKyZ`9Hi-KBYJg2XqO&>-=avrFV_F-UU6)#$Dg9^ZZ*E
zox%PT503p6=vmEq+=thFX}aH~j7Rb~o8^tCn;oxvD-hRX<C@n!F5p+!I6XcAaQ?dn
z^Kv21Xw3C8>?=YQ${GXKzVuYU8$Z!2wrVlnu}LZ_fEVlW8G0?oGvxdCWAVBB&PW;e
zrTB2cIqPHK)QIa>n9sd2oLw){c<OqH;?NXVru>4-8;=Wr3x4MNmwK;r(u(WX{(XHv
zu(=qssm>2H#~I(NJhFB9AifT~2ArYay{|^+fB5~#zvuQ5%Hv;@-&HIBp{Ts>$5dR5
z>eu0+JVn3{+pqM$@*`>=S?Bszy8Ke!;FW$pQ|pd6X|%Hvhz)%3Jc&boz8HKLn63C5
zod3de^SzGm6h~#;xW=pav>`vo)|@1~#mCj2;!kw03VAdz9^|#e-?bi(uYAKRJ$`Sc
z?^CaI`W&*8ej&(?QGB}mQ;PF0JpZ-izVrdeh3fafvvuEk?fqHJ#WcuJ5A=fXgam#M
zT+>|a_O~}CekOm9_(*rVVVB|n;UB{kfj5XG8gcoqc*1J{lt^z;KUwljd#^Y<@jLCK
zm+^eA$KyMu-0M9^ve$bob+7j@<$Arh^>h9vz5qHv9u^E1f2C(Y4gikpe0@iBesLbp
zS))A8TWkF5JP!lnWiXF*;sZWE@l|}seDof0$9ZhDhrc=>ZtEDIBaPsMc-yV6?;(x?
zLlj)mKIDSpBz1mK^94O1<RV@d*k9^*#M{NX<Gt)+#5q;Jd(P5(;VsA*_@^?E3wrK!
zI@hSbb;<)#g(477$H@o;|8?#Ms<+#`gbZY@uS<z<^Ju`A>*0K+-PcdLsEu#)(eOr8
z`LdQBO+R(&{_1Jv7gI2xKY*gTSCfFzI3$k|4-I@1e4xLfq@Km^6p#C1A8(xwwJzev
z-EbW$_2zXRS1!Fq@RPp?d>J6KbFc$dK4qN$viCTbiuZm_3w{`^-|}>M_~`)8_2W0?
z^1b?gw0(y>GrhG7Pr@$6^LDTI!mw6xcTs#i^knVJOa20GxX)1MpNIVXviNDa-hSVP
z_;*&`FT(grj1NN-9)jOk{Ic@{&;`CD9x{2P)5$%*M|&U%j}E{uOu^ATzXz^a>wcp&
zFko`2=Q{_i4Da3Vv(6WuSgzj#*ECc2-}?C1c^ql896uZA?sqV(Rs6Tho6-*eJ*{i}
z-|k@ifGg&=+3#%w->c|zD6A7498cD|J(n65Gp?@s4OaOt%K0<jbbWryQX)j^apc|K
zAG{{(qhc}*?>(;R!_(%;`0)|XbGW?kNLxq6v6lIlJ<edQ+l^cOd?xrM=o0IXzt=dw
zQ{3e>4hPx0(tnk2Q1R}7U-aA6Jdq4de7B0nrDBV50TM%gE>Y);O1lAriTJ~^a{U>v
zI}L8>PYlPV!Oiu&GM_-XKD=i}c%7xZZ!_y-Jgd&n<J=v7-T1aJG|!_#(i~&JUK+0D
zK350<TgKTuzt1+>$H06QH^0{TzU(6GbC|sE@!sTpkM}0;d%VXKd%Xup^<H_{z(2d>
zy`O)8o{I6VlONvK7v&-60TYw=US8#-w@9uj9!ux&@ZIFS*8|>k$@}Pim%NY01$mEk
zfhITN>jP<pm4ICUKDL$ODKtHfI1Ml2`XC<9>@8oPNRP1faePr8nwUS@`Z#^W?`?g0
zytnn~@!r;_$9r2Jf3N&E)ATXtpTHMeACDI;?YH{+xE$4bK#wtf%<Vm$<CMQl`@eb*
zyzg2c$z{lgSReEESYNEqi09dW9c}C4@@1>@6NKGk{n9XO>!ST1o&SNp36vAxLD>I8
zkb4fF<;ha!KLZeaKLzk^J{3~8x@T5$Q*uFin)sOPpBxAeJIeQu<QIcnM;FcWnTO(a
zC$fFzW7K^EI)|)%4duC*biGaf=*@>Q?o)Zx<gbEUhy2kvOT9?^-sg?=F}OHCKYpIW
z#r41C^Nu#SoW9=U&;32(5^!$zb*K1wQMb>ex2Rvxk&OeJ^?*Ns3O>y=gkj3_rVP0q
zI)R`C`2E}tl-$|;JkAsQDz+}Cknw8V@GoH=*#E(}blzTaU+0hnx7_7c;dTY&1nL35
z?62pGY9~MGV7+DwU+wz<PrC5O`NuT;@pzyTe|%qY8vgjaOZ+*{@#hrYQ=@g)KAP4;
z_Hl_nPN!%O^V)ot@W=gD!Vh2P{nHKir$sl*`wq1=f8B{>q;<TWbhv9BHXrt|(W~-a
z!S2Ni&1XhDc6?L3$u$1qd`;t${UCi^bXtJH18>}K4SY5FoJaXz#&<ej1fMi|aXOq%
zFU!bB*sS@pfCpOt=Bdt493M(}%fIh*q5JMHdJ7A}Ux#);5BAsBulZc&Qx^We?i4ak
z;j7BMPW0mITb{#oIM(q*=VO<>jCeMp{JW(-?0ylS$M_n*KQ{8i>mE|j|JZJRpUHlM
z{v~}GzivD1SN84LjvejI+jflZ*g86P$t9y#Z`^U&=+>*++b`X;)g;Z><YasMj*VNl
zj9xmnaZ~$})uS6PdCllEN6$L*+%wO5{`s#sb98d!hAr*wqvKn*Ozzk|wsFgj(W}QM
zN3Ytrb<^06wp)uc|IXYpy7lUP)Zesm{r0i#`O5LF+uJKAw~w!!+_Z7Ly>fGV^Y~@k
zpR#>&<CaU>uNmEX<&M#<myWLAdgYc&CRdN{xU4<8sl8=%<K*a><KtVe+_K}vTX&o}
zIk|OwBgS<8)+^du{KL81w{F-zw)wf+w{P7(IzD#gWc!lQ_4()+tF0bA|FZVzhK*OX
zx9Alb-LiGZ=;kYTjIH0)#*i*)uiU)#lBaB+B!~dZOE+%XG<x-ATQ{{w*I#+*rS0u2
zFWb7gy>k1NTeh^fue^He_A6Fy+cdW0(yiM!H+O8^x@ofhxb?~%E4N=cxnrdOFuCIr
zoBzhGD>rW5wrTPy+b73He|_WRwoPOCDBiR;x3}yVv!&YJ-f`vjE$vH2$F_{NZDv<)
zX}@M$dwfUxl1=%~Je09bo3@T~F?MX<xMjmr{{QCgJ-(5$-XHkP<l1g`H_K%y%U%XV
z2(a5tFWaVFF4=plyWOxCC>LqcX1WQRCLu|8Q&7nQY88Q?N6k+USQIs&LhxDvF-HZ9
z$0OArNW~*W4@f=dCxm<C`g=Vy&y&pev#sdsoZsv9d;Zw&d!EbOpLyoV%rnW<a4;Ix
zLTX@lf-OK#&sgkmGMI3m5m4hXHK+#q<1sCu9tuXswEw}`567cXZJ5n5wSFj_)U@@n
zct~Sg=BT4q3mwo}!dm1&IIW&@j+)Y<BZBMH)}zy>lEW=gE#^Lhr4FUi2L9hJd+<=?
zKrqdge}8RvsfU8eNHCUG^#i>}J;w-}x9#ZbSNCq)vVTwCzKdG+4eV1dXytKIEI6u3
z?~A14>b^)q^#{k<k)iS<T}mY5muti6!Leji3a8VFRL}bLmq*g^mY9~-4@_w|9!m#@
z(<w<C4Mw6psj);No=p49iKIk48W|q16>uPu4v!7B497?Hveu2TGf_Vn4JVA#EF~q9
z+K84+YN5esFm_-pctA@@T1-mC$CAU^;BY*o{o`fw%t`G~Bo&Frq#b?x2KV-E8r;>l
zcW+<+j(U7l3#K$Zde64)gZ-O!ZL6i>+iqL`)`hmJ{mzDc*ZX%|{^-zO*L?iTvcLVb
z-4B2LvC}2>j$dtV-?8}(v5M={k;J-$vC;LDBpMlFhh%Ix98dN{LQ!$9?9ozV(KMbb
zF*UF)ndIk6AFETx^dr1S?F&V>B(-2#<5d?%?$J__D@9}|m<|rIIxrQEk3~ajFnTyR
zo>GT2_1tsx`f+$HnPi6ruj$lOA~<~X{G#!cC=q98EX!uScEh*}laaJ0{ha*<qpIrO
z_^76yeUAEIgCyO%NRkdlVj;Gthk_|>BpDyIxg_cRkywaT5?In+Exl<h9gZg>>G65u
z=9_&il8ywUkt=CgTcW|p=)OoIMM~Kc4#o~>`yz=w+OQTmq|r4oVmC+Q!v{ByMWP`s
zIUJ9TL=L1Qi9x=H2l@6J^vpN0b-syh^G$4@Z(_%M6F1B^v2(tOU45}b!DuA3UDGxt
zBkAy{mW~YTSGp~``?vS)7~HgF%kKUC`}Xzu#eWAqX0)2oW=6Xi9cFAWqtlG8L~vY7
zrp8lgZFG>IEo`xqeA5rH?L0VSY-poZ;n$L*krX?rw`#G77UC<!tFpdOi)viB`^QFy
zv}BKZhI%;6j`?V0I1)Rc1~!F4Np|T!6pTdK)jA#x4Vq^e(+(4FsWoDHgQ?vyEf`H|
z!O*xm6i+7OhqX{Wey`r@NwT9y)nXx|dN#E-jCeLbvRZ70WP<7*8c%B}_2H9WPM5a^
z-Ct<Bv%LECUtF_Q3x?SC=#Qtjv$}L&WK;|79!ocGANo;G?y6h2=m+AyNP<`IyiVXp
zV^Ewjsd#iSq@~i4m|hthZIMVQnvU}w&=-n|tpESCCQQx6ztuivZLguk$lzgC+pxwU
zn=l+79gWBSu_lQ)jJCu>T8}EUOG~AK2iOGCNKA*5@xw7S5>tD~^!Tt|rPhu~qp+RY
zNV;baYj*VL|5c6utDE%8!Gg_Bb98-%=Be|~ZmX6^YQuUXH#r`O9oQFV)uErAc$-pu
zaryq<strejNv(b|?TVyEgX!V0h#yNtBdn-Bn%>|`@#&n~GQ*k{O6`n{M#RClcRY0{
zn1o{b<D!kdHJA?aGWz4`dNm!YPu#0l4!aM>@KoQH(T0r%H&3jm**tz>G9EiX*Q-CC
z-bIr3$J5(l@v#Hp_iN)~CALOF{qgi(EoodSc%jDBty=1+>8aslWR#smaa_Nx<~VV-
z*2**G+ho)wd$sf)?TWETQrnT%F5q`bwJ9)xEpfkg1x!793QM;QlN~id6jQIo;GRgo
zG2&aZo@iGjmYzRGpE`dO-vWIpc2TdFwU@Or>SRT4)rKRZ!Dxz3-JaC6E4A9CpGLB5
z^F--O!VU~mJ+4n<>FXt2tR>@hu}g%OGR<9Y^O)jmw~g$Goo{-5+TL_9ZOU3dXiZ7j
zNmJ(@Eyj|KCQK#68te%kuBYEMmfm(qi<ui^d(&e>^;(=A?4ybFcwZ=LYUto~(;TPg
zueUSd%s48>bat5Hwg;opp<w-TWs2IxF5s~P>_&Q%zfT>~*p*qo&yJ+jP_4dFgRzik
ztj6MMG#)#kC0TowCA}y<rVa;Vv3PntZ_lz@@JOwtr?+VJ=0&YN8%(J|m0#q<M79he
zUhUQ5A|W*t*Z566tN--Eg2U;tVAPa|<rQsZ*1-`H)niB<i6_<3c#<teFs8<1nwm7K
zO#PZ`&S;*lYDNvJ&u-VIfkFSaJ-hn$?c26>aO<Xhn+E&(x9r)rY40{Q%BomaiqQ{|
z7#oU4hSh`G_<YNqH0qX+n$j!ddN#4_y!(Q6kpydpwwh*LA|lO#nd%#q-CmfJiw!M$
z8Ps$*k`f76hscnoipErZx9J;o-rg0~C!}}8u;nzGjA9-~FI^}S(vJt$X5_V3ZPt8s
zwc7PVB<S0!??!eU1yi-<KDzKos=hEmH56f;Iqbektg*h&#cKD*)2gOlYibK{P#aJ2
zbxg<g)rr(kw(WYK8jGl1a*RD=bU)RjL-lKtIe}MYtw%LvzRuJ(hjB0;4hM}Mx%x7y
z^JZfQwSL>qx@`2r!&nHmNyNcJXT)-doto0pM!x!P-y{yk!2@ZH&7Re>tS8ajKWI+$
z?rGS@9E@pKynD*OE0JE@-&5M(k!Ha~iY<7a@v}}GNelF#Zc;~Cr>b#=zH3@?BLBUa
zYL$lA&#Xpchk$93A}N(!$~PGu1?CvKJN1PP@oW0KBpcB$@@nmF<z15NMgJX%jcxEZ
zyOlTbM0$~?wKT8GHr`{ZUa2MHwM|n$1!8HoZ;j@|LS<}HhglcOg3;vQU=`!vmvVt6
zuDAY;`{K3gh^9sL&CKeUq?U*Vhc%;<KNTO<(qVQj)}kqG6T2LVCiX(bZ&FjN^|ElZ
zUNLHVbB3Mg3oPX(H5oj-aAY``(yyTl<{lkea4WI8N}M8WR}RNV6YN(DeU;gd1Obh;
zp4JT~A^~+o3#P}CTHn^4wVgXUmP)fr6>E@<vs=7)GNdJqZO1y-)~e~`xV}r-h8u|_
zQ)%9`s?FB8objrjm2Il--*xdKp{O~1%A8?X@5f`;D|)RkX1Ksy>Y4Bga#S|agi}Yx
zVn(038cb@&42>ROEyOPzrkSackQPfvMj~2LPnt-^4@E-t-+lhp{X4tOH^q;RMbnW)
zbe#SO^$+xxiffVa(@eeBM*rDJOY$FSn0P%m7>SL<dB1@cODD$@@klJqCzw`J?~$)<
z1l2z_bWj`D@7-Bp37suTaeuv4OGXZ9A%0`AKgK$q*a0yTiG|dldMKh#5QnL#K!(Of
z6UO<K9A3{(q?TlgbvmXaqD_<9HI~wE6UIihE%DLBSX$d3i=<P#f*DhDdtWj*tnJid
z2hw5V7F`SN3TF82SW3SKXFuQQP1BS}(HD(s2ZB-k&SQUlO^q9Rp0_`4x?9;CPo~0s
zaeW)`Gl2ICaOw9syMh_^moCkgu~a%PIw3ae9cxBAr*@ytXUJ}9_s2}FMLu2pG47{L
z{RsR{gWpVtSQngehR25E$)q+cIwJbm?aA24NMtyo#nRi^Z-%@~wt4o&<9kPg(I{UL
zQw*PC+Sn|;NS8b?#(rnv`%LWLlu@U!%4}?u)vWq{Q^(kj<3*=<Yr4K$_^pA)n$em%
z8q7pS$3|6_;II}_6Rbu`24kt9ewzCE8OJYpyur&8n|3C@BVd;tqhVLSeFz5+v0hBp
zN1{f9qwLq76gy&v*qux)z0Ro8Ycn#g0-?Bm!YB1#F<4z0WWVo4LgI)v_B#7nR&T>=
zT8J%MI&R$C=}ioA>>to#T2enE^=H1!!FYPH9@t|6?D;eHtb{q3b_&}#!}<@v2h!nx
zXjAeXV(brcuf{GW5u-P~Z?|!A?NRH^bEAJ)4XXODTUu;bKjCZJIhYQvt+kXzUoxxP
zO?3=wKk7fwvaJ$f*Uw<IRsw6NvK?3du|A$)TTIh`UajxZG;8dKgQ?i*>@voF0k7R6
zhc=l-=FC<u#qMd?LjXq?R$p=~QNQETPcglWS~GHJEUh0K`t1Z;&)SyYcWU|p#}13y
zN{i|+!j_XKKRu-m1*1W>HQ6GvLnp<~OtzftM2c!@<8H{b8A)#aE|p|GI-331sm0PM
zJssc0`lhP=@^(5uLFY@UuN*(~Q?-kqz9H+YR4+<BtR>mD*H09qBCI9Tf2i+Kjj4OJ
zE5_Ji#H#$>;2~b2?~Pok=^d`7PMA%xan_S5uF$+T+7~>qEjAnvMPdi|lr7<45+-eq
z$D=T5e|p4Qn`Bh)qeeIQ?v$x6F&0u^;{7q!M|>cjj9jUOcBjKya`#wz_sA}7G@cx<
z|Bk&aKGGLUYsutTBCUl)Ww|qwO7DxucgAarxjhoq*zec-;_+R<*!a#!>|kn3GM-9l
zsjb?f$gq~G_o}h9o5xb)do<%0VD^7Djg=To9?;{BzJv3};_0Bc*y$a=+Cg>|-kXjm
zg9o(jV^QNLOV%~Wx0k7E?~5hISl?b$>o<NPXEW&y#zIlkEOy4@i9K2{v^y5n7s8nF
z)(E@q#FK0v8U1ppP3CEJT*#Vt`cIAg!nQ3FNu^VpldNaPA4!OLZ;c<0v8F{|Y=27Y
zkFy3rOs_Zie<JbNrlEK;t%dl)?vEw4;Bc6&Zf`u5HnE;#kCxIzNs)MLk2b=3-Sn$_
zk2<RFO8tsrG#mJ%Kx@TgH%0=ZHWrVo=vOoS=kH|j@ZceBSpP*P5gd-B$7>H51=&?#
zG?-4a)--!~DE+QavK(Fh$S7+niDu&8@c_yhEiFc~Ltj7RzpP(Xe^7>1U94g<o-2x^
z)Sg5z78yRs9;QjFr=Px74fLq$RgG&K*Q)AO>W9=1xf|VU#ZuLtQW_aeuaAw5wj@)Y
zjK||?^|X1~JsqA6o=#7f$Lr~C^|ZFOwzammcC>D2?QHF8^|p4mdD>dr+S=ONI@&h0
zb+&c2dE2_%J?*XSZSC#t9qk+1JKMY3z3tr{o{rXzwvP6Wj*bl-ogG~r-j41Ko(-)V
z+BURr=-9AfL+6IB4c-miou1Ct&bH3>&W_Fvot>Rso!-vwE>Bl$S6f$mS4Y=|uFkHm
zE^k-2*W+#Vwt3sV9o`MzPH&gj>+SCLbhmc5b+>nSbZ_YH?C$FJc6ZOalE#Bi?lX*E
zLR0Brl0T}Vilf7bVLb}^qg$*&5Y?Nf+{TvHbEeof)^~vx3+cF|rKRNqdLNgOjO`Kf
zuoo*XFr*!b#Ml!C?3Y+~tqG(Khl5Gup|D_be51+^FLoJEMM9c-hMx1NbxNhheZo;u
zW3dQ(YGHjM8Hwr7ezhc1l5DZr>~_UrcRCuDHLhHAV$+Jnt|d)NtuD(k#~j<RTt30t
zET3pu;W$ZNsjOM9TF$bpTht<ZEUikL{59nc<xcC@ov$lz*xpj!w!G8u&CK}qH+;!+
z;lTBu%&q+WlBMt8`No?q>(9IN1A~9O?uHw0{?r}!+<V`H4?X<zC!c=i9m%@vm@`^C
zx_UOA)Azm)TzBKA?zrbW_ulu=&wu&I)6YoO#Y^<qo{ihK_r343kape8U%2JrUp}&U
z*%>_>xAk3k$)%SKhO`@QzT-Rh-uK|cPd)uiW%06YeIYG--M8+4;75-=UU}i#k6eHI
zS0DJ%gFk!ZiQo0+fB0_?{qm8%{@oW|blKp?Z@lTA?|uJA|MJk!9$&Wngi9`c^|iO(
z$&Oy}<Wo!5#NsPg4SwjucinyUefKXvVfC8rJNkDITzu(eAHMp#4?g<XzgJ#(C7HS@
zJ@(ntTGoH<?(hHTXOBGo)aQMl%X@BG^Xo@{`A+}ti!X6Fm%2`0|J?Jjc-J}SZQho<
zdGCR->4#^2HT&CV-+o6@2T!@?DeE;`ohMoC%Z_|wN%rfuH4R5jvYhCYt?R8FR)<A)
z*d5Cn{Y#H=>~~nKD;pauPK(2$SS*$%tIe{=E-yLW*6%pUaiK%8pU~vDZn3Ph$kt`{
zrA<B7Rqq{CN3EB?H#=>+rf6AVzveB=MULeS%?-yj9oKZZz0tnHev#uW+xEt_)+VcL
zX<f9|y28H5lKqCg(Z0TQmnD0<^K8pf%h?XE^DNsn?<{L}u3xs!a`MuXmu5d{z2<W#
zE;@eVpKR-G8y(7$=7#J8r=***zgf{_%f4gFKGpQ%Etal^BbOeRopNUX)z;X&(b8!5
zI=4HU?CC|TEf-raYRF#Oys~k5!%l1V6ZWs)-gJVs^)~B~Cr)!T*=*Ubx{kc!kkvEo
zJFVFptl0-FCs~#*mh7@@k*$i&;ZU5;2Bp!qNLgZa$;*^uY{xD;PCi~aK{;{pO4};u
z8u?WDa_d3mZp%H&{mLWCuarld9&7lG^0@MZT(<o|dDc3oJf~KyRpoWd8*<a>8_(_E
zebcSCe(|d7KmFM+ee2$j-eY$(be?nW1uxC~%6eRLXV(Q6UVZ0XcmHrh`IwJ={Ki{r
z2O~Qc`*(-5OTYL1lU6#Mjf;*up|iWEaL4R#8@h5g7aWZn&mD=}^r>a>!5=;M{KZ2r
zzxmGIeV_kA%lgyZ`)`@N?aQ}+t?<oz@BgWNQPc6Odd}N+{#U>Di+`JRoVenY_nv#+
zv;XJ$cOHDms=nvFr@7m`J-zSS>EFBm0(R^LhP9D{smzD2{>1Hf-d!xs+;w*>{=la%
zJLM{y#k$TiVv*OkWUpCeX<fR~dTPUJ+gY}))+J|V@3fz4J=N-Vb}Z`Oa-^$ad84y=
z<F;<gu(QFl+;+0%B%AE>THkM5Z*6omIDG2q)~1F|OOI`Z!`kHV_jR=|Zg;de8;_i}
z=ly3n&s@IZw3Wx5(9mx^wPEYx6CI8AUgzlzV~aMQd!~J(t<iqIUADO_w(Rvot9zY|
z*{@!9%C<#~_Ql8c*c&_7T2ILS;Ox-errw6e?b}Z3b?#l<=V;8ny1j9gWk+9^Wr?%V
z-tA~S(s`m|qh;j<^3t}&*M4DSY*F^7pV&FP_&Sek`Av6Tv*WfOT+{71(|W1>w8rg?
zZricf6fe=<Z|!z0^RYwXb5-Yczd5tvOV1u@Un;M%FR?n0eDdSggSN$%28ZiYfgKI$
zv$L-@rksi6w_nLlg$o-_%zo_14$DV2FFpP`{~EhJ``B5wb5E8N>ntm*$`Rk1Wj!|e
z$jq77{3-j|89S|wR^{4dTX&w5{qfm$*}C6$QipP6$y#fu>4L`WUEWoT*IFAK$`X6_
z^ViN=msu8D4qFH9O;&knlhx~Nw7Z?B^dH&Rw93-p=yWczHaHp_*?)a+<8}50D`;L(
z53=TeOER@DIles^AMJ}7mw5d;ueWpA1z&H84~``U({a5y%buBIH<#C1Rq1A1K>EP3
zlhQFKsB4<kz?$dRPM&q9M_n8LYI&_v2&`NEMxaG{TkX8{oj~VX@*g_o#*@2FUHpfx
zuP+I9uW!Ds+p{v*`_k&$cKSMk{>tUIoxeMN@}67nzip57NN}(AtK0TUPn^6@D*s{s
zU4IN-_<x>0`J$P*+b&Y2=Ps(qS6?h8B!{$4mSsg&WVv^d=XjT_ITX91$kzABt53RQ
zQBOmI+-#K_WQ%M&%W}5!%w}2bl4aTIw8|Doqq0iwVcD%txj}AJR>+FdEn5|<qF5~Q
zYQ-WiVz$YORX$ExZkJhVMYcL+how<jEpL=%xk+x2-LggQl4Xm{B3m8GBE3|$NEX?q
zFt1d)mHJ#($-S~wRxGmYl+TwHN0W0%RvH#L`jnH{OIUK(64@pzwng%(4f2Rpw#$m5
zoTykWF6&}hQS9<kS+Yo$Rmy5*wc=A`hf`J-HOT8MvOK1oA|J9?l?K^v`JJM$rFF0p
z6{o#Xkv(f#tsaLg+hlh`lcHJ`MYecleL*ZePDROE<i)as&CsGe<dfu|oGe*xkOQh@
zk0_E=Zd4V&BC)DcK2fpBpHo&GvsgaOdE%lLi$`Xg>~wjHT~QRJNp{NX<#t)ND2h#y
z<ueth{2beC>{EO$mrGJ4`H%8vY?4J*Y*x3$Dt|?htdiolY+uxBy-My}dWNhhjh0rc
zqB!JpET`IJ=ecr|($UapRpdbn+mv=$k#CVL&g1nhE6dB}B@T=2Cr-9iPheZs&UO^r
z3I8Q4R=XlACn@`#Y|7<qd)Q@JvnW>CCN;>)D{`YE%T_sORTQhNHoEQl@nBahEsJGE
za>#aB-m_eBu+pxyTUe<MS?*=Ck|kx4(qXf)|H<~Hl5L|ylFzfAFH4HlqMRVfvc+n1
zIu*xi>pxkfE^C`pULr5I$x9`Nyi70A7Lq3&l6;O;vPzCohZM-N4@pUqG~F)M-iu}L
zoQN>dYrJ#2P<)Zci*&`s#=9aV{>{uX{~O@x3f!~&?+s7d_*=*lf2-LDg(qzif9*zk
zQIaI%&9jA<(-$-HWe*yE-Ta-ms`1H9J+OCuYN2GTSNl`-`TV&-;v<eqdOooo#9tO>
zFE>i)<$uHcZ}v&?6%<Kgui^7opUCt(_;@`meCsKjKBgiIpHL+JW-^_A;{wy4u(Nm6
zj9@P3QmZ8KSANL!e>P2zm2DCqu2R~`zgNn_Z^~j6Nh5sXk2Za*Ar{y-#l^PE?>74S
zSTJvwffI}+V%uA!6@OVsoLr9=!5lyJ4I|z>-;I*QzwjuL={*ZfXRnPKUxcLT**m54
zO=qtu&NrQXhHk#;?6t7@rnA@Q=9|tAy%xT*f!~WgW`xdX#Mc9ju=Sbx@x#LT;LE@V
z!5Q#Jz@Gwt5p3S>8Pm8o=IJ+>rn@h*{>}Pgp?It>%FB%UA`moQF3a-2qQ2<m&hWnr
zm7CLy{4+zw-_i$+zXO*Ue_1deZ{qwv^6dQQKg%bMZ}FD}H!nZWmuHIqU1&ZPzp>xn
zeAXuM;r67JQvG~iJXhcE>@7+@bOD*p-Xi3$IFjjX)RlAerIIAylVWrUBW#<a$Jg7>
zh_7E8Veedhc~}U|iBS}cpv{R<I*jl^i2v`F|DidX#9yD+!#}!wU!N0SEi=MBb7Hg^
zBTUWJ>n|4myUY9doUK;3vhY8>J^nIhlZ>z28sQ(^9(Vl3Ry!70_|sp+*T#*o?m3%e
zj3Q-($a6Nmz7*k0&)FpYxlTRIJ!jMFM-kRMZ`12P5%xWAlhzAJl639!Hod+U;eqFE
zdc7#Zi_hDn)dG?vxhgh&>@*QtD>Qz0#iozNAVL6+?;9)PYo11UphEZe@1gv+D|C6<
zUZDAhUZC6K3onRKR*X=3!B)Gbv+(o_Hp%#^p%Iq6NYl5!Xw$EoB3$|+&7XaduK#T>
z+9W<~uO9yRqD}wSng~l?qT7GVOEx~LzY!8I(e=OSC7V8$u?XLLiSDmwApbEh)8+4a
znJ(`oFVo}mL*OsIOy~c=%XIt9LHUbcvFX=w5q7*n=O2BAmUsOtHa;qj5lX+O_1(8$
z5u;ffAq(*{uh8xN0;FH^Dm^|nze<n4Bd^l^@y%Cl5^rMa;mKF&{yFwFdj7ocHM%`x
zuhH#Odubf5Q$>FLIJH`@&slqz4_zX)Rc#U<K0`l$`KLI^^h+eEmd2c(4U;7DZmZU>
z2kf)bqI~moHjaj9hnuILwZL@t&A<85Z&+ZucY)~}7npwD0@K;&!RMRrPFdn3Pf29?
z+4T9+?^<B``3p?HY=P-)7#U-vB|6^-|E??x=It3ZO?Q5O{&q<2exqG;LDj~;f+I-}
z$o2b<aFt%auddeH8EiNlKJ=h;Ta_Ni=5$Z-@8z-Z>#9v}hp@ng^)W^^IC{D<5}Yvz
zf@n91zbur$%iCiMte5M1M*PjM+xXWZjBx+!^!lW{LC^O!Z`8K~3$1U^`sLsowEp}2
z8}xj2zA3&|VT4_8()uX*rWozf2p@dYrjOw$!o6?O>&bt<Y179F65-6ZY!V+<P7fb^
z%O>$*x%BX*w`l%fzeUS;y-n-G^>5Ss``@PZ$<=Su>-~Li)AmdFR9kJonD<ZMJw|(V
zq4=p&{&sxsUGn=+{oDDyJl?g|_BZb@7K+FF3*Tzv{$gOQG2aaTEAB6R+zI~I<EgiU
z&G!qQjYfVJ&xZjc+s(7S9xv`V#9tOBc)Zs$|9XWz_55Ogh`%f}o5~l{#a|W%czpBb
z`S)vavr)dv|N8jfZ^-uAeF+OW*{<K8uwYl}{S2&J5zN~~+(%Vpdu@M(_;-s~=uqtR
zc_C=W?N;oyx`+kycNJI&Dt0nIbPVF-ik&=%G->)ywt2bp{JM(sW9h|q6@OXC{n%K4
zOrL`FWBJASa_0QL0V982GyZ1T$7LmH!TI@k|I|knd+pkxNfICNdf|L?yj&@4lwXM$
ze-B#f<xDh4wYIo<`b`b>{-d&~{lxl<_>eWygoW;}&s*%|zU9Mzs-GV$VEp|SJGqbg
zwZ&e$_OkG_#a_F%u<$&jPs0ATS?#qxI~EH6A-)D~ge9;%m>=hNtkq8H<<g((#{&!9
zRy!XJ#|T*7dDi-NX5$PQBW6m{#a4T*f0JD!Sswrk=IQJ!<*e_Cg@um8S$-TY6d&Nn
z%^MB&T6>vYuZ<BUB{Ka|$=KiGzD(3tqMxFAno)O(wt|Ou9Evuhs0Uwv=bboP<{{%y
zt8JgesYZU$RuJa}PbN8e`J&ChyQ0bQu~4X#ZPJzI6MCM&qK}beX)<9Xbn*1;t5R%w
zhJScwfIra4+Rn=)n-t*7E!K}+r^Wxxfqe^mzUi!=aK7p6{%*eMyB3(vx|Zil&xVbi
zZ~8S0Ouu=7>4gQR|73ybk1sI&=>?`s!}?>zgZk4tQvG3WDWwgMvB4t-)0wmsWKTv(
z?4|f<{J^08A2yOuV!ZbMl$JLBpH7YsvM091NCkuZVO2d-DjaOv&{->p{m@v0@i@57
zNbFGjpf;$FWe^%<!};iwhxJiB<}LVumL6n}+zuMA@9D`$wb9Y|A+5HE!=s5osmPD7
zTD{MYD`7FdsIVL2^I$iBpjM<Wg8jxY%eDAP@Dz9&?BxZE^4<JI6wZKi{Gb!@WpIX9
z3?e?k#~BnZfoEBTXZjt%&2N%K`Yi7Z6`ldl@dmVr_wtLBaNhXrVa;=3(K#>DyLe~4
zaG2lV3(pMF<(&g3_-|Sw{RDWDk4r4#6MQ5tVIRA|o3@8*gt`na@^Sq|{w%Mbh5h^k
zTf!>;txC8E&hbGWM0|yh^DFG+<5df1uB6N7{2;aGI_h3<7@P$c*#}}w+hg)3>gmr?
zPw{ai#q#<8na2BWr7qt|J^L-{-tSVEen73>OI^8-I`aT^xkNqvW9kW3@tW2*`%~)4
z2dQV-!04v*r5S4H|E8V*Pl9K_u19J99N7IBji37sb@>_UD%krc8t(@Oz<F@)&oqAl
z?0<>Im)@YB1xs(z_+D@YJn$Axp8yZMP2+RmggzQ(y?&~Io&1hP9M3-R05}YG%f<ys
z<aa96DtH1s2`+-?zzIIiwwPbmO6NBP9^m7di}bVL3fOI@<@vyVu#+{wP1{#>QhUL@
z;2d~*G0k6IMqTCKV-)M-UQXkEtEj81sf#Lg_!MgORO(s&9V9Wo9P6Mpt#9uc)Ri--
zeQT))z!`83Tm(;p=fKiBIzJWc1rLA|;2gLBo(7k}QVU(4W^gt{;|t(2xC(Y^G=C91
zF+$^2_TdE6{wsjpVTkAVHDdoeub}a+6!ieuou=^ta0Wa9&aeTcP0KqA9{3QAuY8!g
zdNp-6OC3H!UHCZo6V!8H^?Dj#x`EoCqfUI9+VvUg%KxIye4aY+1?tSL)V;S;4}66>
z51s)B3N-!foz%{|s0(*fPke{k^<C;JxI9JUr`Qh+ru{wrBWh=f+6SKbF^%tikXoIl
zE<H>=`Acf|Bh;=L>gunlXJ)C(zok~6pdJ9v{X2~hupdZF+r#@u>e>IGo|>cf{h8YR
zpVY3uP|v+cU44n#`!aO`EWJkKGk>M_ze!zri+V;eZcs&iGhm_iS*hJ@pmo#skrq?C
zmQee_6X51$G=1(^>hN-EC%@qq%R9G{#wS)$53Hv4olM<)I<=eMz>D(3;7PFOESkTt
zj@sEuU1*~&by4?vsXg7){*Bb(^Qa5pGI(k;O<&ncUEM+LdLOu-dV+uVL~JkD9vWW-
zH}9wMo{Ojx-~u>%DNR3h8FeX0Jv$6$A38D}zf&=4HBOyKfUls=CaH7$yLn=J6w@@`
zJ4Rgs_a370UiQH<)AE+tgM22tucR(sMeY1Bwf_ip;X3M>k5N0Xrw*_O22Jy?-b9`I
z6t(*^)B~TTZsr|iVtYxq(fHDrs0+7Khrdca@C|C$UDWQosh!`UE`67J_IuQY`=|py
zq|Q7*-TM=2=|O7OL)0@rr=Iu)b^hO|2YyZMdX!pyjJo_=>iqAhoBxA4_h;$~*z;cy
z|2%cE0)BzI^dj}lOVpK@sWY!oORrK-fHSYr_~yS-=U=B*-=t2wO<mx>M2h28wHO_^
z!UHzyfRnn=NL^{7_AaH)E~A!?qn_a(+7k0uSJ3zgm3j_5c`}U;yoXvkgSvDk^~_n+
zeh;;)jaqG|p6sFybW<mKs4M4E7k$*FP1L^a)KV|CtB*Rji`u`NI^d@+@1vf)fI4vz
zwP%Pr56%rke2BWBQBRFf=h+9`O!c!GrY?Xz5gM;vPF*@k?Hi?@j!`#XLG4dbPmfVc
z8EWTM)cy}q=dY$NAE9<%M_u?Rb>@2N=}%IZKSe$FY3jmfsAoS*UHk%d;uh-ct<=(&
zsY|z0&wPd2e<!u;8`SDIsVDED4t$$B@g3^Q6m{`l>e7AGz7n<cV`|q=sB=G~_CHLm
z{(`#vD0S~+)KzfiH#9y6o(7k}6>#BkTAp*3dH@`F0^)y9JqxaY-A~f=KCmC`e2S(I
zgEN1m@e@x|H~)#+^=E3|U#K%LP?uh!cE3zL`5LwVuhjY1soif<7x)tl;`-*d8&5O{
zPp}Upnd-Y~aMelUry8hpjntJUYVQ*2%ra`va%va*0J3R$CcxekX?$e`wX}+QU^TV(
zWa{vHsi)7R&ab6b*HM?j+4VF&*9z{S&UaDw_E1l5r1qapt)5FgcOG?O6Sa3Mb#Xg&
zX$N(0FSVzSy0DYl(@*W&N1X*H255W*?7WD^`@jR>Fj&2q=Ffs>z|~7=dWpX)CC(R#
zzw0C%j?wf*@HBW9>`Kx61K<QW3zo)c{$6kZoB&T{X#QDn1)LqH>GR++xC(Y&N%K#D
zC&5Lq>nfVxcZ7NXJOQ2q7q6lDr@>XQ>sp%L2c81wucPUU;4;|x5t=>$4u6!!PlLlB
zqwythV1mZy!7l#2J#l>dz(sKQ6STZZ@GRJOJxyN)yFW?e1K??J=?0o!y^*>EZoY}e
zPk}37{}*ZcJa`t|JW130!4u#TxC(aPM#~!jPk^VubKvGL(eir18So@{8e9Q4f0>r=
z1Bbym@D#WVcHU0Q_kah$8E_sv1)c?0!OdTx^Y?-Wz!`8JJO!QwSHaC+h53UAz!`8J
zJO!QwSHaC+gZYC8z!`8JJO!QwSHaB%m_K*`?7oAhPk<-DdGN%YH2*AE{W^^ggA3p}
zu=^X3A3O=31-rgU^Y?<Y;3;qg?7oYZHvpahPl4ya&3DuCdchfR0Xz$K7HN52a2T8e
zPl3x|=RLH14|o8a1sA|G;3`=C7M))&I04RsOW--M>)W(^FE{|602jftVCg%wd^gw+
z&VVPu)8GoYnZGMnYoCC_;4FBSzauE}SHSL{(Dm_w{opdV3U>aKmNy5M9;ERuaPCnW
zUjR>o%V6hYG`}0{0|&qva2{L)&w%H^&fn1GQNcd&05}8Afs5d2@Ellr9F_;{1rLA|
z;2gLBo(7k}(kxw`W^nkoG(HQ?ze3}S;1W1*HQqcC=R?*`od?f=r<^qX4A|8`<0l)b
zr@*t|3OLt9^B2I=;4*lEkI5s}cN*+uAKo_gKlOsM;3;qg>^_l}mjF+Ii{M$Xw1SrB
z2K&Jo@FaK|>^cd`2m8Sp@FaK|>{&_6Pk@Wy3fR4h<`01L;2Cfg+`Age0~f$E;3`;M
zL(A(0C%}1d2|Nq-sI>eEa1lHUmiU-c;`na{XTSw;3C-V47Uj)?o$sZ~8vtj(li)e9
zbQ&#B1^0sU;3BvJcAiel?`@&ZbW%@(r@+oGnqCFxz|-JnFU{`<hrtuz0=T&w$^(bN
z1#k(R@1f-t!D0T6xHvwt;1akBcArhl4}f#v61W0Z&!Oe{!C7z-Tn4+&rRDj+32+Wv
z1W$wKz|QmN{M_JPa2PxRE`X=OWw7L<^H;$>Z~&YIPl8L}GFaLK^9TFD0q`t%g1^Hr
zj?d{GwEQwy<zqIA^xpT=^d;~tcn)0V@8XN{s^DqyPQKnMktFB&bbeuQ5$xPU)0e=_
zdujY6coyv5N7EO<(_r_0ntmFrUO?j$;4(OHAx%F8o&!%`Lepn2rOtx~K0xCqE~B0U
z`v)N&JQbkv74TG$#?OE!`3vM?|L2BjdRK_r$;VO<=>y;r9}7XmdoQQ?y`$8#U}u)b
z`@p@|(D*z!d_9fNeUdu-Y3jLuq8|7R^(?sevowAh?EM^#_uNXI0GGj@FVgf`a0Tq1
zr0JcvQJ2A`FVpy`+o|1Op$>p^;1bwdp!xmaBDf5mxP#`O2A9EAu=h@y-w!VHF;B(u
z+51hJz6|!<MdQ`Gsi(oYB8~UnL+$()brGEXHjQ_Ghq?^TeV4}fevi5eE>F?;i62mh
z@1t(MpSlcg{vnO8fc+29_%gVekDVd*M;<%}_WuhlZw~AgW5)37SsCp5Db1e&=fEZK
zEO_8ST3!zQ5RG^LjM@vXf=kmheFZGWeirLH&BuZko&nE+E8r?vT4IbRBFb}uUEpT0
z3U-5i-~n&~oB?OS6W~d30bBylg3I7Ja0TpKO1GB^_JaN3FgOd&gNxu2cotj%SHUh9
zUH)dU2kZs=!C`O~oCg=d)8I0=3U=|ajm7b*f<0g#*bfeX6W}a32c85M!P8(dHnUj%
zD#T02!2SWNU^mzU_JV!jUa%iL08W52;4F9oJP9s<OW;{>89WEBfSt$E?dbx$!9MT+
zI04RrbKpsE5nKY#fXm<tSUL{Y53GVcU?12I4uBKjEI0?A1Q)?2@C>*Nu7IWEVg11>
z*aP-~{onvN0nUPR;7M>1TmsL4%is!FS`O<ER>2;y59|jAzzJ{`oC8mSi{KJ?23!VL
zz|sk@{$LgC0sFvyZ~&YDXTdq}B)AAJfoH&Fa0M(i!}^0&um|h|`@sQl0-Ocsz?0x2
zxCEX7m%$aVbRw)jSOt5)y<k5$49<e{;39Y$Tn1Oct`&5B++ZJg0Gt3%fG5FI;2H27
zSUQO=Uo+SP?ga<HVQ?0l0~f$k;2H27SXv3o4_3imun+792fzt%7Muf5f{Wl1cm`Ys
zSHRLLy8bS(3ig0~U_UqjPJpxE9C#8u1ulVS!DVn2Eb+06Mf<xMtb)B@G4`>@KLGIo
za0Z+OPk?jaJa`gZ02jei;2H2NxB{+%U2Ev^(+u{2y<k6h0Gt44z&UUpJP9s<r@%Ad
zIdBE+RAK$WZm<{J3myQ6!5Q!bcoJLyPl0E^v*0;!73?}0)*q~b-C!TM7aRa*z*+DF
zI0r6(OW;}X9JmU0o&xI+c7wg(Uhn`o49<Wjz<F>1JO!Qx&w}T`Rj}(lbp736A9w&9
z0B68ia2_ni5f=6DB>z2@4XesV*6|s`1?Xl^vX%MxtSp|{-(++g3lD%N`M}H~z5veg
z@mNKCo_`!pcoOX7gH?-o7r4MbP$c4uU>EyPoK#<*X0V%&uPXBAz<KZ#|G<z)Ujj=3
zI=@Li-l|AHdj*Xz@bOJWyvoNj6_)sTrouU}%Evbq@c}+wsc;@V3-*45E>H6WwHuuO
zIE^oWou8!fF7UvOG(G@Me2&Ivz*Rnes#rhi7MecK$4eFQ0X|-;u*%0v6)y1cQiZ4Z
zc%#B|;4B+(+H^ckfL(k%P?0|ac0Eh;H-k%jyik$9!p8#@p5Wto3McsZox%lhmXE(F
z;-~ren8JBJ{-y8?ILybd6!8H*{-kh%kEbYH0GGkde7r-E-VdGtm%vr9hmVga%9{X}
z!E<1@&lpck<j;a9z}`JH{RDUxTn4LryhSm;aFUic$;UGk@lzk8@g?x&KN}UcNM8V#
z`FJZLehxhGG2?x85uXD)`S<}MKEcNe5DxSA`GtGSw7e>RKVQU4&(ioQ{=U74FM*}E
zXnH5u&);ts`BnaYyRaLqt}&j^uEm2hZ8ScM=I=L){B!*MW#PmK%|8P!MreEq>^Vr|
zec%dzf4MflI8C1c7q6i4Q{X&*pIMYQ!QW37o;ytQXZiccBHqd0FBUF>RsR04h@S=*
z`TJfXzIrd6pYuNI41Zrlq@Msge@N4Z`THOuy~^MJ5O(wTJ%sZQ)BMdprylqPbpTxA
z?|+E$s$iABk0Ig*z&Y?VSmN(bi2Pn~0$c!>!Oi^r2T`6MJOM6&t6&d*UqY1E3(oWR
zB}BaR65XD&{QU?KUj>I>hxB0on>0ReF`f?)<<0T;CxqSn{RrV1{=S2-a}mv7;_owv
z_$oNCn5GXbrLMZD1Iws=$5NM$qYf;m&a9($@#m$*^386b@hX2lSj0E;=Y56U;DYJ?
zfNj|#cp5wdmiY6XqI?&)w3RO34A{G!#`l7~{CQAOelK_coPQrJufU%N75Sx|G``wT
z?c>jfiu5^f9_;1MgNpQ3{(PqJ1b-e=xC9>H&tHmoFMqzWX8sK);Vgf?Pq@IJ?-S1Q
z=lg_b`15_jMgBaWa0xugpXU?tMR1Nk-zVZHZlT*R!=J|!@zdZce;!Z7&++H+guVQE
zJmD~ZK2CTVTm^gi^JpS{fj^HXtn%m0g!BA)GvO+KzDzj4pC1#h^5@5dv;286;aUEC
zlCbk(x_#XIdj>3?#S~5V56sPcynhiN06R_h2YShT{Ckmp0$eb)=UMtPA5UJSuk!Ka
zg<X97c;O5m-&=TqkJlmW=HqJ!m-%=a!d^Z;hOnEDhasE+7r`nY-$JA>^6@N$y?lHM
z;T#{2LO9FEn-HD>J9G8x3EMt7Q~k!=Yib{{o}I+w`c~J=WA;tg^RuoL?-TWS=78yX
z#QJ2ywtBq&z0+6g`PnjhOxG*+4J-AndOYijY3A?$v9#>_p+5d?L}vDlshQb&`Aa29
zs{XES{nI%u;zLL+>_bQ`X^s6G8jq#YNvVZ>z^EmuMO%__N&g!fj~TJ!qx#?AXk=Jw
zNrhACWI8w`wIt*EH;?}Nfh{Y$6Eb?wB#D2Pp#JyYjr9;g^lypK&-07#hWUPPq!)kV
z>;t5xz&|5Y3#{9T&EL2ik!sHsisuXQ17SG-jeOZ_`FX!w?Ju7b?{2H*7t6usZJxjA
z#}j`=IuUUG?fm<wynC<q9W?Phv^*<ZlJxnr|BC$L`)KT2?`+vce({|&@mG8&O$1(C
sEwJxWv*TIh7vFIcf5ms)#QqiY7wfgvwC&BoeUp*n0`o+^t<2&70$$)Nk^lez

literal 0
HcmV?d00001

diff --git a/programs/sbf/Cargo.lock b/programs/sbf/Cargo.lock
index 8868281b8d45..1a45ef6997f2 100644
--- a/programs/sbf/Cargo.lock
+++ b/programs/sbf/Cargo.lock
@@ -123,6 +123,7 @@ dependencies = [
  "solana-rpc-client",
  "solana-rpc-client-api",
  "solana-runtime",
+ "solana-runtime-plugin",
  "solana-sdk",
  "solana-send-transaction-service",
  "solana-storage-bigtable",
@@ -136,6 +137,7 @@ dependencies = [
  "thiserror",
  "tikv-jemallocator",
  "tokio",
+ "tonic",
 ]
 
 [[package]]
@@ -201,6 +203,145 @@ version = "0.2.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"
 
+[[package]]
+name = "anchor-attribute-access-control"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "regex",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-account"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "bs58 0.4.0",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "rustversion",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-constant"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "proc-macro2 1.0.85",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-error"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-event"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-interface"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "heck 0.3.3",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-program"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-attribute-state"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-derive-accounts"
+version = "0.24.2"
+dependencies = [
+ "anchor-syn",
+ "anyhow",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "anchor-lang"
+version = "0.24.2"
+dependencies = [
+ "anchor-attribute-access-control",
+ "anchor-attribute-account",
+ "anchor-attribute-constant",
+ "anchor-attribute-error",
+ "anchor-attribute-event",
+ "anchor-attribute-interface",
+ "anchor-attribute-program",
+ "anchor-attribute-state",
+ "anchor-derive-accounts",
+ "arrayref",
+ "base64 0.13.1",
+ "bincode",
+ "borsh 0.10.3",
+ "bytemuck",
+ "solana-program",
+ "thiserror",
+]
+
+[[package]]
+name = "anchor-syn"
+version = "0.24.2"
+dependencies = [
+ "anyhow",
+ "bs58 0.3.1",
+ "heck 0.3.3",
+ "proc-macro2 1.0.85",
+ "proc-macro2-diagnostics",
+ "quote 1.0.36",
+ "serde",
+ "serde_json",
+ "sha2 0.9.9",
+ "syn 1.0.109",
+ "thiserror",
+]
+
 [[package]]
 name = "android-tzdata"
 version = "0.1.1"
@@ -240,8 +381,8 @@ dependencies = [
  "include_dir",
  "itertools 0.10.5",
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -305,7 +446,7 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3ed4aa4fe255d0bc6d79373f7e31d2ea147bcf486cba1be5ba7ea85abdb92348"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -317,8 +458,8 @@ checksum = "7abe79b0e4288889c4574159ab790824d0033b9fdcb2a112a3182fac2e514565"
 dependencies = [
  "num-bigint 0.4.5",
  "num-traits",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -353,8 +494,8 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ae3281bc6d0fd7e549af32b52511e1302185bd688fd3359fa36423346ff682ea"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -414,8 +555,8 @@ version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "726535892e8eae7e70657b4c8ea93d26b8553afb1ce617caee529ef96d7dee6c"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
  "synstructure",
 ]
@@ -426,8 +567,8 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2777730b2039ac0f95f093556e61b6d26cebed5393ca6f152717777cec3a42ed"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -488,8 +629,8 @@ version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "16e62a023e7c117e27523144c5d2459f4397fcc3cab0085af8e2224f643a0193"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -499,8 +640,8 @@ version = "0.1.80"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c6fa2087f2753a7da8cc1c0dbfcf89579dd57458e36769de5ac750b4671737ca"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -649,8 +790,8 @@ dependencies = [
  "itertools 0.12.1",
  "lazy_static",
  "lazycell",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "regex",
  "rustc-hash",
  "shlex",
@@ -749,7 +890,7 @@ dependencies = [
  "borsh-derive-internal",
  "borsh-schema-derive-internal",
  "proc-macro-crate 0.1.5",
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "syn 1.0.109",
 ]
 
@@ -761,8 +902,8 @@ checksum = "c3ef8005764f53cd4dca619f5bf64cafd4664dada50ece25e4d81de54c80cc0b"
 dependencies = [
  "once_cell",
  "proc-macro-crate 3.1.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
  "syn_derive",
 ]
@@ -773,8 +914,8 @@ version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "afb438156919598d2c7bad7e1c0adf3d26ed3840dbc010db1a882a65583ca2fb"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -784,8 +925,8 @@ version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "634205cc43f74a1b9046ef87c4540ebda95696ec0f315024860cad7c5b0f5ccd"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -810,6 +951,18 @@ dependencies = [
  "alloc-stdlib",
 ]
 
+[[package]]
+name = "bs58"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "476e9cd489f9e121e02ffa6014a8ef220ecb15c05ed23fc34cca13925dc283fb"
+
+[[package]]
+name = "bs58"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "771fe0050b883fcc3ea2359b1a96bcfbc090b7116eae7c3c512c7a083fdf23d3"
+
 [[package]]
 name = "bs58"
 version = "0.5.1"
@@ -860,8 +1013,8 @@ version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1ee891b04274a59bd38b412188e24b849617b2e45a0fd8d057deb63e7403761b"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1265,8 +1418,8 @@ checksum = "ab8bfa2e259f8ee1ce5e97824a3c55ec4404a0d772ca7fa96bf19f0752a046eb"
 dependencies = [
  "fnv",
  "ident_case",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "strsim 0.10.0",
  "syn 2.0.58",
 ]
@@ -1278,7 +1431,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "29a358ff9f12ec09c3e61fef9b5a9902623a695a46a917b07f269bff1445611a"
 dependencies = [
  "darling_core",
- "quote",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1302,6 +1455,17 @@ version = "2.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e8566979429cf69b49a5c740c60791108e86440e8be149bbea4fe54d2c32d6e2"
 
+[[package]]
+name = "default-env"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f753eb82d29277e79efc625e84aecacfd4851ee50e05a8573a4740239a77bfd3"
+dependencies = [
+ "proc-macro2 0.4.30",
+ "quote 0.6.13",
+ "syn 0.15.44",
+]
+
 [[package]]
 name = "der-parser"
 version = "8.2.0"
@@ -1337,8 +1501,8 @@ version = "2.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1349,8 +1513,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321"
 dependencies = [
  "convert_case",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustc_version",
  "syn 1.0.109",
 ]
@@ -1429,8 +1593,8 @@ version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "487585f4d0c6655fe74905e2504d8ad6908e4db67f744eb140876906c2f3175d"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1452,8 +1616,8 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a6cbae11b3de8fce2a456e8ea3dada226b35fe791f0dc1d360c0941f0bb681f3"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1511,8 +1675,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0f0042ff8246a363dbe77d2ceedb073339e85a804b9a47636c6e016a9a32c05f"
 dependencies = [
  "enum-ordinalize",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -1561,8 +1725,8 @@ version = "1.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "03cdc46ec28bd728e67540c528013c6a10eb69a02eb31078a1bda695438cbfb8"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1574,8 +1738,8 @@ checksum = "1bf1fa3f06bbff1ea5b1a9c7b14aa992a39657db60a2759457328d7e058f49ee"
 dependencies = [
  "num-bigint 0.4.5",
  "num-traits",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -1802,8 +1966,8 @@ version = "0.3.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -2019,6 +2183,15 @@ dependencies = [
  "http",
 ]
 
+[[package]]
+name = "heck"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
+dependencies = [
+ "unicode-segmentation",
+]
+
 [[package]]
 name = "heck"
 version = "0.4.0"
@@ -2274,8 +2447,8 @@ version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b139284b5cf57ecfa712bcc66950bb635b31aff41c188e8a4cfc758eca374a3f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
 ]
 
 [[package]]
@@ -2366,6 +2539,49 @@ version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
 
+[[package]]
+name = "jito-programs-vote-state"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "bincode",
+ "serde",
+ "serde_derive",
+ "solana-program",
+]
+
+[[package]]
+name = "jito-protos"
+version = "2.0.7"
+dependencies = [
+ "bytes",
+ "prost",
+ "prost-types",
+ "protobuf-src",
+ "tonic",
+ "tonic-build",
+]
+
+[[package]]
+name = "jito-tip-distribution"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "default-env",
+ "jito-programs-vote-state",
+ "solana-program",
+ "solana-security-txt",
+]
+
+[[package]]
+name = "jito-tip-payment"
+version = "0.1.5"
+dependencies = [
+ "anchor-lang",
+ "default-env",
+ "solana-security-txt",
+]
+
 [[package]]
 name = "jobserver"
 version = "0.1.21"
@@ -2446,8 +2662,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5b939a78fa820cdfcb7ee7484466746a7377760970f6f9c6fe19f9edcc8a38d2"
 dependencies = [
  "proc-macro-crate 0.1.5",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -2905,8 +3121,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "22ce75669015c4f47b289fd4d4f56e894e4c96003ffdf3ac51313126f94c6cbb"
 dependencies = [
  "cfg-if 1.0.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -2926,8 +3142,8 @@ version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a7d5f7076603ebc68de2dc6a650ec331a062a13abaa346975be747bbfa4b789"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3051,8 +3267,8 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3123,8 +3339,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "681030a937600a36906c185595136d26abfebb4aa9c65701cefcaf8578bb982b"
 dependencies = [
  "proc-macro-crate 3.1.0",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3185,8 +3401,8 @@ version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3388,8 +3604,8 @@ checksum = "3ec22af7d3fb470a85dd2ca96b7c577a1eb4ef6f1683a9fe9a8c16e136c04687"
 dependencies = [
  "pest",
  "pest_meta",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3429,8 +3645,8 @@ version = "1.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2f38a4412a78282e09a2cf38d195ea5420d15ba0602cb375210efbc877243965"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3530,7 +3746,7 @@ version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3b83ec2d0af5c5c556257ff52c9f98934e243b9fd39604bfb2a9b75ec2e97f18"
 dependencies = [
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "syn 1.0.109",
 ]
 
@@ -3565,8 +3781,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
 dependencies = [
  "proc-macro-error-attr",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
  "version_check",
 ]
@@ -3577,11 +3793,20 @@ version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "version_check",
 ]
 
+[[package]]
+name = "proc-macro2"
+version = "0.4.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759"
+dependencies = [
+ "unicode-xid 0.1.0",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.85"
@@ -3591,6 +3816,19 @@ dependencies = [
  "unicode-ident",
 ]
 
+[[package]]
+name = "proc-macro2-diagnostics"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bf29726d67464d49fa6224a1d07936a8c08bb3fba727c7493f6cf1616fdaada"
+dependencies = [
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
+ "syn 1.0.109",
+ "version_check",
+ "yansi",
+]
+
 [[package]]
 name = "prost"
 version = "0.11.9"
@@ -3608,7 +3846,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "119533552c9a7ffacc21e099c24a0ac8bb19c2a2a3f363de84cd9b844feab270"
 dependencies = [
  "bytes",
- "heck",
+ "heck 0.4.0",
  "itertools 0.10.5",
  "lazy_static",
  "log",
@@ -3631,8 +3869,8 @@ checksum = "e5d2d8d10f3c6ded6da8b05b5fb3b8a5082514344d56c9f871412d29b4e075b4"
 dependencies = [
  "anyhow",
  "itertools 0.10.5",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -3669,8 +3907,8 @@ version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9e2e25ee72f5b24d773cae88422baddefff7714f97aab68d96fe2b6fc4a28fb2"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -3722,13 +3960,22 @@ dependencies = [
  "windows-sys 0.48.0",
 ]
 
+[[package]]
+name = "quote"
+version = "0.6.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ce23b6b870e8f94f81fb0a363d65d86675884b34a09043c81e5562f11c1f8e1"
+dependencies = [
+ "proc-macro2 0.4.30",
+]
+
 [[package]]
 name = "quote"
 version = "1.0.36"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
 dependencies = [
- "proc-macro2",
+ "proc-macro2 1.0.85",
 ]
 
 [[package]]
@@ -4091,7 +4338,7 @@ checksum = "3f56a14d1f48b391359b22f731fd4bd7e43c97f3c50eee276f3aa09c94784d3e"
 dependencies = [
  "log",
  "ring 0.17.3",
- "rustls-webpki",
+ "rustls-webpki 0.101.7",
  "sct",
 ]
 
@@ -4116,6 +4363,16 @@ dependencies = [
  "base64 0.13.1",
 ]
 
+[[package]]
+name = "rustls-webpki"
+version = "0.100.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f6a5fc258f1c1276dfe3016516945546e2d5383911efc0fc4f1cdc5df3a4ae3"
+dependencies = [
+ "ring 0.16.20",
+ "untrusted 0.7.1",
+]
+
 [[package]]
 name = "rustls-webpki"
 version = "0.101.7"
@@ -4177,8 +4434,8 @@ version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bdbda6ac5cd1321e724fa9cee216f3a61885889b896f073b8f82322789c5250e"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -4254,8 +4511,8 @@ version = "1.0.203"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "500cbc0ebeb6f46627f50f3f5811ccf6bf00643be300b4c3eabc0ef55dc5b5ba"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -4299,8 +4556,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "881b6f881b17d13214e5d494c939ebab463d01264ce1811e9d4ac3a882e7695f"
 dependencies = [
  "darling",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -4525,7 +4782,7 @@ dependencies = [
  "Inflector",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "bv",
  "lazy_static",
  "serde",
@@ -4634,6 +4891,7 @@ dependencies = [
  "futures 0.3.30",
  "solana-banks-interface",
  "solana-client",
+ "solana-gossip",
  "solana-runtime",
  "solana-sdk",
  "solana-send-transaction-service",
@@ -4695,6 +4953,27 @@ dependencies = [
  "tempfile",
 ]
 
+[[package]]
+name = "solana-bundle"
+version = "2.0.7"
+dependencies = [
+ "anchor-lang",
+ "itertools 0.12.1",
+ "log",
+ "serde",
+ "solana-accounts-db",
+ "solana-ledger",
+ "solana-logger",
+ "solana-measure",
+ "solana-poh",
+ "solana-program-runtime",
+ "solana-runtime",
+ "solana-sdk",
+ "solana-svm",
+ "solana-transaction-status",
+ "thiserror",
+]
+
 [[package]]
 name = "solana-clap-utils"
 version = "2.0.10"
@@ -4832,9 +5111,10 @@ name = "solana-core"
 version = "2.0.10"
 dependencies = [
  "ahash 0.8.10",
+ "anchor-lang",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "bytes",
  "chrono",
  "crossbeam-channel",
@@ -4843,12 +5123,17 @@ dependencies = [
  "futures 0.3.30",
  "histogram",
  "itertools 0.12.1",
+ "jito-protos",
+ "jito-tip-distribution",
+ "jito-tip-payment",
  "lazy_static",
  "log",
  "lru",
  "min-max-heap",
  "num_enum",
  "prio-graph",
+ "prost",
+ "prost-types",
  "qualifier_attr",
  "quinn",
  "rand 0.8.5",
@@ -4862,6 +5147,7 @@ dependencies = [
  "serde_derive",
  "solana-accounts-db",
  "solana-bloom",
+ "solana-bundle",
  "solana-client",
  "solana-compute-budget",
  "solana-connection-cache",
@@ -4881,6 +5167,7 @@ dependencies = [
  "solana-rpc",
  "solana-rpc-client-api",
  "solana-runtime",
+ "solana-runtime-plugin",
  "solana-sdk",
  "solana-send-transaction-service",
  "solana-streamer",
@@ -4900,6 +5187,8 @@ dependencies = [
  "tempfile",
  "thiserror",
  "tokio",
+ "tonic",
+ "tonic-build",
  "trees",
 ]
 
@@ -5005,7 +5294,7 @@ name = "solana-geyser-plugin-manager"
 version = "2.0.10"
 dependencies = [
  "agave-geyser-plugin-interface",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "json5",
  "jsonrpc-core",
@@ -5289,7 +5578,7 @@ dependencies = [
  "blake3",
  "borsh 0.10.3",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "bv",
  "bytemuck",
  "bytemuck_derive",
@@ -5454,7 +5743,7 @@ version = "2.0.10"
 dependencies = [
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "crossbeam-channel",
  "dashmap",
  "itertools 0.12.1",
@@ -5473,6 +5762,7 @@ dependencies = [
  "soketto",
  "solana-account-decoder",
  "solana-accounts-db",
+ "solana-bundle",
  "solana-client",
  "solana-entry",
  "solana-faucet",
@@ -5483,6 +5773,7 @@ dependencies = [
  "solana-metrics",
  "solana-perf",
  "solana-poh",
+ "solana-program-runtime",
  "solana-rayon-threadlimit",
  "solana-rpc-client-api",
  "solana-runtime",
@@ -5512,7 +5803,7 @@ dependencies = [
  "async-trait",
  "base64 0.22.1",
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "indicatif",
  "log",
  "reqwest",
@@ -5536,7 +5827,7 @@ version = "2.0.10"
 dependencies = [
  "anyhow",
  "base64 0.22.1",
- "bs58",
+ "bs58 0.5.1",
  "jsonrpc-core",
  "reqwest",
  "reqwest-middleware",
@@ -5545,8 +5836,10 @@ dependencies = [
  "serde_derive",
  "serde_json",
  "solana-account-decoder",
+ "solana-bundle",
  "solana-inline-spl",
  "solana-sdk",
+ "solana-svm",
  "solana-transaction-status",
  "solana-version",
  "thiserror",
@@ -5641,6 +5934,24 @@ dependencies = [
  "zstd",
 ]
 
+[[package]]
+name = "solana-runtime-plugin"
+version = "2.0.7"
+dependencies = [
+ "crossbeam-channel",
+ "json5",
+ "jsonrpc-core",
+ "jsonrpc-core-client",
+ "jsonrpc-derive",
+ "jsonrpc-ipc-server",
+ "jsonrpc-server-utils",
+ "libloading 0.7.4",
+ "log",
+ "solana-runtime",
+ "solana-sdk",
+ "thiserror",
+]
+
 [[package]]
 name = "solana-sbf-programs"
 version = "2.0.10"
@@ -6102,10 +6413,12 @@ dependencies = [
 name = "solana-sdk"
 version = "2.0.10"
 dependencies = [
+ "anchor-lang",
+ "base64 0.22.1",
  "bincode",
  "bitflags 2.5.0",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "bytemuck",
  "bytemuck_derive",
  "byteorder 1.5.0",
@@ -6150,9 +6463,9 @@ dependencies = [
 name = "solana-sdk-macro"
 version = "2.0.10"
 dependencies = [
- "bs58",
- "proc-macro2",
- "quote",
+ "bs58 0.5.1",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustversion",
  "syn 2.0.58",
 ]
@@ -6171,6 +6484,7 @@ dependencies = [
  "log",
  "solana-client",
  "solana-connection-cache",
+ "solana-gossip",
  "solana-measure",
  "solana-metrics",
  "solana-runtime",
@@ -6229,7 +6543,7 @@ name = "solana-storage-proto"
 version = "2.0.10"
 dependencies = [
  "bincode",
- "bs58",
+ "bs58 0.5.1",
  "prost",
  "protobuf-src",
  "serde",
@@ -6395,7 +6709,7 @@ dependencies = [
  "base64 0.22.1",
  "bincode",
  "borsh 1.5.1",
- "bs58",
+ "bs58 0.5.1",
  "lazy_static",
  "log",
  "serde",
@@ -6706,7 +7020,7 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9e8418ea6269dcfb01c712f0444d2c75542c04448b480e87de59d2865edc750"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "spl-discriminator-syn",
  "syn 2.0.58",
 ]
@@ -6717,8 +7031,8 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8c1f05593b7ca9eac7caca309720f2eafb96355e037e6d373b909a80fe7b69b9"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "sha2 0.10.8",
  "syn 2.0.58",
  "thiserror",
@@ -6766,8 +7080,8 @@ version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e6d375dd76c517836353e093c2dbb490938ff72821ab568b545fd30ab3256b3e"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "sha2 0.10.8",
  "syn 2.0.58",
 ]
@@ -6925,9 +7239,9 @@ version = "0.24.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59"
 dependencies = [
- "heck",
- "proc-macro2",
- "quote",
+ "heck 0.4.0",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "rustversion",
  "syn 1.0.109",
 ]
@@ -6944,14 +7258,25 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a7973cce6668464ea31f176d85b13c7ab3bba2cb3b77a2ed26abd7801688010a"
 
+[[package]]
+name = "syn"
+version = "0.15.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ca4b3b69a77cbe1ffc9e198781b7acb0c7365a883670e8f1c1bc66fba79a5c5"
+dependencies = [
+ "proc-macro2 0.4.30",
+ "quote 0.6.13",
+ "unicode-xid 0.1.0",
+]
+
 [[package]]
 name = "syn"
 version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "unicode-ident",
 ]
 
@@ -6961,8 +7286,8 @@ version = "2.0.58"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "44cfb93f38070beee36b3fef7d4f5a16f27751d94b187b666a5cc5e9b0d30687"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "unicode-ident",
 ]
 
@@ -6973,8 +7298,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1329189c02ff984e9736652b1631330da25eaa6bc639089ed4915d25446cbe7b"
 dependencies = [
  "proc-macro-error",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -6990,10 +7315,10 @@ version = "0.12.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
- "unicode-xid",
+ "unicode-xid 0.2.4",
 ]
 
 [[package]]
@@ -7081,8 +7406,8 @@ version = "0.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ee42b4e559f17bce0385ebf511a7beb67d5cc33c12c96b7f4e9789919d9c10f"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -7152,8 +7477,8 @@ version = "1.0.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "46c3384250002a6d5af4d114f2845d37b57521033f30d5c3f46c4d70e1197533"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -7289,8 +7614,8 @@ version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "630bdcf245f78637c13ec01ffae6187cca34625e8c63150d424b59e55af2675e"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -7433,6 +7758,7 @@ dependencies = [
  "percent-encoding 2.3.1",
  "pin-project",
  "prost",
+ "rustls-native-certs",
  "rustls-pemfile",
  "tokio",
  "tokio-rustls",
@@ -7441,6 +7767,7 @@ dependencies = [
  "tower-layer",
  "tower-service",
  "tracing",
+ "webpki-roots 0.23.1",
 ]
 
 [[package]]
@@ -7450,9 +7777,9 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a6fdaae4c2c638bb70fe42803a26fbd6fc6ac8c72f5c59f67ecc2a2dcabf4b07"
 dependencies = [
  "prettyplease",
- "proc-macro2",
+ "proc-macro2 1.0.85",
  "prost-build",
- "quote",
+ "quote 1.0.36",
  "syn 1.0.109",
 ]
 
@@ -7507,8 +7834,8 @@ version = "0.1.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -7621,12 +7948,24 @@ dependencies = [
  "tinyvec",
 ]
 
+[[package]]
+name = "unicode-segmentation"
+version = "1.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"
+
 [[package]]
 name = "unicode-width"
 version = "0.1.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3"
 
+[[package]]
+name = "unicode-xid"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
+
 [[package]]
 name = "unicode-xid"
 version = "0.2.4"
@@ -7796,8 +8135,8 @@ dependencies = [
  "bumpalo",
  "log",
  "once_cell",
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
  "wasm-bindgen-shared",
 ]
@@ -7820,7 +8159,7 @@ version = "0.2.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
 dependencies = [
- "quote",
+ "quote 1.0.36",
  "wasm-bindgen-macro-support",
 ]
 
@@ -7830,8 +8169,8 @@ version = "0.2.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
@@ -7853,13 +8192,22 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "webpki-roots"
+version = "0.23.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b03058f88386e5ff5310d9111d53f48b17d732b401aeb83a8d5190f2ac459338"
+dependencies = [
+ "rustls-webpki 0.100.3",
+]
+
 [[package]]
 name = "webpki-roots"
 version = "0.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b291546d5d9d1eab74f069c77749f2cb8504a12caa20f0f2de93ddbf6f411888"
 dependencies = [
- "rustls-webpki",
+ "rustls-webpki 0.101.7",
 ]
 
 [[package]]
@@ -8102,6 +8450,12 @@ dependencies = [
  "rustix",
 ]
 
+[[package]]
+name = "yansi"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09041cd90cf85f7f8b2df60c646f853b7f535ce68f85244eb6731cf89fa498ec"
+
 [[package]]
 name = "zerocopy"
 version = "0.7.31"
@@ -8117,8 +8471,8 @@ version = "0.7.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b3c129550b3e6de3fd0ba67ba5c81818f9805e58b8d7fee80a3a59d2c9fc601a"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
@@ -8137,8 +8491,8 @@ version = "1.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
 dependencies = [
- "proc-macro2",
- "quote",
+ "proc-macro2 1.0.85",
+ "quote 1.0.36",
  "syn 2.0.58",
 ]
 
diff --git a/programs/sbf/tests/programs.rs b/programs/sbf/tests/programs.rs
index 55802a89dcbc..0b014c145659 100644
--- a/programs/sbf/tests/programs.rs
+++ b/programs/sbf/tests/programs.rs
@@ -136,7 +136,7 @@ fn execute_transactions(
     let batch = bank.prepare_batch_for_tests(txs.clone());
     let mut timings = ExecuteTimings::default();
     let mut mint_decimals = HashMap::new();
-    let tx_pre_token_balances = collect_token_balances(&bank, &batch, &mut mint_decimals);
+    let tx_pre_token_balances = collect_token_balances(&bank, &batch, &mut mint_decimals, None);
     let (
         TransactionResults {
             execution_results, ..
@@ -154,7 +154,7 @@ fn execute_transactions(
         &mut timings,
         None,
     );
-    let tx_post_token_balances = collect_token_balances(&bank, &batch, &mut mint_decimals);
+    let tx_post_token_balances = collect_token_balances(&bank, &batch, &mut mint_decimals, None);
 
     izip!(
         txs.iter(),
diff --git a/rpc-client-api/Cargo.toml b/rpc-client-api/Cargo.toml
index 22a883244c70..bfc61c9ba172 100644
--- a/rpc-client-api/Cargo.toml
+++ b/rpc-client-api/Cargo.toml
@@ -21,8 +21,10 @@ serde = { workspace = true }
 serde_derive = { workspace = true }
 serde_json = { workspace = true }
 solana-account-decoder = { workspace = true }
+solana-bundle = { workspace = true }
 solana-inline-spl = { workspace = true }
 solana-sdk = { workspace = true }
+solana-svm = { workspace = true }
 solana-transaction-status = { workspace = true }
 solana-version = { workspace = true }
 thiserror = { workspace = true }
diff --git a/rpc-client-api/src/bundles.rs b/rpc-client-api/src/bundles.rs
new file mode 100644
index 000000000000..5f47a102e982
--- /dev/null
+++ b/rpc-client-api/src/bundles.rs
@@ -0,0 +1,166 @@
+//! Use a separate file for Jito related code to minimize upstream merge conflicts.
+
+use {
+    crate::config::RpcSimulateTransactionAccountsConfig,
+    solana_account_decoder::UiAccount,
+    solana_bundle::{bundle_execution::LoadAndExecuteBundleError, BundleExecutionError},
+    solana_sdk::{
+        clock::Slot,
+        commitment_config::{CommitmentConfig, CommitmentLevel},
+        signature::Signature,
+        transaction::TransactionError,
+    },
+    solana_svm::transaction_results::TransactionExecutionResult,
+    solana_transaction_status::{UiTransactionEncoding, UiTransactionReturnData},
+    thiserror::Error,
+};
+
+#[derive(Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
+pub enum RpcBundleSimulationSummary {
+    /// error and offending transaction signature if applicable
+    Failed {
+        error: RpcBundleExecutionError,
+        tx_signature: Option<String>,
+    },
+    Succeeded,
+}
+
+#[derive(Error, Debug, Clone, Serialize, Deserialize)]
+pub enum RpcBundleExecutionError {
+    #[error("The bank has hit the max allotted time for processing transactions")]
+    BankProcessingTimeLimitReached,
+
+    #[error("Error locking bundle because a transaction is malformed")]
+    BundleLockError,
+
+    #[error("Bundle execution timed out")]
+    BundleExecutionTimeout,
+
+    #[error("The bundle exceeds the cost model")]
+    ExceedsCostModel,
+
+    #[error("Invalid pre or post accounts")]
+    InvalidPreOrPostAccounts,
+
+    #[error("PoH record error: {0}")]
+    PohRecordError(String),
+
+    #[error("Tip payment error: {0}")]
+    TipError(String),
+
+    #[error("A transaction in the bundle failed to execute: [signature={0}, error={1}]")]
+    TransactionFailure(Signature, String),
+}
+
+impl From<BundleExecutionError> for RpcBundleExecutionError {
+    fn from(bundle_execution_error: BundleExecutionError) -> Self {
+        match bundle_execution_error {
+            BundleExecutionError::BankProcessingTimeLimitReached => {
+                Self::BankProcessingTimeLimitReached
+            }
+            BundleExecutionError::ExceedsCostModel => Self::ExceedsCostModel,
+            BundleExecutionError::TransactionFailure(load_and_execute_bundle_error) => {
+                match load_and_execute_bundle_error {
+                    LoadAndExecuteBundleError::ProcessingTimeExceeded(_) => {
+                        Self::BundleExecutionTimeout
+                    }
+                    LoadAndExecuteBundleError::LockError {
+                        signature,
+                        transaction_error,
+                    } => Self::TransactionFailure(signature, transaction_error.to_string()),
+                    LoadAndExecuteBundleError::TransactionError {
+                        signature,
+                        execution_result,
+                    } => match *execution_result {
+                        TransactionExecutionResult::Executed { details, .. } => {
+                            let err_msg = if let Err(e) = details.status {
+                                e.to_string()
+                            } else {
+                                "Unknown error".to_string()
+                            };
+                            Self::TransactionFailure(signature, err_msg)
+                        }
+                        TransactionExecutionResult::NotExecuted(e) => {
+                            Self::TransactionFailure(signature, e.to_string())
+                        }
+                    },
+                    LoadAndExecuteBundleError::InvalidPreOrPostAccounts => {
+                        Self::InvalidPreOrPostAccounts
+                    }
+                }
+            }
+            BundleExecutionError::LockError => Self::BundleLockError,
+            BundleExecutionError::PohRecordError(e) => Self::PohRecordError(e.to_string()),
+            BundleExecutionError::TipError(e) => Self::TipError(e.to_string()),
+        }
+    }
+}
+
+#[derive(Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
+pub struct RpcSimulateBundleResult {
+    pub summary: RpcBundleSimulationSummary,
+    pub transaction_results: Vec<RpcSimulateBundleTransactionResult>,
+}
+
+#[derive(Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
+pub struct RpcSimulateBundleTransactionResult {
+    pub err: Option<TransactionError>,
+    pub logs: Option<Vec<String>>,
+    pub pre_execution_accounts: Option<Vec<UiAccount>>,
+    pub post_execution_accounts: Option<Vec<UiAccount>>,
+    pub units_consumed: Option<u64>,
+    pub return_data: Option<UiTransactionReturnData>,
+}
+
+#[derive(Debug, Default, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RpcSimulateBundleConfig {
+    /// Gives the state of accounts pre/post transaction execution.
+    /// The length of each of these must be equal to the number transactions.   
+    pub pre_execution_accounts_configs: Vec<Option<RpcSimulateTransactionAccountsConfig>>,
+    pub post_execution_accounts_configs: Vec<Option<RpcSimulateTransactionAccountsConfig>>,
+
+    /// Specifies the encoding scheme of the contained transactions.
+    pub transaction_encoding: Option<UiTransactionEncoding>,
+
+    /// Specifies the bank to run simulation against.
+    pub simulation_bank: Option<SimulationSlotConfig>,
+
+    /// Opt to skip sig-verify for faster performance.
+    #[serde(default)]
+    pub skip_sig_verify: bool,
+
+    /// Replace recent blockhash to simulate old transactions without resigning.
+    #[serde(default)]
+    pub replace_recent_blockhash: bool,
+}
+
+#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
+#[serde(rename_all = "camelCase")]
+pub enum SimulationSlotConfig {
+    /// Simulate on top of bank with the provided commitment.
+    Commitment(CommitmentConfig),
+
+    /// Simulate on the provided slot's bank.
+    Slot(Slot),
+
+    /// Simulates on top of the RPC's highest slot's bank i.e. the working bank.
+    Tip,
+}
+
+impl Default for SimulationSlotConfig {
+    fn default() -> Self {
+        Self::Commitment(CommitmentConfig {
+            commitment: CommitmentLevel::Confirmed,
+        })
+    }
+}
+
+#[derive(Debug, Default, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RpcBundleRequest {
+    pub encoded_transactions: Vec<String>,
+}
diff --git a/rpc-client-api/src/lib.rs b/rpc-client-api/src/lib.rs
index b2484637766c..198442c2b7b3 100644
--- a/rpc-client-api/src/lib.rs
+++ b/rpc-client-api/src/lib.rs
@@ -1,5 +1,6 @@
 #![allow(clippy::arithmetic_side_effects)]
 
+pub mod bundles;
 pub mod client_error;
 pub mod config;
 pub mod custom_error;
diff --git a/rpc-client-api/src/request.rs b/rpc-client-api/src/request.rs
index fe032a858deb..5b0547c90e27 100644
--- a/rpc-client-api/src/request.rs
+++ b/rpc-client-api/src/request.rs
@@ -66,6 +66,7 @@ pub enum RpcRequest {
     RequestAirdrop,
     SendTransaction,
     SimulateTransaction,
+    SimulateBundle,
     SignVote,
 }
 
@@ -131,6 +132,7 @@ impl fmt::Display for RpcRequest {
             RpcRequest::RequestAirdrop => "requestAirdrop",
             RpcRequest::SendTransaction => "sendTransaction",
             RpcRequest::SimulateTransaction => "simulateTransaction",
+            RpcRequest::SimulateBundle => "simulateBundle",
             RpcRequest::SignVote => "signVote",
         };
 
diff --git a/rpc-client/src/nonblocking/rpc_client.rs b/rpc-client/src/nonblocking/rpc_client.rs
index 0ca5f76a49f8..153332b65ae5 100644
--- a/rpc-client/src/nonblocking/rpc_client.rs
+++ b/rpc-client/src/nonblocking/rpc_client.rs
@@ -28,6 +28,10 @@ use {
         UiAccount, UiAccountData, UiAccountEncoding,
     },
     solana_rpc_client_api::{
+        bundles::{
+            RpcBundleRequest, RpcSimulateBundleConfig, RpcSimulateBundleResult,
+            SimulationSlotConfig,
+        },
         client_error::{
             Error as ClientError, ErrorKind as ClientErrorKind, Result as ClientResult,
         },
@@ -37,6 +41,7 @@ use {
     },
     solana_sdk::{
         account::Account,
+        bundle::VersionedBundle,
         clock::{Epoch, Slot, UnixTimestamp, DEFAULT_MS_PER_SLOT},
         commitment_config::CommitmentConfig,
         epoch_info::EpochInfo,
@@ -44,7 +49,7 @@ use {
         hash::Hash,
         pubkey::Pubkey,
         signature::Signature,
-        transaction,
+        transaction::{self, VersionedTransaction},
     },
     solana_transaction_status::{
         EncodedConfirmedBlock, EncodedConfirmedTransactionWithStatusMeta, TransactionStatus,
@@ -885,6 +890,7 @@ impl RpcClient {
                     code,
                     message,
                     data,
+                    ..
                 }) = &err.kind
                 {
                     debug!("{} {}", code, message);
@@ -1312,6 +1318,54 @@ impl RpcClient {
         .await
     }
 
+    pub async fn simulate_bundle(
+        &self,
+        bundle: &VersionedBundle,
+    ) -> RpcResult<RpcSimulateBundleResult> {
+        self.simulate_bundle_with_config(
+            bundle,
+            RpcSimulateBundleConfig {
+                simulation_bank: Some(SimulationSlotConfig::Commitment(self.commitment())),
+                pre_execution_accounts_configs: vec![None; bundle.transactions.len()],
+                post_execution_accounts_configs: vec![None; bundle.transactions.len()],
+                ..RpcSimulateBundleConfig::default()
+            },
+        )
+        .await
+    }
+
+    pub async fn simulate_bundle_with_config(
+        &self,
+        bundle: &VersionedBundle,
+        config: RpcSimulateBundleConfig,
+    ) -> RpcResult<RpcSimulateBundleResult> {
+        let transaction_encoding = config
+            .transaction_encoding
+            .unwrap_or(UiTransactionEncoding::Base64);
+        let simulation_bank = Some(config.simulation_bank.unwrap_or_default());
+
+        let encoded_transactions = bundle
+            .transactions
+            .iter()
+            .map(|tx| serialize_and_encode::<VersionedTransaction>(tx, transaction_encoding))
+            .collect::<ClientResult<Vec<String>>>()?;
+        let rpc_bundle_request = RpcBundleRequest {
+            encoded_transactions,
+        };
+
+        let config = RpcSimulateBundleConfig {
+            transaction_encoding: Some(transaction_encoding),
+            simulation_bank,
+            ..config
+        };
+
+        self.send(
+            RpcRequest::SimulateBundle,
+            json!([rpc_bundle_request, config]),
+        )
+        .await
+    }
+
     /// Returns the highest slot information that the node has snapshots for.
     ///
     /// This will find the highest full snapshot slot, and the highest incremental snapshot slot
diff --git a/rpc-client/src/rpc_client.rs b/rpc-client/src/rpc_client.rs
index 32bd08cef49f..e4167d6330cf 100644
--- a/rpc-client/src/rpc_client.rs
+++ b/rpc-client/src/rpc_client.rs
@@ -24,6 +24,7 @@ use {
         UiAccount, UiAccountEncoding,
     },
     solana_rpc_client_api::{
+        bundles::{RpcSimulateBundleConfig, RpcSimulateBundleResult},
         client_error::{Error as ClientError, ErrorKind, Result as ClientResult},
         config::{RpcAccountInfoConfig, *},
         request::{RpcRequest, TokenAccountsFilter},
@@ -31,6 +32,7 @@ use {
     },
     solana_sdk::{
         account::{Account, ReadableAccount},
+        bundle::VersionedBundle,
         clock::{Epoch, Slot, UnixTimestamp},
         commitment_config::CommitmentConfig,
         epoch_info::EpochInfo,
@@ -1146,6 +1148,18 @@ impl RpcClient {
         )
     }
 
+    pub fn simulate_bundle(&self, bundle: &VersionedBundle) -> RpcResult<RpcSimulateBundleResult> {
+        self.invoke((self.rpc_client.as_ref()).simulate_bundle(bundle))
+    }
+
+    pub fn simulate_bundle_with_config(
+        &self,
+        bundle: &VersionedBundle,
+        config: RpcSimulateBundleConfig,
+    ) -> RpcResult<RpcSimulateBundleResult> {
+        self.invoke((self.rpc_client.as_ref()).simulate_bundle_with_config(bundle, config))
+    }
+
     /// Returns the highest slot information that the node has snapshots for.
     ///
     /// This will find the highest full snapshot slot, and the highest incremental snapshot slot
diff --git a/rpc-test/Cargo.toml b/rpc-test/Cargo.toml
index eb69e4c95d8c..ea8d766641e8 100644
--- a/rpc-test/Cargo.toml
+++ b/rpc-test/Cargo.toml
@@ -33,6 +33,7 @@ solana-transaction-status = { workspace = true }
 tokio = { workspace = true, features = ["full"] }
 
 [dev-dependencies]
+serial_test = { workspace = true }
 solana-logger = { workspace = true }
 
 [package.metadata.docs.rs]
diff --git a/rpc-test/tests/rpc.rs b/rpc-test/tests/rpc.rs
index 463e20468673..216f01d3288d 100644
--- a/rpc-test/tests/rpc.rs
+++ b/rpc-test/tests/rpc.rs
@@ -5,6 +5,7 @@ use {
     log::*,
     reqwest::{self, header::CONTENT_TYPE},
     serde_json::{json, Value},
+    serial_test::serial,
     solana_account_decoder::UiAccount,
     solana_client::{
         connection_cache::ConnectionCache,
@@ -286,6 +287,7 @@ fn test_rpc_slot_updates() {
 }
 
 #[test]
+#[serial] // helps test pass
 fn test_rpc_subscriptions() {
     solana_logger::setup();
 
diff --git a/rpc/Cargo.toml b/rpc/Cargo.toml
index 2a0c5c480da1..b9616c2fb0fd 100644
--- a/rpc/Cargo.toml
+++ b/rpc/Cargo.toml
@@ -31,6 +31,7 @@ serde_json = { workspace = true }
 soketto = { workspace = true }
 solana-account-decoder = { workspace = true }
 solana-accounts-db = { workspace = true }
+solana-bundle = { workspace = true }
 solana-client = { workspace = true }
 solana-entry = { workspace = true }
 solana-faucet = { workspace = true }
@@ -41,6 +42,7 @@ solana-measure = { workspace = true }
 solana-metrics = { workspace = true }
 solana-perf = { workspace = true }
 solana-poh = { workspace = true }
+solana-program-runtime = { workspace = true }
 solana-rayon-threadlimit = { workspace = true }
 solana-rpc-client-api = { workspace = true }
 solana-runtime = { workspace = true }
diff --git a/rpc/src/rpc.rs b/rpc/src/rpc.rs
index 1aedda8d0920..d173b78b244f 100644
--- a/rpc/src/rpc.rs
+++ b/rpc/src/rpc.rs
@@ -61,7 +61,7 @@ use {
     },
     solana_sdk::{
         account::{AccountSharedData, ReadableAccount},
-        clock::{Slot, UnixTimestamp, MAX_PROCESSING_AGE},
+        clock::{Slot, UnixTimestamp},
         commitment_config::{CommitmentConfig, CommitmentLevel},
         epoch_info::EpochInfo,
         epoch_rewards_hasher::EpochRewardsHasher,
@@ -242,6 +242,13 @@ impl JsonRpcRequestProcessor {
         Ok(bank)
     }
 
+    fn bank_from_slot(&self, slot: Slot) -> Option<Arc<Bank>> {
+        debug!("Slot: {:?}", slot);
+
+        let r_bank_forks = self.bank_forks.read().unwrap();
+        r_bank_forks.get(slot)
+    }
+
     #[allow(deprecated)]
     fn bank(&self, commitment: Option<CommitmentConfig>) -> Arc<Bank> {
         debug!("RPC commitment_config: {:?}", commitment);
@@ -364,13 +371,10 @@ impl JsonRpcRequestProcessor {
             );
             ClusterInfo::new(contact_info, keypair, socket_addr_space)
         });
-        let tpu_address = cluster_info
-            .my_contact_info()
-            .tpu(connection_cache.protocol())
-            .unwrap();
+
         let (sender, receiver) = unbounded();
         SendTransactionService::new::<NullTpuInfo>(
-            tpu_address,
+            cluster_info.clone(),
             &bank_forks,
             None,
             receiver,
@@ -2693,13 +2697,16 @@ pub mod rpc_minimal {
                 })
                 .unwrap();
 
-            let full_snapshot_slot =
-                snapshot_utils::get_highest_full_snapshot_archive_slot(full_snapshot_archives_dir)
-                    .ok_or(RpcCustomError::NoSnapshot)?;
+            let full_snapshot_slot = snapshot_utils::get_highest_full_snapshot_archive_slot(
+                full_snapshot_archives_dir,
+                None,
+            )
+            .ok_or(RpcCustomError::NoSnapshot)?;
             let incremental_snapshot_slot =
                 snapshot_utils::get_highest_incremental_snapshot_archive_slot(
                     incremental_snapshot_archives_dir,
                     full_snapshot_slot,
+                    None,
                 );
 
             Ok(RpcSnapshotSlotInfo {
@@ -3284,14 +3291,169 @@ pub mod rpc_accounts_scan {
     }
 }
 
+pub mod utils {
+    use {
+        crate::rpc::encode_account,
+        jsonrpc_core::Error,
+        solana_account_decoder::{UiAccount, UiAccountEncoding},
+        solana_bundle::{
+            bundle_execution::{LoadAndExecuteBundleError, LoadAndExecuteBundleOutput},
+            BundleExecutionError,
+        },
+        solana_rpc_client_api::{
+            bundles::{
+                RpcBundleExecutionError, RpcBundleSimulationSummary, RpcSimulateBundleConfig,
+                RpcSimulateBundleResult, RpcSimulateBundleTransactionResult,
+            },
+            config::RpcSimulateTransactionAccountsConfig,
+        },
+        solana_sdk::{account::AccountSharedData, pubkey::Pubkey},
+        std::str::FromStr,
+    };
+
+    /// Encodes the accounts, returns an error if any of the accounts failed to encode
+    /// The outer error can be set by error parsing, Ok(None) means there wasn't any accounts in the parameter
+    fn try_encode_accounts(
+        accounts: &Option<Vec<(Pubkey, AccountSharedData)>>,
+        encoding: UiAccountEncoding,
+    ) -> Result<Option<Vec<UiAccount>>, Error> {
+        if let Some(accounts) = accounts {
+            Ok(Some(
+                accounts
+                    .iter()
+                    .map(|(pubkey, account)| encode_account(account, pubkey, encoding, None))
+                    .collect::<Result<Vec<UiAccount>, Error>>()?,
+            ))
+        } else {
+            Ok(None)
+        }
+    }
+
+    pub fn rpc_bundle_result_from_bank_result(
+        bundle_execution_result: LoadAndExecuteBundleOutput,
+        rpc_config: RpcSimulateBundleConfig,
+    ) -> Result<RpcSimulateBundleResult, Error> {
+        let summary = match bundle_execution_result.result() {
+            Ok(_) => RpcBundleSimulationSummary::Succeeded,
+            Err(e) => {
+                let tx_signature = match e {
+                    LoadAndExecuteBundleError::TransactionError { signature, .. }
+                    | LoadAndExecuteBundleError::LockError { signature, .. } => {
+                        Some(signature.to_string())
+                    }
+                    _ => None,
+                };
+                RpcBundleSimulationSummary::Failed {
+                    error: RpcBundleExecutionError::from(BundleExecutionError::TransactionFailure(
+                        e.clone(),
+                    )),
+                    tx_signature,
+                }
+            }
+        };
+
+        let mut transaction_results = Vec::new();
+        for bundle_output in bundle_execution_result.bundle_transaction_results() {
+            for (index, execution_result) in bundle_output
+                .execution_results()
+                .iter()
+                .enumerate()
+                .filter(|(_, result)| result.was_executed())
+            {
+                // things are filtered by was_executed, so safe to unwrap here
+                let result = execution_result.flattened_result();
+                let details = execution_result.details().unwrap();
+
+                let account_config = rpc_config
+                    .pre_execution_accounts_configs
+                    .get(transaction_results.len())
+                    .ok_or_else(|| Error::invalid_params("the length of pre_execution_accounts_configs must match the number of transactions"))?;
+                let account_encoding = account_config
+                    .as_ref()
+                    .and_then(|config| config.encoding)
+                    .unwrap_or(UiAccountEncoding::Base64);
+
+                let pre_execution_accounts = if let Some(pre_tx_accounts) =
+                    bundle_output.pre_tx_execution_accounts().get(index)
+                {
+                    try_encode_accounts(pre_tx_accounts, account_encoding)?
+                } else {
+                    None
+                };
+
+                let post_execution_accounts = if let Some(post_tx_accounts) =
+                    bundle_output.post_tx_execution_accounts().get(index)
+                {
+                    try_encode_accounts(post_tx_accounts, account_encoding)?
+                } else {
+                    None
+                };
+
+                transaction_results.push(RpcSimulateBundleTransactionResult {
+                    err: match result {
+                        Ok(_) => None,
+                        Err(e) => Some(e),
+                    },
+                    logs: details.log_messages.clone(),
+                    pre_execution_accounts,
+                    post_execution_accounts,
+                    units_consumed: Some(details.executed_units),
+                    return_data: details.return_data.clone().map(|data| data.into()),
+                });
+            }
+        }
+
+        Ok(RpcSimulateBundleResult {
+            summary,
+            transaction_results,
+        })
+    }
+
+    pub fn account_configs_to_accounts(
+        accounts_config: &[Option<RpcSimulateTransactionAccountsConfig>],
+    ) -> Result<Vec<Option<Vec<Pubkey>>>, Error> {
+        let mut execution_accounts = Vec::new();
+        for account_config in accounts_config {
+            let accounts = match account_config {
+                None => None,
+                Some(account_config) => Some(
+                    account_config
+                        .addresses
+                        .iter()
+                        .map(|a| {
+                            Pubkey::from_str(a).map_err(|_| {
+                                Error::invalid_params(format!("invalid pubkey provided: {}", a))
+                            })
+                        })
+                        .collect::<Result<Vec<Pubkey>, Error>>()?,
+                ),
+            };
+            execution_accounts.push(accounts);
+        }
+        Ok(execution_accounts)
+    }
+}
+
 // Full RPC interface that an API node is expected to provide
 // (rpc_minimal should also be provided by an API node)
 pub mod rpc_full {
     use {
         super::*,
-        solana_sdk::message::{SanitizedVersionedMessage, VersionedMessage},
+        crate::rpc::utils::{account_configs_to_accounts, rpc_bundle_result_from_bank_result},
+        jsonrpc_core::ErrorCode,
+        solana_bundle::bundle_execution::{load_and_execute_bundle, LoadAndExecuteBundleError},
+        solana_rpc_client_api::bundles::{
+            RpcBundleRequest, RpcSimulateBundleConfig, RpcSimulateBundleResult,
+            SimulationSlotConfig,
+        },
+        solana_sdk::{
+            bundle::{derive_bundle_id, SanitizedBundle},
+            clock::MAX_PROCESSING_AGE,
+            message::{SanitizedVersionedMessage, VersionedMessage},
+        },
         solana_transaction_status::UiInnerInstructions,
     };
+
     #[rpc]
     pub trait Full {
         type Metadata;
@@ -3353,6 +3515,14 @@ pub mod rpc_full {
             config: Option<RpcSimulateTransactionConfig>,
         ) -> Result<RpcResponse<RpcSimulateTransactionResult>>;
 
+        #[rpc(meta, name = "simulateBundle")]
+        fn simulate_bundle(
+            &self,
+            meta: Self::Metadata,
+            rpc_bundle_request: RpcBundleRequest,
+            config: Option<RpcSimulateBundleConfig>,
+        ) -> Result<RpcResponse<RpcSimulateBundleResult>>;
+
         #[rpc(meta, name = "minimumLedgerSlot")]
         fn minimum_ledger_slot(&self, meta: Self::Metadata) -> Result<Slot>;
 
@@ -3897,6 +4067,145 @@ pub mod rpc_full {
             ))
         }
 
+        // TODO (LB): probably want to add a max transaction size and max account return size and max
+        // allowable simulation time
+        fn simulate_bundle(
+            &self,
+            meta: Self::Metadata,
+            rpc_bundle_request: RpcBundleRequest,
+            config: Option<RpcSimulateBundleConfig>,
+        ) -> Result<RpcResponse<RpcSimulateBundleResult>> {
+            const MAX_BUNDLE_SIMULATION_TIME: Duration = Duration::from_millis(500);
+
+            debug!("simulate_bundle rpc request received");
+
+            let config = config.unwrap_or_else(|| RpcSimulateBundleConfig {
+                pre_execution_accounts_configs: vec![
+                    None;
+                    rpc_bundle_request.encoded_transactions.len()
+                ],
+                post_execution_accounts_configs: vec![
+                    None;
+                    rpc_bundle_request.encoded_transactions.len()
+                ],
+                ..RpcSimulateBundleConfig::default()
+            });
+
+            // Run some request validations
+            if !(config.pre_execution_accounts_configs.len()
+                == rpc_bundle_request.encoded_transactions.len()
+                && config.post_execution_accounts_configs.len()
+                    == rpc_bundle_request.encoded_transactions.len())
+            {
+                return Err(Error::invalid_params(
+                    "pre/post_execution_accounts_configs must be equal in length to the number of transactions",
+                ));
+            }
+
+            let bank = match config.simulation_bank.unwrap_or_default() {
+                SimulationSlotConfig::Commitment(commitment) => Ok(meta.bank(Some(commitment))),
+                SimulationSlotConfig::Slot(slot) => meta.bank_from_slot(slot).ok_or_else(|| {
+                    Error::invalid_params(format!("bank not found for the provided slot: {}", slot))
+                }),
+                SimulationSlotConfig::Tip => Ok(meta.bank_forks.read().unwrap().working_bank()),
+            }?;
+
+            let tx_encoding = config
+                .transaction_encoding
+                .unwrap_or(UiTransactionEncoding::Base64);
+            let binary_encoding = tx_encoding.into_binary_encoding().ok_or_else(|| {
+                Error::invalid_params(format!(
+                    "Unsupported encoding: {}. Supported encodings are: base58 & base64",
+                    tx_encoding
+                ))
+            })?;
+            let mut decoded_transactions = rpc_bundle_request
+                .encoded_transactions
+                .into_iter()
+                .map(|encoded_tx| {
+                    decode_and_deserialize::<VersionedTransaction>(encoded_tx, binary_encoding)
+                        .map(|de| de.1)
+                })
+                .collect::<Result<Vec<VersionedTransaction>>>()?;
+
+            if config.replace_recent_blockhash {
+                if !config.skip_sig_verify {
+                    return Err(Error::invalid_params(
+                        "sigVerify may not be used with replaceRecentBlockhash",
+                    ));
+                }
+                decoded_transactions.iter_mut().for_each(|tx| {
+                    tx.message.set_recent_blockhash(bank.last_blockhash());
+                });
+            }
+
+            let bundle_id = derive_bundle_id(&decoded_transactions);
+            let sanitized_bundle = SanitizedBundle {
+                transactions: decoded_transactions
+                    .into_iter()
+                    .map(|tx| {
+                        sanitize_transaction(tx, bank.as_ref(), bank.get_reserved_account_keys())
+                    })
+                    .collect::<Result<Vec<SanitizedTransaction>>>()?,
+                bundle_id,
+            };
+
+            if !config.skip_sig_verify {
+                for tx in &sanitized_bundle.transactions {
+                    verify_transaction(tx, &bank.feature_set)?;
+                }
+            }
+
+            let pre_execution_accounts =
+                account_configs_to_accounts(&config.pre_execution_accounts_configs)?;
+            let post_execution_accounts =
+                account_configs_to_accounts(&config.post_execution_accounts_configs)?;
+
+            let bundle_execution_result = load_and_execute_bundle(
+                &bank,
+                &sanitized_bundle,
+                MAX_PROCESSING_AGE,
+                &MAX_BUNDLE_SIMULATION_TIME,
+                true,
+                &None,
+                true,
+                None,
+                &pre_execution_accounts,
+                &post_execution_accounts,
+            );
+
+            // only return error if irrecoverable (timeout or tx malformed)
+            // bundle execution failures w/ context are returned to client
+            match bundle_execution_result.result() {
+                Ok(()) | Err(LoadAndExecuteBundleError::TransactionError { .. }) => {}
+                Err(LoadAndExecuteBundleError::ProcessingTimeExceeded(elapsed)) => {
+                    let mut error = Error::new(ErrorCode::ServerError(10_000));
+                    error.message = format!(
+                        "simulation time exceeded max allowed time: {:?}ms",
+                        elapsed.as_millis()
+                    );
+                    return Err(error);
+                }
+                Err(LoadAndExecuteBundleError::InvalidPreOrPostAccounts) => {
+                    return Err(Error::invalid_params("invalid pre or post account data"));
+                }
+                Err(LoadAndExecuteBundleError::LockError {
+                    signature,
+                    transaction_error,
+                }) => {
+                    return Err(Error::invalid_params(format!(
+                        "error locking transaction with signature: {}, error: {:?}",
+                        signature, transaction_error
+                    )));
+                }
+            }
+
+            let rpc_bundle_result =
+                rpc_bundle_result_from_bank_result(bundle_execution_result, config)?;
+
+            Ok(new_response(&bank, rpc_bundle_result))
+        }
+
         fn minimum_ledger_slot(&self, meta: Self::Metadata) -> Result<Slot> {
             debug!("minimum_ledger_slot rpc request received");
             meta.minimum_ledger_slot()
@@ -4319,6 +4628,7 @@ pub mod tests {
             },
             rpc_subscriptions::RpcSubscriptions,
         },
+        base64::engine::general_purpose,
         bincode::deserialize,
         jsonrpc_core::{futures, ErrorCode, MetaIoHandler, Output, Response, Value},
         jsonrpc_core_client::transports::local,
@@ -5628,6 +5938,146 @@ pub mod tests {
         assert_eq!(result.len(), 0);
     }
 
+    #[test]
+    fn test_rpc_simulate_bundle_happy_path() {
+        // 1. setup
+        let rpc = RpcHandler::start();
+        let bank = rpc.working_bank();
+
+        let recent_blockhash = bank.confirmed_last_blockhash();
+        let RpcHandler {
+            ref meta, ref io, ..
+        } = rpc;
+
+        let data_len = 100;
+        let lamports = bank.get_minimum_balance_for_rent_exemption(data_len);
+        let leader_pubkey = solana_sdk::pubkey::new_rand();
+        let leader_account_data = AccountSharedData::new(lamports, data_len, &system_program::id());
+        bank.store_account(&leader_pubkey, &leader_account_data);
+        bank.freeze();
+
+        // 2. build bundle
+
+        // let's pretend the RPC keypair is a searcher
+        let searcher_keypair = rpc.mint_keypair;
+
+        // create tip tx
+        let tip_amount = 10000;
+        let tip_tx = VersionedTransaction::from(system_transaction::transfer(
+            &searcher_keypair,
+            &leader_pubkey,
+            tip_amount,
+            recent_blockhash,
+        ));
+
+        // some random mev tx
+        let mev_amount = 20000;
+        let goku_pubkey = solana_sdk::pubkey::new_rand();
+        let mev_tx = VersionedTransaction::from(system_transaction::transfer(
+            &searcher_keypair,
+            &goku_pubkey,
+            mev_amount,
+            recent_blockhash,
+        ));
+
+        let encoded_mev_tx = general_purpose::STANDARD.encode(serialize(&mev_tx).unwrap());
+        let encoded_tip_tx = general_purpose::STANDARD.encode(serialize(&tip_tx).unwrap());
+        let b64_data = general_purpose::STANDARD.encode(leader_account_data.data());
+
+        // 3. test and assert
+        let skip_sig_verify = true;
+        let replace_recent_blockhash = false;
+        let expected_response = json!({
+            "jsonrpc": "2.0",
+            "result": {
+                "context": {"slot": bank.slot(), "apiVersion": RpcApiVersion::default()},
+                "value":{
+                    "summary": "succeeded",
+                    "transactionResults": [
+                        {
+                            "err": null,
+                            "logs": ["Program 11111111111111111111111111111111 invoke [1]", "Program 11111111111111111111111111111111 success"],
+                            "returnData": null,
+                            "unitsConsumed": 150,
+                            "postExecutionAccounts": [],
+                            "preExecutionAccounts": [
+                                {
+                                    "data": [b64_data, "base64"],
+                                    "executable": false,
+                                    "lamports": leader_account_data.lamports(),
+                                    "owner": "11111111111111111111111111111111",
+                                    "rentEpoch": 0,
+                                    "space": 100
+                                }
+                            ],
+                        },
+                        {
+                            "err": null,
+                            "logs": ["Program 11111111111111111111111111111111 invoke [1]", "Program 11111111111111111111111111111111 success"],
+                            "returnData": null,
+                            "unitsConsumed": 150,
+                            "preExecutionAccounts": [],
+                            "postExecutionAccounts": [
+                                {
+                                    "data": [b64_data, "base64"],
+                                    "executable": false,
+                                    "lamports": leader_account_data.lamports() + tip_amount,
+                                    "owner": "11111111111111111111111111111111",
+                                    "rentEpoch": u64::MAX,
+                                    "space": 100
+                                }
+                            ],
+                        },
+                    ],
+                }
+            },
+            "id": 1,
+        });
+
+        let request = format!(
+            r#"{{"jsonrpc":"2.0",
+                 "id":1,
+                 "method":"simulateBundle",
+                 "params":[
+                   {{
+                     "encodedTransactions": ["{}", "{}"]
+                   }},
+                   {{
+                     "skipSigVerify": {},
+                     "replaceRecentBlockhash": {},
+                     "slot": {},
+                     "preExecutionAccountsConfigs": [
+                        {{ "encoding": "base64", "addresses": ["{}"] }},
+                        {{ "encoding": "base64", "addresses": [] }}
+                     ],
+                     "postExecutionAccountsConfigs": [
+                        {{ "encoding": "base64", "addresses": [] }},
+                        {{ "encoding": "base64", "addresses": ["{}"] }}
+                     ]
+                   }}
+                ]
+            }}"#,
+            encoded_mev_tx,
+            encoded_tip_tx,
+            skip_sig_verify,
+            replace_recent_blockhash,
+            bank.slot(),
+            leader_pubkey,
+            leader_pubkey,
+        );
+
+        let actual_response = io
+            .handle_request_sync(&request, meta.clone())
+            .expect("response");
+
+        let expected_response = serde_json::from_value::<Response>(expected_response)
+            .expect("expected_response deserialization");
+        let actual_response = serde_json::from_str::<Response>(&actual_response)
+            .expect("actual_response deserialization");
+
+        assert_eq!(expected_response, actual_response);
+    }
+
     #[test]
     fn test_rpc_simulate_transaction() {
         let rpc = RpcHandler::start();
@@ -6446,10 +6896,7 @@ pub mod tests {
             ClusterInfo::new(contact_info, keypair, SocketAddrSpace::Unspecified)
         });
         let connection_cache = Arc::new(ConnectionCache::new("connection_cache_test"));
-        let tpu_address = cluster_info
-            .my_contact_info()
-            .tpu(connection_cache.protocol())
-            .unwrap();
+
         let (meta, receiver) = JsonRpcRequestProcessor::new(
             JsonRpcConfig::default(),
             None,
@@ -6458,7 +6905,7 @@ pub mod tests {
             blockstore,
             validator_exit,
             health.clone(),
-            cluster_info,
+            cluster_info.clone(),
             Hash::default(),
             None,
             optimistically_confirmed_bank,
@@ -6470,7 +6917,7 @@ pub mod tests {
             Arc::new(PrioritizationFeeCache::default()),
         );
         SendTransactionService::new::<NullTpuInfo>(
-            tpu_address,
+            cluster_info,
             &bank_forks,
             None,
             receiver,
@@ -6718,12 +7165,10 @@ pub mod tests {
 
         let cluster_info = Arc::new(new_test_cluster_info());
         let connection_cache = Arc::new(ConnectionCache::new("connection_cache_test"));
-        let tpu_address = cluster_info
-            .my_contact_info()
-            .tpu(connection_cache.protocol())
-            .unwrap();
+
         let optimistically_confirmed_bank =
             OptimisticallyConfirmedBank::locked_from_bank_forks_root(&bank_forks);
+
         let (request_processor, receiver) = JsonRpcRequestProcessor::new(
             JsonRpcConfig::default(),
             None,
@@ -6732,7 +7177,7 @@ pub mod tests {
             blockstore.clone(),
             validator_exit,
             RpcHealth::stub(optimistically_confirmed_bank.clone(), blockstore),
-            cluster_info,
+            cluster_info.clone(),
             Hash::default(),
             None,
             optimistically_confirmed_bank,
@@ -6744,7 +7189,7 @@ pub mod tests {
             Arc::new(PrioritizationFeeCache::default()),
         );
         SendTransactionService::new::<NullTpuInfo>(
-            tpu_address,
+            cluster_info,
             &bank_forks,
             None,
             receiver,
diff --git a/rpc/src/rpc_service.rs b/rpc/src/rpc_service.rs
index fed748d70947..dc4353ddca76 100644
--- a/rpc/src/rpc_service.rs
+++ b/rpc/src/rpc_service.rs
@@ -251,6 +251,7 @@ impl RequestMiddleware for RpcRequestMiddleware {
                 let full_snapshot_archive_info =
                     snapshot_utils::get_highest_full_snapshot_archive_info(
                         &snapshot_config.full_snapshot_archives_dir,
+                        None,
                     );
                 let snapshot_archive_info =
                     if let Some(full_snapshot_archive_info) = full_snapshot_archive_info {
@@ -260,6 +261,7 @@ impl RequestMiddleware for RpcRequestMiddleware {
                             snapshot_utils::get_highest_incremental_snapshot_archive_info(
                                 &snapshot_config.incremental_snapshot_archives_dir,
                                 full_snapshot_archive_info.slot(),
+                                None,
                             )
                             .map(|incremental_snapshot_archive_info| {
                                 incremental_snapshot_archive_info
@@ -373,11 +375,6 @@ impl JsonRpcService {
             LARGEST_ACCOUNTS_CACHE_DURATION,
         )));
 
-        let tpu_address = cluster_info
-            .my_contact_info()
-            .tpu(connection_cache.protocol())
-            .map_err(|err| format!("{err}"))?;
-
         // sadly, some parts of our current rpc implemention block the jsonrpc's
         // _socket-listening_ event loop for too long, due to (blocking) long IO or intesive CPU,
         // causing no further processing of incoming requests and ultimatily innocent clients timing-out.
@@ -475,7 +472,7 @@ impl JsonRpcService {
         let leader_info =
             poh_recorder.map(|recorder| ClusterTpuInfo::new(cluster_info.clone(), recorder));
         let _send_transaction_service = Arc::new(SendTransactionService::new_with_config(
-            tpu_address,
+            cluster_info,
             &bank_forks,
             leader_info,
             receiver,
diff --git a/runtime-plugin/Cargo.toml b/runtime-plugin/Cargo.toml
new file mode 100644
index 000000000000..2a526dc52e0a
--- /dev/null
+++ b/runtime-plugin/Cargo.toml
@@ -0,0 +1,22 @@
+[package]
+name = "solana-runtime-plugin"
+version = { workspace = true }
+authors = { workspace = true }
+repository = { workspace = true }
+homepage = { workspace = true }
+license = { workspace = true }
+edition = { workspace = true }
+
+[dependencies]
+crossbeam-channel = { workspace = true }
+json5 = { workspace = true }
+jsonrpc-core = { workspace = true }
+jsonrpc-core-client = { workspace = true, features = ["ipc"] }
+jsonrpc-derive = { workspace = true }
+jsonrpc-ipc-server = { workspace = true }
+jsonrpc-server-utils = { workspace = true }
+libloading = { workspace = true }
+log = { workspace = true }
+solana-runtime = { workspace = true }
+solana-sdk = { workspace = true }
+thiserror = { workspace = true }
diff --git a/runtime-plugin/src/lib.rs b/runtime-plugin/src/lib.rs
new file mode 100644
index 000000000000..477af43c9bdc
--- /dev/null
+++ b/runtime-plugin/src/lib.rs
@@ -0,0 +1,4 @@
+pub mod runtime_plugin;
+pub mod runtime_plugin_admin_rpc_service;
+pub mod runtime_plugin_manager;
+pub mod runtime_plugin_service;
diff --git a/runtime-plugin/src/runtime_plugin.rs b/runtime-plugin/src/runtime_plugin.rs
new file mode 100644
index 000000000000..7dc0b95fa4d4
--- /dev/null
+++ b/runtime-plugin/src/runtime_plugin.rs
@@ -0,0 +1,41 @@
+use {
+    solana_runtime::{bank_forks::BankForks, commitment::BlockCommitmentCache},
+    std::{
+        any::Any,
+        error,
+        fmt::Debug,
+        io,
+        sync::{atomic::AtomicBool, Arc, RwLock},
+    },
+    thiserror::Error,
+};
+
+pub type Result<T> = std::result::Result<T, RuntimePluginError>;
+
+/// Errors returned by plugin calls
+#[derive(Error, Debug)]
+pub enum RuntimePluginError {
+    /// Error opening the configuration file; for example, when the file
+    /// is not found or when the validator process has no permission to read it.
+    #[error("Error opening config file. Error detail: ({0}).")]
+    ConfigFileOpenError(#[from] io::Error),
+
+    /// Any custom error defined by the plugin.
+    #[error("Plugin-defined custom error. Error message: ({0})")]
+    Custom(Box<dyn error::Error + Send + Sync>),
+
+    #[error("Failed to load a runtime plugin")]
+    FailedToLoadPlugin(#[from] Box<dyn std::error::Error>),
+}
+
+pub struct PluginDependencies {
+    pub bank_forks: Arc<RwLock<BankForks>>,
+    pub block_commitment_cache: Arc<RwLock<BlockCommitmentCache>>,
+    pub exit: Arc<AtomicBool>,
+}
+
+pub trait RuntimePlugin: Any + Debug + Send + Sync {
+    fn name(&self) -> &'static str;
+    fn on_load(&mut self, config_file: &str, dependencies: PluginDependencies) -> Result<()>;
+    fn on_unload(&mut self);
+}
diff --git a/runtime-plugin/src/runtime_plugin_admin_rpc_service.rs b/runtime-plugin/src/runtime_plugin_admin_rpc_service.rs
new file mode 100644
index 000000000000..fdc33b06c506
--- /dev/null
+++ b/runtime-plugin/src/runtime_plugin_admin_rpc_service.rs
@@ -0,0 +1,326 @@
+//! RPC interface to dynamically make changes to runtime plugins.
+
+use {
+    crossbeam_channel::Sender,
+    jsonrpc_core::{BoxFuture, ErrorCode, MetaIoHandler, Metadata, Result as JsonRpcResult},
+    jsonrpc_core_client::{transports::ipc, RpcError},
+    jsonrpc_derive::rpc,
+    jsonrpc_ipc_server::{
+        tokio::{self, sync::oneshot::channel as oneshot_channel},
+        RequestContext, ServerBuilder,
+    },
+    jsonrpc_server_utils::tokio::sync::oneshot::Sender as OneShotSender,
+    log::*,
+    solana_sdk::exit::Exit,
+    std::{
+        path::{Path, PathBuf},
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc, RwLock,
+        },
+    },
+};
+
+#[derive(Debug)]
+pub enum RuntimePluginManagerRpcRequest {
+    ReloadPlugin {
+        name: String,
+        config_file: String,
+        response_sender: OneShotSender<JsonRpcResult<()>>,
+    },
+    UnloadPlugin {
+        name: String,
+        response_sender: OneShotSender<JsonRpcResult<()>>,
+    },
+    LoadPlugin {
+        config_file: String,
+        response_sender: OneShotSender<JsonRpcResult<String>>,
+    },
+    ListPlugins {
+        response_sender: OneShotSender<JsonRpcResult<Vec<String>>>,
+    },
+}
+
+#[rpc]
+pub trait RuntimePluginAdminRpc {
+    type Metadata;
+
+    #[rpc(meta, name = "reloadPlugin")]
+    fn reload_plugin(
+        &self,
+        meta: Self::Metadata,
+        name: String,
+        config_file: String,
+    ) -> BoxFuture<JsonRpcResult<()>>;
+
+    #[rpc(meta, name = "unloadPlugin")]
+    fn unload_plugin(&self, meta: Self::Metadata, name: String) -> BoxFuture<JsonRpcResult<()>>;
+
+    #[rpc(meta, name = "loadPlugin")]
+    fn load_plugin(
+        &self,
+        meta: Self::Metadata,
+        config_file: String,
+    ) -> BoxFuture<JsonRpcResult<String>>;
+
+    #[rpc(meta, name = "listPlugins")]
+    fn list_plugins(&self, meta: Self::Metadata) -> BoxFuture<JsonRpcResult<Vec<String>>>;
+}
+
+#[derive(Clone)]
+pub struct RuntimePluginAdminRpcRequestMetadata {
+    pub rpc_request_sender: Sender<RuntimePluginManagerRpcRequest>,
+    pub validator_exit: Arc<RwLock<Exit>>,
+}
+
+impl Metadata for RuntimePluginAdminRpcRequestMetadata {}
+
+fn rpc_path(ledger_path: &Path) -> PathBuf {
+    #[cfg(target_family = "windows")]
+    {
+        // More information about the wackiness of pipe names over at
+        // https://docs.microsoft.com/en-us/windows/win32/ipc/pipe-names
+        if let Some(ledger_filename) = ledger_path.file_name() {
+            PathBuf::from(format!(
+                "\\\\.\\pipe\\{}-runtime_plugin_admin.rpc",
+                ledger_filename.to_string_lossy()
+            ))
+        } else {
+            PathBuf::from("\\\\.\\pipe\\runtime_plugin_admin.rpc")
+        }
+    }
+    #[cfg(not(target_family = "windows"))]
+    {
+        ledger_path.join("runtime_plugin_admin.rpc")
+    }
+}
+
+/// Start the Runtime Plugin Admin RPC interface.
+pub fn run(
+    ledger_path: &Path,
+    metadata: RuntimePluginAdminRpcRequestMetadata,
+    plugin_exit: Arc<AtomicBool>,
+) {
+    let rpc_path = rpc_path(ledger_path);
+
+    let event_loop = tokio::runtime::Builder::new_multi_thread()
+        .thread_name("solRuntimePluginAdminRpc")
+        .worker_threads(1)
+        .enable_all()
+        .build()
+        .unwrap();
+
+    std::thread::Builder::new()
+        .name("solAdminRpc".to_string())
+        .spawn(move || {
+            let mut io = MetaIoHandler::default();
+            io.extend_with(RuntimePluginAdminRpcImpl.to_delegate());
+
+            let validator_exit = metadata.validator_exit.clone();
+
+            match ServerBuilder::with_meta_extractor(io, move |_req: &RequestContext| {
+                metadata.clone()
+            })
+            .event_loop_executor(event_loop.handle().clone())
+            .start(&format!("{}", rpc_path.display()))
+            {
+                Err(e) => {
+                    error!("Unable to start runtime plugin admin rpc service: {e:?}, exiting");
+                    validator_exit.write().unwrap().exit();
+                }
+                Ok(server) => {
+                    info!("started runtime plugin admin rpc service!");
+                    let close_handle = server.close_handle();
+                    let c_plugin_exit = plugin_exit.clone();
+                    validator_exit
+                        .write()
+                        .unwrap()
+                        .register_exit(Box::new(move || {
+                            close_handle.close();
+                            c_plugin_exit.store(true, Ordering::Relaxed);
+                        }));
+
+                    server.wait();
+                    plugin_exit.store(true, Ordering::Relaxed);
+                }
+            }
+        })
+        .unwrap();
+}
+
+pub struct RuntimePluginAdminRpcImpl;
+impl RuntimePluginAdminRpc for RuntimePluginAdminRpcImpl {
+    type Metadata = RuntimePluginAdminRpcRequestMetadata;
+
+    fn reload_plugin(
+        &self,
+        meta: Self::Metadata,
+        name: String,
+        config_file: String,
+    ) -> BoxFuture<JsonRpcResult<()>> {
+        Box::pin(async move {
+            let (response_sender, response_receiver) = oneshot_channel();
+
+            if meta
+                .rpc_request_sender
+                .send(RuntimePluginManagerRpcRequest::ReloadPlugin {
+                    name,
+                    config_file,
+                    response_sender,
+                })
+                .is_err()
+            {
+                error!("rpc_request_sender channel closed, exiting");
+                meta.validator_exit.write().unwrap().exit();
+
+                return Err(jsonrpc_core::Error {
+                    code: ErrorCode::InternalError,
+                    message: "Internal channel disconnected while sending the request".to_string(),
+                    data: None,
+                });
+            }
+
+            match response_receiver.await {
+                Err(_) => {
+                    error!("response_receiver channel closed, exiting");
+                    meta.validator_exit.write().unwrap().exit();
+                    Err(jsonrpc_core::Error {
+                        code: ErrorCode::InternalError,
+                        message: "Internal channel disconnected while awaiting the response"
+                            .to_string(),
+                        data: None,
+                    })
+                }
+                Ok(resp) => resp,
+            }
+        })
+    }
+
+    fn unload_plugin(&self, meta: Self::Metadata, name: String) -> BoxFuture<JsonRpcResult<()>> {
+        Box::pin(async move {
+            let (response_sender, response_receiver) = oneshot_channel();
+
+            if meta
+                .rpc_request_sender
+                .send(RuntimePluginManagerRpcRequest::UnloadPlugin {
+                    name,
+                    response_sender,
+                })
+                .is_err()
+            {
+                error!("rpc_request_sender channel closed, exiting");
+                meta.validator_exit.write().unwrap().exit();
+
+                return Err(jsonrpc_core::Error {
+                    code: ErrorCode::InternalError,
+                    message: "Internal channel disconnected while sending the request".to_string(),
+                    data: None,
+                });
+            }
+
+            match response_receiver.await {
+                Err(_) => {
+                    error!("response_receiver channel closed, exiting");
+                    meta.validator_exit.write().unwrap().exit();
+                    Err(jsonrpc_core::Error {
+                        code: ErrorCode::InternalError,
+                        message: "Internal channel disconnected while awaiting the response"
+                            .to_string(),
+                        data: None,
+                    })
+                }
+                Ok(resp) => resp,
+            }
+        })
+    }
+
+    fn load_plugin(
+        &self,
+        meta: Self::Metadata,
+        config_file: String,
+    ) -> BoxFuture<JsonRpcResult<String>> {
+        Box::pin(async move {
+            let (response_sender, response_receiver) = oneshot_channel();
+
+            if meta
+                .rpc_request_sender
+                .send(RuntimePluginManagerRpcRequest::LoadPlugin {
+                    config_file,
+                    response_sender,
+                })
+                .is_err()
+            {
+                error!("rpc_request_sender channel closed, exiting");
+                meta.validator_exit.write().unwrap().exit();
+
+                return Err(jsonrpc_core::Error {
+                    code: ErrorCode::InternalError,
+                    message: "Internal channel disconnected while sending the request".to_string(),
+                    data: None,
+                });
+            }
+
+            match response_receiver.await {
+                Err(_) => {
+                    error!("response_receiver channel closed, exiting");
+                    meta.validator_exit.write().unwrap().exit();
+                    Err(jsonrpc_core::Error {
+                        code: ErrorCode::InternalError,
+                        message: "Internal channel disconnected while awaiting the response"
+                            .to_string(),
+                        data: None,
+                    })
+                }
+                Ok(resp) => resp,
+            }
+        })
+    }
+
+    fn list_plugins(&self, meta: Self::Metadata) -> BoxFuture<JsonRpcResult<Vec<String>>> {
+        Box::pin(async move {
+            let (response_sender, response_receiver) = oneshot_channel();
+
+            if meta
+                .rpc_request_sender
+                .send(RuntimePluginManagerRpcRequest::ListPlugins { response_sender })
+                .is_err()
+            {
+                error!("rpc_request_sender channel closed, exiting");
+                meta.validator_exit.write().unwrap().exit();
+
+                return Err(jsonrpc_core::Error {
+                    code: ErrorCode::InternalError,
+                    message: "Internal channel disconnected while sending the request".to_string(),
+                    data: None,
+                });
+            }
+
+            match response_receiver.await {
+                Err(_) => {
+                    error!("response_receiver channel closed, exiting");
+                    meta.validator_exit.write().unwrap().exit();
+                    Err(jsonrpc_core::Error {
+                        code: ErrorCode::InternalError,
+                        message: "Internal channel disconnected while awaiting the response"
+                            .to_string(),
+                        data: None,
+                    })
+                }
+                Ok(resp) => resp,
+            }
+        })
+    }
+}
+
+// Connect to the Runtime Plugin RPC interface
+pub async fn connect(ledger_path: &Path) -> Result<gen_client::Client, RpcError> {
+    let rpc_path = rpc_path(ledger_path);
+    if !rpc_path.exists() {
+        Err(RpcError::Client(format!(
+            "{} does not exist",
+            rpc_path.display()
+        )))
+    } else {
+        ipc::connect::<_, gen_client::Client>(&format!("{}", rpc_path.display())).await
+    }
+}
diff --git a/runtime-plugin/src/runtime_plugin_manager.rs b/runtime-plugin/src/runtime_plugin_manager.rs
new file mode 100644
index 000000000000..af1dcf2cde14
--- /dev/null
+++ b/runtime-plugin/src/runtime_plugin_manager.rs
@@ -0,0 +1,275 @@
+use {
+    crate::runtime_plugin::{PluginDependencies, RuntimePlugin},
+    jsonrpc_core::{serde_json, ErrorCode, Result as JsonRpcResult},
+    libloading::Library,
+    log::*,
+    solana_runtime::{bank_forks::BankForks, commitment::BlockCommitmentCache},
+    std::{
+        fs::File,
+        io::Read,
+        path::{Path, PathBuf},
+        sync::{atomic::AtomicBool, Arc, RwLock},
+    },
+};
+
+#[derive(thiserror::Error, Debug)]
+pub enum RuntimePluginManagerError {
+    #[error("Cannot open the the plugin config file")]
+    CannotOpenConfigFile(String),
+
+    #[error("Cannot read the the plugin config file")]
+    CannotReadConfigFile(String),
+
+    #[error("The config file is not in a valid Json format")]
+    InvalidConfigFileFormat(String),
+
+    #[error("Plugin library path is not specified in the config file")]
+    LibPathNotSet,
+
+    #[error("Invalid plugin path")]
+    InvalidPluginPath,
+
+    #[error("Cannot load plugin shared library")]
+    PluginLoadError(String),
+
+    #[error("The runtime plugin {0} is already loaded shared library")]
+    PluginAlreadyLoaded(String),
+
+    #[error("The RuntimePlugin on_load method failed")]
+    PluginStartError(String),
+}
+
+pub struct RuntimePluginManager {
+    plugins: Vec<Box<dyn RuntimePlugin>>,
+    libs: Vec<Library>,
+    bank_forks: Arc<RwLock<BankForks>>,
+    block_commitment_cache: Arc<RwLock<BlockCommitmentCache>>,
+    exit: Arc<AtomicBool>,
+}
+
+impl RuntimePluginManager {
+    pub fn new(
+        bank_forks: Arc<RwLock<BankForks>>,
+        block_commitment_cache: Arc<RwLock<BlockCommitmentCache>>,
+        exit: Arc<AtomicBool>,
+    ) -> Self {
+        Self {
+            plugins: vec![],
+            libs: vec![],
+            bank_forks,
+            block_commitment_cache,
+            exit,
+        }
+    }
+
+    /// This method allows dynamic loading of a runtime plugin.
+    /// Adds to the existing list of loaded plugins.
+    pub(crate) fn load_plugin(
+        &mut self,
+        plugin_config_path: impl AsRef<Path>,
+    ) -> JsonRpcResult<String /* plugin name */> {
+        // First load plugin
+        let (mut new_plugin, new_lib, config_file) =
+            load_plugin_from_config(plugin_config_path.as_ref()).map_err(|e| {
+                jsonrpc_core::Error {
+                    code: ErrorCode::InvalidRequest,
+                    message: format!("Failed to load plugin: {e}"),
+                    data: None,
+                }
+            })?;
+
+        // Then see if a plugin with this name already exists, if so return Err.
+        let name = new_plugin.name();
+        if self.plugins.iter().any(|plugin| name.eq(plugin.name())) {
+            return Err(jsonrpc_core::Error {
+                code: ErrorCode::InvalidRequest,
+                message: format!(
+                    "There already exists a plugin named {} loaded. Did not load requested plugin",
+                    name,
+                ),
+                data: None,
+            });
+        }
+
+        new_plugin
+            .on_load(
+                config_file,
+                PluginDependencies {
+                    bank_forks: self.bank_forks.clone(),
+                    block_commitment_cache: self.block_commitment_cache.clone(),
+                    exit: self.exit.clone(),
+                },
+            )
+            .map_err(|on_load_err| jsonrpc_core::Error {
+                code: ErrorCode::InvalidRequest,
+                message: format!(
+                    "on_load method of plugin {} failed: {on_load_err}",
+                    new_plugin.name()
+                ),
+                data: None,
+            })?;
+
+        self.plugins.push(new_plugin);
+        self.libs.push(new_lib);
+
+        Ok(name.to_string())
+    }
+
+    /// Unloads the plugins and loaded plugin libraries, making sure to fire
+    /// their `on_plugin_unload()` methods so they can do any necessary cleanup.
+    pub(crate) fn unload_all_plugins(&mut self) {
+        (0..self.plugins.len()).for_each(|idx| {
+            self.try_drop_plugin(idx);
+        });
+    }
+
+    pub(crate) fn unload_plugin(&mut self, name: &str) -> JsonRpcResult<()> {
+        // Check if any plugin names match this one
+        let Some(idx) = self
+            .plugins
+            .iter()
+            .position(|plugin| plugin.name().eq(name))
+        else {
+            // If we don't find one return an error
+            return Err(jsonrpc_core::error::Error {
+                code: ErrorCode::InvalidRequest,
+                message: String::from("The plugin you requested to unload is not loaded"),
+                data: None,
+            });
+        };
+
+        // Unload and drop plugin and lib
+        self.try_drop_plugin(idx);
+
+        Ok(())
+    }
+
+    /// Reloads an existing plugin.
+    pub(crate) fn reload_plugin(&mut self, name: &str, config_file: &str) -> JsonRpcResult<()> {
+        // Check if any plugin names match this one
+        let Some(idx) = self
+            .plugins
+            .iter()
+            .position(|plugin| plugin.name().eq(name))
+        else {
+            // If we don't find one return an error
+            return Err(jsonrpc_core::error::Error {
+                code: ErrorCode::InvalidRequest,
+                message: String::from("The plugin you requested to reload is not loaded"),
+                data: None,
+            });
+        };
+
+        self.try_drop_plugin(idx);
+
+        // Try to load plugin, library
+        // SAFETY: It is up to the validator to ensure this is a valid plugin library.
+        let (mut new_plugin, new_lib, new_parsed_config_file) =
+            load_plugin_from_config(config_file.as_ref()).map_err(|err| jsonrpc_core::Error {
+                code: ErrorCode::InvalidRequest,
+                message: err.to_string(),
+                data: None,
+            })?;
+
+        // Attempt to on_load with new plugin
+        match new_plugin.on_load(
+            new_parsed_config_file,
+            PluginDependencies {
+                bank_forks: self.bank_forks.clone(),
+                block_commitment_cache: self.block_commitment_cache.clone(),
+                exit: self.exit.clone(),
+            },
+        ) {
+            // On success, push plugin and library
+            Ok(()) => {
+                self.plugins.push(new_plugin);
+                self.libs.push(new_lib);
+                Ok(())
+            }
+            // On failure, return error
+            Err(err) => Err(jsonrpc_core::error::Error {
+                code: ErrorCode::InvalidRequest,
+                message: format!(
+                    "Failed to start new plugin (previous plugin was dropped!): {err}"
+                ),
+                data: None,
+            }),
+        }
+    }
+
+    pub(crate) fn list_plugins(&self) -> JsonRpcResult<Vec<String>> {
+        Ok(self.plugins.iter().map(|p| p.name().to_owned()).collect())
+    }
+
+    fn try_drop_plugin(&mut self, idx: usize) {
+        if idx < self.plugins.len() {
+            let mut plugin = self.plugins.remove(idx);
+            let lib = self.libs.remove(idx);
+            drop(lib);
+            plugin.on_unload();
+        } else {
+            error!("failed to drop plugin: index {idx} out of bounds");
+        }
+    }
+}
+
+fn load_plugin_from_config(
+    plugin_config_path: &Path,
+) -> Result<(Box<dyn RuntimePlugin>, Library, &str), RuntimePluginManagerError> {
+    type PluginConstructor = unsafe fn() -> *mut dyn RuntimePlugin;
+    use libloading::Symbol;
+
+    let mut file = match File::open(plugin_config_path) {
+        Ok(file) => file,
+        Err(err) => {
+            return Err(RuntimePluginManagerError::CannotOpenConfigFile(format!(
+                "Failed to open the plugin config file {plugin_config_path:?}, error: {err:?}"
+            )));
+        }
+    };
+
+    let mut contents = String::new();
+    if let Err(err) = file.read_to_string(&mut contents) {
+        return Err(RuntimePluginManagerError::CannotReadConfigFile(format!(
+            "Failed to read the plugin config file {plugin_config_path:?}, error: {err:?}"
+        )));
+    }
+
+    let result: serde_json::Value = match json5::from_str(&contents) {
+        Ok(value) => value,
+        Err(err) => {
+            return Err(RuntimePluginManagerError::InvalidConfigFileFormat(format!(
+                "The config file {plugin_config_path:?} is not in a valid Json5 format, error: {err:?}"
+            )));
+        }
+    };
+
+    let libpath = result["libpath"]
+        .as_str()
+        .ok_or(RuntimePluginManagerError::LibPathNotSet)?;
+    let mut libpath = PathBuf::from(libpath);
+    if libpath.is_relative() {
+        let config_dir = plugin_config_path.parent().ok_or_else(|| {
+            RuntimePluginManagerError::CannotOpenConfigFile(format!(
+                "Failed to resolve parent of {plugin_config_path:?}",
+            ))
+        })?;
+        libpath = config_dir.join(libpath);
+    }
+
+    let config_file = plugin_config_path
+        .as_os_str()
+        .to_str()
+        .ok_or(RuntimePluginManagerError::InvalidPluginPath)?;
+
+    let (plugin, lib) = unsafe {
+        let lib = Library::new(libpath)
+            .map_err(|e| RuntimePluginManagerError::PluginLoadError(e.to_string()))?;
+        let constructor: Symbol<PluginConstructor> = lib
+            .get(b"_create_plugin")
+            .map_err(|e| RuntimePluginManagerError::PluginLoadError(e.to_string()))?;
+        (Box::from_raw(constructor()), lib)
+    };
+
+    Ok((plugin, lib, config_file))
+}
diff --git a/runtime-plugin/src/runtime_plugin_service.rs b/runtime-plugin/src/runtime_plugin_service.rs
new file mode 100644
index 000000000000..5fcb625a26d7
--- /dev/null
+++ b/runtime-plugin/src/runtime_plugin_service.rs
@@ -0,0 +1,123 @@
+use {
+    crate::{
+        runtime_plugin::RuntimePluginError,
+        runtime_plugin_admin_rpc_service::RuntimePluginManagerRpcRequest,
+        runtime_plugin_manager::RuntimePluginManager,
+    },
+    crossbeam_channel::Receiver,
+    log::{error, info},
+    solana_runtime::{bank_forks::BankForks, commitment::BlockCommitmentCache},
+    std::{
+        path::PathBuf,
+        sync::{
+            atomic::{AtomicBool, Ordering},
+            Arc, RwLock,
+        },
+        thread::{self, JoinHandle},
+        time::Duration,
+    },
+};
+
+pub struct RuntimePluginService {
+    plugin_manager: Arc<RwLock<RuntimePluginManager>>,
+    rpc_thread: JoinHandle<()>,
+}
+
+impl RuntimePluginService {
+    pub fn start(
+        plugin_config_files: &[PathBuf],
+        rpc_receiver: Receiver<RuntimePluginManagerRpcRequest>,
+        bank_forks: Arc<RwLock<BankForks>>,
+        block_commitment_cache: Arc<RwLock<BlockCommitmentCache>>,
+        exit: Arc<AtomicBool>,
+    ) -> Result<Self, RuntimePluginError> {
+        let mut plugin_manager =
+            RuntimePluginManager::new(bank_forks, block_commitment_cache, exit.clone());
+
+        for config in plugin_config_files {
+            let name = plugin_manager
+                .load_plugin(config)
+                .map_err(|e| RuntimePluginError::FailedToLoadPlugin(e.into()))?;
+            info!("Loaded Runtime Plugin: {name}");
+        }
+
+        let plugin_manager = Arc::new(RwLock::new(plugin_manager));
+        let rpc_thread =
+            Self::start_rpc_request_handler(rpc_receiver, plugin_manager.clone(), exit);
+
+        Ok(Self {
+            plugin_manager,
+            rpc_thread,
+        })
+    }
+
+    pub fn join(self) {
+        if let Err(e) = self.rpc_thread.join() {
+            error!("error joining rpc thread: {e:?}");
+        }
+        self.plugin_manager.write().unwrap().unload_all_plugins();
+    }
+
+    fn start_rpc_request_handler(
+        rpc_receiver: Receiver<RuntimePluginManagerRpcRequest>,
+        plugin_manager: Arc<RwLock<RuntimePluginManager>>,
+        exit: Arc<AtomicBool>,
+    ) -> JoinHandle<()> {
+        thread::Builder::new()
+            .name("solRuntimePluginRpc".to_string())
+            .spawn(move || {
+                const TIMEOUT: Duration = Duration::from_secs(3);
+                while !exit.load(Ordering::Relaxed) {
+                    if let Ok(request) = rpc_receiver.recv_timeout(TIMEOUT) {
+                        match request {
+                            RuntimePluginManagerRpcRequest::ListPlugins { response_sender } => {
+                                let plugin_list = plugin_manager.read().unwrap().list_plugins();
+                                if response_sender.send(plugin_list).is_err() {
+                                    error!("response_sender channel disconnected");
+                                    return;
+                                }
+                            }
+                            RuntimePluginManagerRpcRequest::ReloadPlugin {
+                                ref name,
+                                ref config_file,
+                                response_sender,
+                            } => {
+                                let reload_result = plugin_manager
+                                    .write()
+                                    .unwrap()
+                                    .reload_plugin(name, config_file);
+                                if response_sender.send(reload_result).is_err() {
+                                    error!("response_sender channel disconnected");
+                                    return;
+                                }
+                            }
+                            RuntimePluginManagerRpcRequest::LoadPlugin {
+                                ref config_file,
+                                response_sender,
+                            } => {
+                                let load_result =
+                                    plugin_manager.write().unwrap().load_plugin(config_file);
+                                if response_sender.send(load_result).is_err() {
+                                    error!("response_sender channel disconnected");
+                                    return;
+                                }
+                            }
+                            RuntimePluginManagerRpcRequest::UnloadPlugin {
+                                ref name,
+                                response_sender,
+                            } => {
+                                let unload_result =
+                                    plugin_manager.write().unwrap().unload_plugin(name);
+                                if response_sender.send(unload_result).is_err() {
+                                    error!("response_sender channel disconnected");
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+                plugin_manager.write().unwrap().unload_all_plugins();
+            })
+            .unwrap()
+    }
+}
diff --git a/runtime/src/bank.rs b/runtime/src/bank.rs
index 4efac319401a..ad763a128822 100644
--- a/runtime/src/bank.rs
+++ b/runtime/src/bank.rs
@@ -67,7 +67,7 @@ use {
     },
     serde::Serialize,
     solana_accounts_db::{
-        accounts::{AccountAddressFilter, Accounts, PubkeyAccountSlot},
+        accounts::{AccountAddressFilter, AccountLocks, Accounts, PubkeyAccountSlot},
         accounts_db::{
             AccountShrinkThreshold, AccountStorageEntry, AccountsDb, AccountsDbConfig,
             CalcAccountsHashDataSource, PubkeyHashAccount, VerifyAccountsHashAndLamportsConfig,
@@ -340,6 +340,7 @@ impl BankRc {
     }
 }
 
+#[derive(Debug)]
 pub struct LoadAndExecuteTransactionsOutput {
     pub loaded_transactions: Vec<TransactionLoadResult>,
     // Vector of results indicating whether a transaction was executed or could not
@@ -357,6 +358,22 @@ pub struct LoadAndExecuteTransactionsOutput {
     pub error_counters: TransactionErrorMetrics,
 }
 
+#[derive(Clone)]
+pub struct BundleTransactionSimulationResult {
+    pub result: Result<()>,
+    pub logs: TransactionLogMessages,
+    pub pre_execution_accounts: Option<Vec<AccountData>>,
+    pub post_execution_accounts: Option<Vec<AccountData>>,
+    pub return_data: Option<TransactionReturnData>,
+    pub units_consumed: u64,
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub struct AccountData {
+    pub pubkey: Pubkey,
+    pub data: AccountSharedData,
+}
+
 pub struct TransactionSimulationResult {
     pub result: Result<()>,
     pub logs: TransactionLogMessages,
@@ -812,7 +829,7 @@ pub struct Bank {
     inflation: Arc<RwLock<Inflation>>,
 
     /// cache of vote_account and stake_account state for this fork
-    stakes_cache: StakesCache,
+    pub stakes_cache: StakesCache,
 
     /// staked nodes on epoch boundaries, saved off when a bank.slot() is at
     ///   a leader schedule calculation boundary
@@ -3296,17 +3313,61 @@ impl Bank {
         &'a self,
         transactions: &'b [SanitizedTransaction],
         transaction_results: impl Iterator<Item = Result<()>>,
+        additional_read_locks: Option<&HashSet<Pubkey>>,
+        additional_write_locks: Option<&HashSet<Pubkey>>,
     ) -> TransactionBatch<'a, 'b> {
-        // this lock_results could be: Ok, AccountInUse, WouldExceedBlockMaxLimit or WouldExceedAccountMaxLimit
         let tx_account_lock_limit = self.get_transaction_account_lock_limit();
         let lock_results = self.rc.accounts.lock_accounts_with_results(
             transactions.iter(),
             transaction_results,
             tx_account_lock_limit,
+            additional_read_locks,
+            additional_write_locks,
         );
         TransactionBatch::new(lock_results, self, Cow::Borrowed(transactions))
     }
 
+    /// Prepare a locked transaction batch from a list of sanitized transactions, and their cost
+    /// limited packing status, where transactions will be locked sequentially until the first failure
+    pub fn prepare_sequential_sanitized_batch_with_results<'a, 'b>(
+        &'a self,
+        transactions: &'b [SanitizedTransaction],
+    ) -> TransactionBatch<'a, 'b> {
+        // this lock_results could be: Ok, AccountInUse, AccountLoadedTwice, or TooManyAccountLocks
+        let tx_account_lock_limit = self.get_transaction_account_lock_limit();
+        let lock_results = self
+            .rc
+            .accounts
+            .lock_accounts_sequential_with_results(transactions.iter(), tx_account_lock_limit);
+        TransactionBatch::new(lock_results, self, Cow::Borrowed(transactions))
+    }
+
+    /// Prepare a locked transaction batch from a list of sanitized transactions for simulation.
+    /// This grabs as many sequential account locks that it can without a RW conflict. However,
+    /// it uses a temporary version of AccountLocks and not the Bank's account locks, so one can
+    /// use this during simulation on an unfrozen Bank without worrying about impacting the RW
+    /// lock usage in replay
+    pub fn prepare_sequential_sanitized_batch_with_results_for_simulation<'a, 'b>(
+        &'a self,
+        transactions: &'b [SanitizedTransaction],
+    ) -> TransactionBatch<'a, 'b> {
+        let tx_account_lock_limit = self.get_transaction_account_lock_limit();
+        let tx_account_locks_results: Vec<Result<_>> = transactions
+            .iter()
+            .map(|tx| tx.get_account_locks(tx_account_lock_limit))
+            .collect();
+
+        let mut account_locks = AccountLocks::default();
+        let lock_results =
+            Accounts::lock_accounts_sequential(&mut account_locks, tx_account_locks_results);
+        let mut batch = TransactionBatch::new(lock_results, self, Cow::Borrowed(transactions));
+        // this is required to ensure that accounts aren't unlocked accidentally, which can be problematic during replay.
+        // more specifically, during process_entries, if the lock counts are accidentally decremented,
+        // one might end up replaying a block incorrectly
+        batch.set_needs_unlock(false);
+        batch
+    }
+
     /// Prepare a transaction batch from a single transaction without locking accounts
     pub fn prepare_unlocked_batch_from_single_tx<'a>(
         &'a self,
@@ -3428,7 +3489,11 @@ impl Bank {
         }
     }
 
-    fn get_account_overrides_for_simulation(&self, account_keys: &AccountKeys) -> AccountOverrides {
+    // NOTE: Do not revert this back to private during rebases.
+    pub fn get_account_overrides_for_simulation(
+        &self,
+        account_keys: &AccountKeys,
+    ) -> AccountOverrides {
         let mut account_overrides = AccountOverrides::default();
         let slot_history_id = sysvar::slot_history::id();
         if account_keys.iter().any(|pubkey| *pubkey == slot_history_id) {
@@ -3616,6 +3681,30 @@ impl Bank {
         balances
     }
 
+    pub fn collect_balances_with_cache(
+        &self,
+        batch: &TransactionBatch,
+        account_overrides: Option<&AccountOverrides>,
+    ) -> TransactionBalances {
+        let mut balances: TransactionBalances = vec![];
+        for transaction in batch.sanitized_transactions() {
+            let mut transaction_balances: Vec<u64> = vec![];
+            for account_key in transaction.message().account_keys().iter() {
+                let balance = match account_overrides {
+                    None => self.get_balance(account_key),
+                    Some(overrides) => match overrides.get(account_key) {
+                        None => self.get_balance(account_key),
+                        Some(account_data) => account_data.lamports(),
+                    },
+                };
+                transaction_balances.push(balance);
+            }
+            balances.push(transaction_balances);
+        }
+        balances
+    }
+
+    #[allow(clippy::too_many_arguments, clippy::type_complexity)]
     pub fn load_and_execute_transactions(
         &self,
         batch: &TransactionBatch,
diff --git a/runtime/src/snapshot_bank_utils.rs b/runtime/src/snapshot_bank_utils.rs
index 5b3f83f28a25..8e42d859a78b 100644
--- a/runtime/src/snapshot_bank_utils.rs
+++ b/runtime/src/snapshot_bank_utils.rs
@@ -87,13 +87,14 @@ pub fn bank_fields_from_snapshot_archives(
     storage_access: StorageAccess,
 ) -> snapshot_utils::Result<BankFieldsToDeserialize> {
     let full_snapshot_archive_info =
-        get_highest_full_snapshot_archive_info(&full_snapshot_archives_dir).ok_or_else(|| {
-            SnapshotError::NoSnapshotArchives(full_snapshot_archives_dir.as_ref().to_path_buf())
-        })?;
+        get_highest_full_snapshot_archive_info(&full_snapshot_archives_dir, None).ok_or_else(
+            || SnapshotError::NoSnapshotArchives(full_snapshot_archives_dir.as_ref().to_path_buf()),
+        )?;
 
     let incremental_snapshot_archive_info = get_highest_incremental_snapshot_archive_info(
         &incremental_snapshot_archives_dir,
         full_snapshot_archive_info.slot(),
+        None,
     );
 
     let temp_unpack_dir = TempDir::new()?;
@@ -298,13 +299,14 @@ pub fn bank_from_latest_snapshot_archives(
     Option<IncrementalSnapshotArchiveInfo>,
 )> {
     let full_snapshot_archive_info =
-        get_highest_full_snapshot_archive_info(&full_snapshot_archives_dir).ok_or_else(|| {
-            SnapshotError::NoSnapshotArchives(full_snapshot_archives_dir.as_ref().to_path_buf())
-        })?;
+        get_highest_full_snapshot_archive_info(&full_snapshot_archives_dir, None).ok_or_else(
+            || SnapshotError::NoSnapshotArchives(full_snapshot_archives_dir.as_ref().to_path_buf()),
+        )?;
 
     let incremental_snapshot_archive_info = get_highest_incremental_snapshot_archive_info(
         &incremental_snapshot_archives_dir,
         full_snapshot_archive_info.slot(),
+        None,
     );
 
     let (bank, _) = bank_from_snapshot_archives(
@@ -2550,7 +2552,7 @@ mod tests {
         fs::remove_file(full_snapshot_archive_info.unwrap().path()).unwrap();
 
         let highest_full_snapshot_archive =
-            get_highest_full_snapshot_archive_info(&snapshot_archives_dir).unwrap();
+            get_highest_full_snapshot_archive_info(&snapshot_archives_dir, None).unwrap();
         let highest_bank_snapshot_post =
             get_highest_bank_snapshot_post(&bank_snapshots_dir).unwrap();
         let highest_bank_snapshot_pre = get_highest_bank_snapshot_pre(&bank_snapshots_dir).unwrap();
diff --git a/runtime/src/snapshot_utils.rs b/runtime/src/snapshot_utils.rs
index 5d407eaf0ba7..7e0b55d9fd36 100644
--- a/runtime/src/snapshot_utils.rs
+++ b/runtime/src/snapshot_utils.rs
@@ -701,7 +701,7 @@ pub fn get_highest_loadable_bank_snapshot(
     // Otherwise, the bank snapshot's full snapshot slot *must* be the same as
     // the highest full snapshot archive's slot.
     let highest_full_snapshot_archive_slot =
-        get_highest_full_snapshot_archive_slot(&snapshot_config.full_snapshot_archives_dir)?;
+        get_highest_full_snapshot_archive_slot(&snapshot_config.full_snapshot_archives_dir, None)?;
     let full_snapshot_file_slot =
         read_full_snapshot_slot_file(&highest_bank_snapshot.snapshot_dir).ok()?;
     (full_snapshot_file_slot == highest_full_snapshot_archive_slot).then_some(highest_bank_snapshot)
@@ -2066,8 +2066,9 @@ pub fn get_incremental_snapshot_archives(
 /// Get the highest slot of the full snapshot archives in a directory
 pub fn get_highest_full_snapshot_archive_slot(
     full_snapshot_archives_dir: impl AsRef<Path>,
+    halt_at_slot: Option<Slot>,
 ) -> Option<Slot> {
-    get_highest_full_snapshot_archive_info(full_snapshot_archives_dir)
+    get_highest_full_snapshot_archive_info(full_snapshot_archives_dir, halt_at_slot)
         .map(|full_snapshot_archive_info| full_snapshot_archive_info.slot())
 }
 
@@ -2076,10 +2077,12 @@ pub fn get_highest_full_snapshot_archive_slot(
 pub fn get_highest_incremental_snapshot_archive_slot(
     incremental_snapshot_archives_dir: impl AsRef<Path>,
     full_snapshot_slot: Slot,
+    halt_at_slot: Option<Slot>,
 ) -> Option<Slot> {
     get_highest_incremental_snapshot_archive_info(
         incremental_snapshot_archives_dir,
         full_snapshot_slot,
+        halt_at_slot,
     )
     .map(|incremental_snapshot_archive_info| incremental_snapshot_archive_info.slot())
 }
@@ -2087,8 +2090,13 @@ pub fn get_highest_incremental_snapshot_archive_slot(
 /// Get the path (and metadata) for the full snapshot archive with the highest slot in a directory
 pub fn get_highest_full_snapshot_archive_info(
     full_snapshot_archives_dir: impl AsRef<Path>,
+    halt_at_slot: Option<Slot>,
 ) -> Option<FullSnapshotArchiveInfo> {
     let mut full_snapshot_archives = get_full_snapshot_archives(full_snapshot_archives_dir);
+    if let Some(halt_at_slot) = halt_at_slot {
+        full_snapshot_archives
+            .retain(|archive| archive.snapshot_archive_info().slot <= halt_at_slot);
+    }
     full_snapshot_archives.sort_unstable();
     full_snapshot_archives.into_iter().next_back()
 }
@@ -2098,6 +2106,7 @@ pub fn get_highest_full_snapshot_archive_info(
 pub fn get_highest_incremental_snapshot_archive_info(
     incremental_snapshot_archives_dir: impl AsRef<Path>,
     full_snapshot_slot: Slot,
+    halt_at_slot: Option<Slot>,
 ) -> Option<IncrementalSnapshotArchiveInfo> {
     // Since we want to filter down to only the incremental snapshot archives that have the same
     // full snapshot slot as the value passed in, perform the filtering before sorting to avoid
@@ -2109,6 +2118,9 @@ pub fn get_highest_incremental_snapshot_archive_info(
                 incremental_snapshot_archive_info.base_slot() == full_snapshot_slot
             })
             .collect::<Vec<_>>();
+    if let Some(halt_at_slot) = halt_at_slot {
+        incremental_snapshot_archives.retain(|archive| archive.slot() <= halt_at_slot);
+    }
     incremental_snapshot_archives.sort_unstable();
     incremental_snapshot_archives.into_iter().next_back()
 }
@@ -3136,7 +3148,7 @@ mod tests {
         );
 
         assert_eq!(
-            get_highest_full_snapshot_archive_slot(full_snapshot_archives_dir.path()),
+            get_highest_full_snapshot_archive_slot(full_snapshot_archives_dir.path(), None),
             Some(max_slot - 1)
         );
     }
@@ -3162,7 +3174,8 @@ mod tests {
             assert_eq!(
                 get_highest_incremental_snapshot_archive_slot(
                     incremental_snapshot_archives_dir.path(),
-                    full_snapshot_slot
+                    full_snapshot_slot,
+                    None,
                 ),
                 Some(max_incremental_snapshot_slot - 1)
             );
@@ -3171,7 +3184,8 @@ mod tests {
         assert_eq!(
             get_highest_incremental_snapshot_archive_slot(
                 incremental_snapshot_archives_dir.path(),
-                max_full_snapshot_slot
+                max_full_snapshot_slot,
+                None,
             ),
             None
         );
diff --git a/runtime/src/stake_account.rs b/runtime/src/stake_account.rs
index d735e2fe7a02..9a943cacbab6 100644
--- a/runtime/src/stake_account.rs
+++ b/runtime/src/stake_account.rs
@@ -41,14 +41,14 @@ impl<T> StakeAccount<T> {
     }
 
     #[inline]
-    pub(crate) fn stake_state(&self) -> &StakeStateV2 {
+    pub fn stake_state(&self) -> &StakeStateV2 {
         &self.stake_state
     }
 }
 
 impl StakeAccount<Delegation> {
     #[inline]
-    pub(crate) fn delegation(&self) -> &Delegation {
+    pub fn delegation(&self) -> &Delegation {
         // Safe to unwrap here because StakeAccount<Delegation> will always
         // only wrap a stake-state which is a delegation.
         self.stake_state.delegation_ref().unwrap()
diff --git a/runtime/src/stakes.rs b/runtime/src/stakes.rs
index 53e563889d67..88d086e91f12 100644
--- a/runtime/src/stakes.rs
+++ b/runtime/src/stakes.rs
@@ -52,18 +52,18 @@ pub enum InvalidCacheEntryReason {
     WrongOwner,
 }
 
-type StakeAccount = stake_account::StakeAccount<Delegation>;
+pub type StakeAccount = stake_account::StakeAccount<Delegation>;
 
 #[cfg_attr(feature = "frozen-abi", derive(AbiExample))]
 #[derive(Default, Debug)]
-pub(crate) struct StakesCache(RwLock<Stakes<StakeAccount>>);
+pub struct StakesCache(RwLock<Stakes<StakeAccount>>);
 
 impl StakesCache {
     pub(crate) fn new(stakes: Stakes<StakeAccount>) -> Self {
         Self(RwLock::new(stakes))
     }
 
-    pub(crate) fn stakes(&self) -> RwLockReadGuard<Stakes<StakeAccount>> {
+    pub fn stakes(&self) -> RwLockReadGuard<Stakes<StakeAccount>> {
         self.0.read().unwrap()
     }
 
@@ -191,7 +191,7 @@ pub struct Stakes<T: Clone> {
     vote_accounts: VoteAccounts,
 
     /// stake_delegations
-    stake_delegations: ImHashMap<Pubkey, T>,
+    pub stake_delegations: ImHashMap<Pubkey, T>,
 
     /// unused
     unused: u64,
@@ -234,7 +234,7 @@ impl Stakes<StakeAccount> {
     /// full account state for respective stake pubkeys. get_account function
     /// should return the account at the respective slot where stakes where
     /// cached.
-    pub(crate) fn new<F>(stakes: &Stakes<Delegation>, get_account: F) -> Result<Self, Error>
+    pub fn new<F>(stakes: &Stakes<Delegation>, get_account: F) -> Result<Self, Error>
     where
         F: Fn(&Pubkey) -> Option<AccountSharedData> + Sync,
     {
@@ -474,7 +474,7 @@ impl Stakes<StakeAccount> {
         );
     }
 
-    pub(crate) fn stake_delegations(&self) -> &ImHashMap<Pubkey, StakeAccount> {
+    pub fn stake_delegations(&self) -> &ImHashMap<Pubkey, StakeAccount> {
         &self.stake_delegations
     }
 
diff --git a/runtime/src/transaction_batch.rs b/runtime/src/transaction_batch.rs
index ecec27e02e93..3e92176db2f0 100644
--- a/runtime/src/transaction_batch.rs
+++ b/runtime/src/transaction_batch.rs
@@ -1,6 +1,6 @@
 use {
     crate::bank::Bank,
-    solana_sdk::transaction::{Result, SanitizedTransaction},
+    solana_sdk::transaction::{Result, SanitizedTransaction, TransactionError},
     std::borrow::Cow,
 };
 
@@ -79,6 +79,28 @@ impl<'a, 'b> TransactionBatch<'a, 'b> {
         // that validity constraint.
         self.lock_results = transaction_results;
     }
+
+    /// Bundle locking failed if lock result returns something other than ok or AccountInUse
+    pub fn check_bundle_lock_results(&self) -> Option<(&SanitizedTransaction, &TransactionError)> {
+        self.sanitized_transactions()
+            .iter()
+            .zip(self.lock_results.iter())
+            .find(|(_, lock_result)| {
+                !matches!(lock_result, Ok(()) | Err(TransactionError::AccountInUse))
+            })
+            .map(|(transaction, lock_result)| {
+                (
+                    transaction,
+                    match lock_result {
+                        Ok(_) => {
+                            // safe here bc the above find will never return Ok
+                            unreachable!()
+                        }
+                        Err(lock_error) => lock_error,
+                    },
+                )
+            })
+    }
 }
 
 // Unlock all locked accounts in destructor.
diff --git a/rustfmt.toml b/rustfmt.toml
index e26d07f0d84e..c7ccd487504a 100644
--- a/rustfmt.toml
+++ b/rustfmt.toml
@@ -1,2 +1,7 @@
 imports_granularity = "One"
 group_imports = "One"
+
+ignore = [
+    "jito-programs",
+    "anchor"
+]
\ No newline at end of file
diff --git a/s b/s
new file mode 100755
index 000000000000..308133d22740
--- /dev/null
+++ b/s
@@ -0,0 +1,15 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
+
+if [ -f .env ]; then
+  export $(cat .env | grep -v '#' | awk '/=/ {print $1}')
+else
+  echo "Missing .env file"
+  exit 0
+fi
+
+echo "Syncing to host: $HOST"
+
+# sync to build server, ignoring local builds and local/remote dev ledger
+rsync -avh --delete --exclude target --exclude docker-output "$SCRIPT_DIR" "$HOST":~/
diff --git a/scripts/agave-install-deploy.sh b/scripts/agave-install-deploy.sh
index dcdec14ffb63..86575954d3f2 100755
--- a/scripts/agave-install-deploy.sh
+++ b/scripts/agave-install-deploy.sh
@@ -57,10 +57,10 @@ esac
 
 case $TAG in
 edge|beta)
-  DOWNLOAD_URL=https://release.anza.xyz/"$TAG"/solana-release-$TARGET.tar.bz2
+  DOWNLOAD_URL=https://release.jito.wtf/"$TAG"/solana-release-$TARGET.tar.bz2
   ;;
 *)
-  DOWNLOAD_URL=https://github.com/anza-xyz/agave/releases/download/"$TAG"/solana-release-$TARGET.tar.bz2
+  DOWNLOAD_URL=https://github.com/jito-foundation/jito-solana/releases/download/"$TAG"/solana-release-$TARGET.tar.bz2
   ;;
 esac
 
diff --git a/scripts/increment-cargo-version.sh b/scripts/increment-cargo-version.sh
index 866f44287402..41e1994ced33 100755
--- a/scripts/increment-cargo-version.sh
+++ b/scripts/increment-cargo-version.sh
@@ -23,6 +23,8 @@ ignores=(
   .cargo
   target
   node_modules
+  jito-programs
+  anchor
 )
 
 not_paths=()
diff --git a/scripts/run.sh b/scripts/run.sh
index 70994c921f47..4a148dfed5e4 100755
--- a/scripts/run.sh
+++ b/scripts/run.sh
@@ -104,6 +104,10 @@ args=(
   --identity "$validator_identity"
   --vote-account "$validator_vote_account"
   --ledger "$ledgerDir"
+  --tip-payment-program-pubkey "T1pyyaTNZsKv2WcRAB8oVnk93mLJw2XzjtVYqCsaHqt"
+  --tip-distribution-program-pubkey "4R3gSG8BpU4t19KYj8CfnbtRpnT8gtk4dvTHxVRwc2r7"
+  --merkle-root-upload-authority "$validator_identity"
+  --commission-bps 0
   --gossip-port 8001
   --full-rpc-api
   --rpc-port 8899
diff --git a/sdk/Cargo.toml b/sdk/Cargo.toml
index 1f553f66a522..65913443ceda 100644
--- a/sdk/Cargo.toml
+++ b/sdk/Cargo.toml
@@ -17,8 +17,8 @@ edition = { workspace = true }
 program = []
 
 default = [
-  "borsh",
-  "full" # functionality that is not compatible or needed for on-chain programs
+    "borsh",
+    "full" # functionality that is not compatible or needed for on-chain programs
 ]
 full = [
     "byteorder",
@@ -36,15 +36,18 @@ full = [
 ]
 borsh = ["dep:borsh", "solana-program/borsh"]
 dev-context-only-utils = [
-  "qualifier_attr"
+    "qualifier_attr"
 ]
 frozen-abi = [
-  "dep:solana-frozen-abi",
-  "dep:solana-frozen-abi-macro",
-  "solana-program/frozen-abi",
+    "dep:solana-frozen-abi",
+    "dep:solana-frozen-abi-macro",
+    "solana-program/frozen-abi",
 ]
 
 [dependencies]
+anchor-lang = { workspace = true }
+assert_matches = { workspace = true, optional = true }
+base64 = { workspace = true }
 bincode = { workspace = true }
 bitflags = { workspace = true, features = ["serde"] }
 borsh = { workspace = true, optional = true }
@@ -60,7 +63,7 @@ ed25519-dalek = { workspace = true, optional = true }
 ed25519-dalek-bip32 = { workspace = true, optional = true }
 generic-array = { workspace = true, features = ["serde", "more_lengths"], optional = true }
 hmac = { workspace = true }
-itertools =  { workspace = true }
+itertools = { workspace = true }
 lazy_static = { workspace = true }
 libsecp256k1 = { workspace = true, optional = true, features = ["hmac"] }
 log = { workspace = true }
diff --git a/sdk/src/bundle/mod.rs b/sdk/src/bundle/mod.rs
new file mode 100644
index 000000000000..3c02a59f9f56
--- /dev/null
+++ b/sdk/src/bundle/mod.rs
@@ -0,0 +1,33 @@
+#![cfg(feature = "full")]
+
+use {
+    crate::transaction::{SanitizedTransaction, VersionedTransaction},
+    digest::Digest,
+    itertools::Itertools,
+    sha2::Sha256,
+};
+
+#[derive(Debug, PartialEq, Default, Eq, Clone, Serialize, Deserialize)]
+pub struct VersionedBundle {
+    pub transactions: Vec<VersionedTransaction>,
+}
+
+#[derive(Clone, Debug)]
+pub struct SanitizedBundle {
+    pub transactions: Vec<SanitizedTransaction>,
+    pub bundle_id: String,
+}
+
+pub fn derive_bundle_id(transactions: &[VersionedTransaction]) -> String {
+    let mut hasher = Sha256::new();
+    hasher.update(transactions.iter().map(|tx| tx.signatures[0]).join(","));
+    format!("{:x}", hasher.finalize())
+}
+
+pub fn derive_bundle_id_from_sanitized_transactions(
+    transactions: &[SanitizedTransaction],
+) -> String {
+    let mut hasher = Sha256::new();
+    hasher.update(transactions.iter().map(|tx| tx.signature()).join(","));
+    format!("{:x}", hasher.finalize())
+}
diff --git a/sdk/src/lib.rs b/sdk/src/lib.rs
index f5b0a5682f17..3e16ca3f1f02 100644
--- a/sdk/src/lib.rs
+++ b/sdk/src/lib.rs
@@ -62,6 +62,7 @@ pub use solana_program::{borsh, borsh0_10, borsh1};
 
 pub mod account;
 pub mod account_utils;
+pub mod bundle;
 pub mod client;
 pub mod commitment_config;
 pub mod compute_budget;
diff --git a/send-transaction-service/Cargo.toml b/send-transaction-service/Cargo.toml
index a69c366a358f..9da9b4d40595 100644
--- a/send-transaction-service/Cargo.toml
+++ b/send-transaction-service/Cargo.toml
@@ -14,6 +14,7 @@ crossbeam-channel = { workspace = true }
 log = { workspace = true }
 solana-client = { workspace = true }
 solana-connection-cache = { workspace = true }
+solana-gossip = { workspace = true }
 solana-measure = { workspace = true }
 solana-metrics = { workspace = true }
 solana-runtime = { workspace = true }
@@ -23,6 +24,7 @@ solana-tpu-client = { workspace = true }
 [dev-dependencies]
 solana-logger = { workspace = true }
 solana-runtime = { workspace = true, features = ["dev-context-only-utils"] }
+solana-streamer = { workspace = true }
 
 [package.metadata.docs.rs]
 targets = ["x86_64-unknown-linux-gnu"]
diff --git a/send-transaction-service/src/send_transaction_service.rs b/send-transaction-service/src/send_transaction_service.rs
index 8cc21b123596..94036582069c 100644
--- a/send-transaction-service/src/send_transaction_service.rs
+++ b/send-transaction-service/src/send_transaction_service.rs
@@ -4,6 +4,7 @@ use {
     log::*,
     solana_client::connection_cache::{ConnectionCache, Protocol},
     solana_connection_cache::client_connection::ClientConnection as TpuConnection,
+    solana_gossip::cluster_info::ClusterInfo,
     solana_measure::measure::Measure,
     solana_runtime::{bank::Bank, bank_forks::BankForks},
     solana_sdk::{
@@ -330,7 +331,7 @@ const SEND_TRANSACTION_METRICS_REPORT_RATE_MS: u64 = 5000;
 
 impl SendTransactionService {
     pub fn new<T: TpuInfo + std::marker::Send + 'static>(
-        tpu_address: SocketAddr,
+        cluster_info: Arc<ClusterInfo>,
         bank_forks: &Arc<RwLock<BankForks>>,
         leader_info: Option<T>,
         receiver: Receiver<TransactionInfo>,
@@ -345,7 +346,7 @@ impl SendTransactionService {
             ..Config::default()
         };
         Self::new_with_config(
-            tpu_address,
+            cluster_info,
             bank_forks,
             leader_info,
             receiver,
@@ -356,7 +357,7 @@ impl SendTransactionService {
     }
 
     pub fn new_with_config<T: TpuInfo + std::marker::Send + 'static>(
-        tpu_address: SocketAddr,
+        cluster_info: Arc<ClusterInfo>,
         bank_forks: &Arc<RwLock<BankForks>>,
         leader_info: Option<T>,
         receiver: Receiver<TransactionInfo>,
@@ -371,7 +372,7 @@ impl SendTransactionService {
         let leader_info_provider = Arc::new(Mutex::new(CurrentLeaderInfo::new(leader_info)));
 
         let receive_txn_thread = Self::receive_txn_thread(
-            tpu_address,
+            cluster_info.clone(),
             receiver,
             leader_info_provider.clone(),
             connection_cache.clone(),
@@ -382,7 +383,7 @@ impl SendTransactionService {
         );
 
         let retry_thread = Self::retry_thread(
-            tpu_address,
+            cluster_info,
             bank_forks.clone(),
             leader_info_provider,
             connection_cache.clone(),
@@ -400,7 +401,7 @@ impl SendTransactionService {
 
     /// Thread responsible for receiving transactions from RPC clients.
     fn receive_txn_thread<T: TpuInfo + std::marker::Send + 'static>(
-        tpu_address: SocketAddr,
+        cluster_info: Arc<ClusterInfo>,
         receiver: Receiver<TransactionInfo>,
         leader_info_provider: Arc<Mutex<CurrentLeaderInfo<T>>>,
         connection_cache: Arc<ConnectionCache>,
@@ -461,6 +462,10 @@ impl SendTransactionService {
                     stats
                         .sent_transactions
                         .fetch_add(transactions.len() as u64, Ordering::Relaxed);
+                    let tpu_address = cluster_info
+                        .my_contact_info()
+                        .tpu(connection_cache.protocol())
+                        .unwrap();
                     Self::send_transactions_in_batch(
                         &tpu_address,
                         &transactions,
@@ -506,7 +511,7 @@ impl SendTransactionService {
 
     /// Thread responsible for retrying transactions
     fn retry_thread<T: TpuInfo + std::marker::Send + 'static>(
-        tpu_address: SocketAddr,
+        cluster_info: Arc<ClusterInfo>,
         bank_forks: Arc<RwLock<BankForks>>,
         leader_info_provider: Arc<Mutex<CurrentLeaderInfo<T>>>,
         connection_cache: Arc<ConnectionCache>,
@@ -539,7 +544,10 @@ impl SendTransactionService {
                         let bank_forks = bank_forks.read().unwrap();
                         (bank_forks.root_bank(), bank_forks.working_bank())
                     };
-
+                    let tpu_address = cluster_info
+                        .my_contact_info()
+                        .tpu(connection_cache.protocol())
+                        .unwrap();
                     let _result = Self::process_transactions(
                         &working_bank,
                         &root_bank,
@@ -824,27 +832,40 @@ mod test {
         super::*,
         crate::tpu_info::NullTpuInfo,
         crossbeam_channel::{bounded, unbounded},
+        solana_gossip::contact_info::ContactInfo,
         solana_sdk::{
             account::AccountSharedData,
             genesis_config::create_genesis_config,
             nonce::{self, state::DurableNonce},
             pubkey::Pubkey,
-            signature::Signer,
+            signature::{Keypair, Signer},
             system_program, system_transaction,
+            timing::timestamp,
         },
+        solana_streamer::socket::SocketAddrSpace,
         std::ops::Sub,
     };
 
+    fn new_test_cluster_info() -> Arc<ClusterInfo> {
+        let keypair = Arc::new(Keypair::new());
+        let contact_info = ContactInfo::new_localhost(&keypair.pubkey(), timestamp());
+        Arc::new(ClusterInfo::new(
+            contact_info,
+            keypair,
+            SocketAddrSpace::Unspecified,
+        ))
+    }
+
     #[test]
     fn service_exit() {
-        let tpu_address = "127.0.0.1:0".parse().unwrap();
         let bank = Bank::default_for_tests();
         let bank_forks = BankForks::new_rw_arc(bank);
         let (sender, receiver) = unbounded();
 
         let connection_cache = Arc::new(ConnectionCache::new("connection_cache_test"));
+        let cluster_info = new_test_cluster_info();
         let send_transaction_service = SendTransactionService::new::<NullTpuInfo>(
-            tpu_address,
+            cluster_info,
             &bank_forks,
             None,
             receiver,
@@ -860,7 +881,7 @@ mod test {
 
     #[test]
     fn validator_exit() {
-        let tpu_address = "127.0.0.1:0".parse().unwrap();
+        let cluster_info = new_test_cluster_info();
         let bank = Bank::default_for_tests();
         let bank_forks = BankForks::new_rw_arc(bank);
         let (sender, receiver) = bounded(0);
@@ -878,7 +899,7 @@ mod test {
         let exit = Arc::new(AtomicBool::new(false));
         let connection_cache = Arc::new(ConnectionCache::new("connection_cache_test"));
         let _send_transaction_service = SendTransactionService::new::<NullTpuInfo>(
-            tpu_address,
+            cluster_info,
             &bank_forks,
             None,
             receiver,
diff --git a/start b/start
new file mode 100755
index 000000000000..c2f35e272ab7
--- /dev/null
+++ b/start
@@ -0,0 +1,9 @@
+#!/usr/bin/env bash
+set -eu
+
+SOLANA_CONFIG_DIR=./config
+
+mkdir -p $SOLANA_CONFIG_DIR
+NDEBUG=1 ./multinode-demo/setup.sh
+cargo run --release --bin solana-ledger-tool -- -l config/bootstrap-validator/ create-snapshot 0
+NDEBUG=1 ./multinode-demo/faucet.sh
diff --git a/start_multi b/start_multi
new file mode 100755
index 000000000000..66de0032dc36
--- /dev/null
+++ b/start_multi
@@ -0,0 +1,30 @@
+#!/usr/bin/env bash
+set -eu
+
+SOLANA_KEYGEN="cargo run --release --bin solana-keygen --"
+SOLANA_CONFIG_DIR=./config
+
+if [[ ! -d $SOLANA_CONFIG_DIR ]]; then
+  echo "New Config! Generating Identities"
+  mkdir $SOLANA_CONFIG_DIR
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/a/identity.json
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/a/stake-account.json
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/a/vote-account.json
+
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/b/identity.json
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/b/stake-account.json
+  $SOLANA_KEYGEN new --no-passphrase -so "$SOLANA_CONFIG_DIR"/b/vote-account.json
+fi
+
+NDEBUG=1 ./multinode-demo/setup.sh \
+  --bootstrap-validator \
+  "$SOLANA_CONFIG_DIR"/a/identity.json \
+  "$SOLANA_CONFIG_DIR"/a/vote-account.json \
+  "$SOLANA_CONFIG_DIR"/a/stake-account.json \
+  --bootstrap-validator \
+  "$SOLANA_CONFIG_DIR"/b/identity.json \
+  "$SOLANA_CONFIG_DIR"/b/vote-account.json \
+  "$SOLANA_CONFIG_DIR"/b/stake-account.json
+
+cargo run --bin solana-ledger-tool -- -l config/bootstrap-validator/ create-snapshot 0
+NDEBUG=1 ./multinode-demo/faucet.sh
diff --git a/svm/src/account_loader.rs b/svm/src/account_loader.rs
index c62963c09e09..4cf6c882d3aa 100644
--- a/svm/src/account_loader.rs
+++ b/svm/src/account_loader.rs
@@ -6,6 +6,7 @@ use {
         transaction_processing_callback::TransactionProcessingCallback,
     },
     itertools::Itertools,
+    log::info,
     solana_compute_budget::compute_budget_processor::{
         process_compute_budget_instructions, ComputeBudgetLimits,
     },
@@ -235,6 +236,10 @@ fn load_transaction_accounts<CB: TransactionProcessingCallback>(
                 } else if let Some(account_override) =
                     account_overrides.and_then(|overrides| overrides.get(key))
                 {
+                    info!(
+                        "loaded account from cache key: {:?} override: {:?}",
+                        key, account_override
+                    );
                     (account_override.data().len(), account_override.clone(), 0)
                 } else if let Some(program) = (!instruction_account && !message.is_writable(i))
                     .then_some(())
diff --git a/svm/src/account_overrides.rs b/svm/src/account_overrides.rs
index 8a205a798f66..b92ba7d0adce 100644
--- a/svm/src/account_overrides.rs
+++ b/svm/src/account_overrides.rs
@@ -4,12 +4,16 @@ use {
 };
 
 /// Encapsulates overridden accounts, typically used for transaction simulations
-#[derive(Default)]
+#[derive(Clone, Default, Debug)]
 pub struct AccountOverrides {
     accounts: HashMap<Pubkey, AccountSharedData>,
 }
 
 impl AccountOverrides {
+    pub fn upsert_account_overrides(&mut self, other: AccountOverrides) {
+        self.accounts.extend(other.accounts);
+    }
+
     /// Insert or remove an account with a given pubkey to/from the list of overrides.
     pub fn set_account(&mut self, pubkey: &Pubkey, account: Option<AccountSharedData>) {
         match account {
diff --git a/svm/src/transaction_processor.rs b/svm/src/transaction_processor.rs
index edcba870c6e8..feb37beeb049 100644
--- a/svm/src/transaction_processor.rs
+++ b/svm/src/transaction_processor.rs
@@ -245,7 +245,7 @@ impl<FG: ForkGraph> TransactionBatchProcessor<FG> {
             environment
                 .rent_collector
                 .unwrap_or(&RentCollector::default()),
-            &mut error_metrics
+            &mut error_metrics,
         ));
 
         let mut program_cache_time = Measure::start("program_cache");
diff --git a/test-validator/src/lib.rs b/test-validator/src/lib.rs
index da0d669b7639..ddd526b23d5a 100644
--- a/test-validator/src/lib.rs
+++ b/test-validator/src/lib.rs
@@ -1025,6 +1025,7 @@ impl TestValidator {
             config.tpu_enable_udp,
             32, // max connections per IpAddr per minute for test
             config.admin_rpc_service_post_init.clone(),
+            None,
         )?);
 
         // Needed to avoid panics in `solana-responder-gossip` in tests that create a number of
diff --git a/tip-distributor/Cargo.toml b/tip-distributor/Cargo.toml
new file mode 100644
index 000000000000..76682d220a85
--- /dev/null
+++ b/tip-distributor/Cargo.toml
@@ -0,0 +1,61 @@
+[package]
+name = "solana-tip-distributor"
+version = { workspace = true }
+edition = { workspace = true }
+license = { workspace = true }
+description = "Collection of binaries used to distribute MEV rewards to delegators and validators."
+publish = false
+
+[dependencies]
+anchor-lang = { workspace = true }
+clap = { version = "4.1.11", features = ["derive", "env"] }
+crossbeam-channel = { workspace = true }
+env_logger = { workspace = true }
+futures = { workspace = true }
+gethostname = { workspace = true }
+im = { workspace = true }
+itertools = { workspace = true }
+jito-tip-distribution = { workspace = true }
+jito-tip-payment = { workspace = true }
+log = { workspace = true }
+num-traits = { workspace = true }
+rand = { workspace = true }
+serde = { workspace = true }
+serde_json = { workspace = true }
+solana-accounts-db = { workspace = true }
+solana-client = { workspace = true }
+solana-genesis-utils = { workspace = true }
+solana-ledger = { workspace = true }
+solana-measure = { workspace = true }
+solana-merkle-tree = { workspace = true }
+solana-metrics = { workspace = true }
+solana-program = { workspace = true }
+solana-program-runtime = { workspace = true }
+solana-rpc-client-api = { workspace = true }
+solana-runtime = { workspace = true }
+solana-sdk = { workspace = true }
+solana-stake-program = { workspace = true }
+solana-transaction-status = { workspace = true }
+solana-vote = { workspace = true }
+thiserror = { workspace = true }
+tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
+
+[dev-dependencies]
+solana-runtime = { workspace = true, features = ["dev-context-only-utils"] }
+solana-sdk = { workspace = true, features = ["dev-context-only-utils"] }
+
+[[bin]]
+name = "solana-stake-meta-generator"
+path = "src/bin/stake-meta-generator.rs"
+
+[[bin]]
+name = "solana-merkle-root-generator"
+path = "src/bin/merkle-root-generator.rs"
+
+[[bin]]
+name = "solana-merkle-root-uploader"
+path = "src/bin/merkle-root-uploader.rs"
+
+[[bin]]
+name = "solana-claim-mev-tips"
+path = "src/bin/claim-mev-tips.rs"
diff --git a/tip-distributor/README.md b/tip-distributor/README.md
new file mode 100644
index 000000000000..fec682879adb
--- /dev/null
+++ b/tip-distributor/README.md
@@ -0,0 +1,52 @@
+# Tip Distributor
+This library and collection of binaries are responsible for generating and uploading merkle roots to the on-chain 
+tip-distribution program found [here](https://github.com/jito-foundation/jito-programs/blob/submodule/tip-payment/programs/tip-distribution/src/lib.rs).
+
+## Background
+Each individual validator is assigned a new PDA per epoch where their share of tips, in lamports, will be stored. 
+At the end of the epoch it's expected that validators take a commission and then distribute the rest of the funds
+to their delegators such that delegators receive rewards proportional to their respective delegations. The distribution
+mechanism is via merkle proofs similar to how airdrops work.
+
+The merkle roots are calculated off-chain and uploaded to the validator's **TipDistributionAccount** PDA. Validators may
+elect an account to upload the merkle roots on their behalf. Once uploaded, users can invoke the **claim** instruction
+and receive the rewards they're entitled to. Once all funds are claimed by users the validator can close the account and
+refunded the rent.
+
+## Scripts
+
+### stake-meta-generator
+
+This script generates a JSON file identifying individual stake delegations to a validator, along with amount of lamports 
+in each validator's **TipDistributionAccount**. All validators will be contained in the JSON list, regardless of whether 
+the validator is a participant in the system; participant being indicative of running the jito-solana client to accept tips 
+having initialized a **TipDistributionAccount** PDA account for the epoch.
+
+One edge case that we've taken into account is the last validator in an epoch N receives tips but those tips don't get transferred
+out into the PDA until some slot in epoch N + 1. Due to this we cannot rely on the bank's state at epoch N for lamports amount
+in the PDAs. We use the bank solely to take a snapshot of delegations, but an RPC node to fetch the PDA lamports for more up-to-date data.
+
+### merkle-root-generator
+This script accepts a path to the above JSON file as one of its arguments, and generates a merkle-root into a JSON file.
+
+### merkle-root-uploader
+Uploads the root on-chain.
+
+### claim-mev-tips
+This reads the file outputted by `merkle-root-generator` and finds all eligible accounts to receive mev tips. Transactions
+are created and sent to the RPC server.
+
+
+## How it works?
+In order to use this library as the merkle root creator one must follow the following steps:
+1. Download a ledger snapshot containing the slot of interest, i.e. the last slot in an epoch. The Solana foundation has snapshots that can be found [here](https://console.cloud.google.com/storage/browser/mainnet-beta-ledger-us-ny5).
+2. Download the snapshot onto your worker machine (where this script will run).
+3. Run `solana-ledger-tool -l ${PATH_TO_LEDGER} create-snapshot ${YOUR_SLOT} ${WHERE_TO_CREATE_SNAPSHOT}`
+   1. The snapshot created at `${WHERE_TO_CREATE_SNAPSHOT}` will have the highest slot of `${YOUR_SLOT}`, assuming you downloaded the correct snapshot.
+4. Run `stake-meta-generator --ledger-path ${WHERE_TO_CREATE_SNAPSHOT} --tip-distribution-program-id ${PUBKEY} --out-path ${JSON_OUT_PATH} --snapshot-slot ${SLOT} --rpc-url ${URL}`
+   1. Note: `${WHERE_TO_CREATE_SNAPSHOT}` must be the same in steps 3 & 4.
+5. Run `merkle-root-generator --stake-meta-coll-path ${STAKE_META_COLLECTION_JSON} --rpc-url ${URL} --out-path ${MERKLE_ROOT_PATH}`
+6. Run `merkle-root-uploader --out-path ${MERKLE_ROOT_PATH} --keypair-path ${KEYPAIR_PATH} --rpc-url ${URL} --tip-distribution-program-id ${PROGRAM_ID}`
+7. Run `solana-claim-mev-tips --merkle-trees-path /solana/ledger/autosnapshot/merkle-tree-221615999.json --rpc-url ${URL} --tip-distribution-program-id ${PROGRAM_ID} --keypair-path ${KEYPAIR_PATH}`
+
+Voila!
diff --git a/tip-distributor/src/bin/claim-mev-tips.rs b/tip-distributor/src/bin/claim-mev-tips.rs
new file mode 100644
index 000000000000..dd57db923156
--- /dev/null
+++ b/tip-distributor/src/bin/claim-mev-tips.rs
@@ -0,0 +1,190 @@
+//! This binary claims MEV tips.
+use {
+    clap::Parser,
+    futures::future::join_all,
+    gethostname::gethostname,
+    log::*,
+    solana_metrics::{datapoint_error, datapoint_info, set_host_id},
+    solana_sdk::{
+        pubkey::Pubkey,
+        signature::{read_keypair_file, Keypair},
+    },
+    solana_tip_distributor::{
+        claim_mev_workflow::{claim_mev_tips, ClaimMevError},
+        read_json_from_file,
+        reclaim_rent_workflow::reclaim_rent,
+        GeneratedMerkleTreeCollection,
+    },
+    std::{
+        path::PathBuf,
+        sync::Arc,
+        time::{Duration, Instant},
+    },
+};
+
+#[derive(Parser, Debug)]
+#[command(author, version, about, long_about = None)]
+struct Args {
+    /// Path to JSON file containing the [GeneratedMerkleTreeCollection] object.
+    #[arg(long, env)]
+    merkle_trees_path: PathBuf,
+
+    /// RPC to send transactions through
+    #[arg(long, env, default_value = "http://localhost:8899")]
+    rpc_url: String,
+
+    /// Tip distribution program ID
+    #[arg(long, env)]
+    tip_distribution_program_id: Pubkey,
+
+    /// Path to keypair
+    #[arg(long, env)]
+    keypair_path: PathBuf,
+
+    /// Limits how long before send loop runs before stopping
+    #[arg(long, env, default_value_t = 60 * 60)]
+    max_retry_duration_secs: u64,
+
+    /// Specifies whether to reclaim any rent.
+    #[arg(long, env, default_value_t = true)]
+    should_reclaim_rent: bool,
+
+    /// Specifies whether to reclaim rent on behalf of validators from respective TDAs.
+    #[arg(long, env)]
+    should_reclaim_tdas: bool,
+
+    /// The price to pay for priority fee
+    #[arg(long, env, default_value_t = 1)]
+    micro_lamports: u64,
+}
+
+async fn start_mev_claim_process(
+    merkle_trees: GeneratedMerkleTreeCollection,
+    rpc_url: String,
+    tip_distribution_program_id: Pubkey,
+    signer: Arc<Keypair>,
+    max_loop_duration: Duration,
+    micro_lamports: u64,
+) -> Result<(), ClaimMevError> {
+    let start = Instant::now();
+
+    match claim_mev_tips(
+        &merkle_trees,
+        rpc_url,
+        tip_distribution_program_id,
+        signer,
+        max_loop_duration,
+        micro_lamports,
+    )
+    .await
+    {
+        Err(e) => {
+            datapoint_error!(
+                "claim_mev_workflow-claim_error",
+                ("epoch", merkle_trees.epoch, i64),
+                ("error", 1, i64),
+                ("err_str", e.to_string(), String),
+                ("elapsed_us", start.elapsed().as_micros(), i64),
+            );
+            Err(e)
+        }
+        Ok(()) => {
+            datapoint_info!(
+                "claim_mev_workflow-claim_completion",
+                ("epoch", merkle_trees.epoch, i64),
+                ("elapsed_us", start.elapsed().as_micros(), i64),
+            );
+            Ok(())
+        }
+    }
+}
+
+async fn start_rent_claim(
+    rpc_url: String,
+    tip_distribution_program_id: Pubkey,
+    signer: Arc<Keypair>,
+    max_loop_duration: Duration,
+    should_reclaim_tdas: bool,
+    micro_lamports: u64,
+    epoch: u64,
+) -> Result<(), ClaimMevError> {
+    let start = Instant::now();
+    match reclaim_rent(
+        rpc_url,
+        tip_distribution_program_id,
+        signer,
+        max_loop_duration,
+        should_reclaim_tdas,
+        micro_lamports,
+    )
+    .await
+    {
+        Err(e) => {
+            datapoint_error!(
+                "claim_mev_workflow-reclaim_rent_error",
+                ("epoch", epoch, i64),
+                ("error", 1, i64),
+                ("err_str", e.to_string(), String),
+                ("elapsed_us", start.elapsed().as_micros(), i64),
+            );
+            Err(e)
+        }
+        Ok(()) => {
+            datapoint_info!(
+                "claim_mev_workflow-reclaim_rent_completion",
+                ("epoch", epoch, i64),
+                ("elapsed_us", start.elapsed().as_micros(), i64),
+            );
+            Ok(())
+        }
+    }
+}
+
+#[tokio::main]
+async fn main() -> Result<(), ClaimMevError> {
+    env_logger::init();
+
+    gethostname()
+        .into_string()
+        .map(set_host_id)
+        .expect("set hostname");
+
+    let args: Args = Args::parse();
+    let keypair = Arc::new(read_keypair_file(&args.keypair_path).expect("read keypair file"));
+    let merkle_trees: GeneratedMerkleTreeCollection =
+        read_json_from_file(&args.merkle_trees_path).expect("read GeneratedMerkleTreeCollection");
+    let max_loop_duration = Duration::from_secs(args.max_retry_duration_secs);
+
+    info!(
+        "Starting to claim mev tips for epoch: {}",
+        merkle_trees.epoch
+    );
+    let epoch = merkle_trees.epoch;
+
+    let mut futs = vec![];
+    futs.push(tokio::spawn(start_mev_claim_process(
+        merkle_trees,
+        args.rpc_url.clone(),
+        args.tip_distribution_program_id,
+        keypair.clone(),
+        max_loop_duration,
+        args.micro_lamports,
+    )));
+    if args.should_reclaim_rent {
+        futs.push(tokio::spawn(start_rent_claim(
+            args.rpc_url.clone(),
+            args.tip_distribution_program_id,
+            keypair.clone(),
+            max_loop_duration,
+            args.should_reclaim_tdas,
+            args.micro_lamports,
+            epoch,
+        )));
+    }
+    let results = join_all(futs).await;
+    solana_metrics::flush(); // sometimes last datapoint doesn't get emitted. this increases likelihood.
+    for r in results {
+        r.map_err(|e| ClaimMevError::UncaughtError { e: e.to_string() })??;
+    }
+    Ok(())
+}
diff --git a/tip-distributor/src/bin/merkle-root-generator.rs b/tip-distributor/src/bin/merkle-root-generator.rs
new file mode 100644
index 000000000000..9f2d0f9a4e66
--- /dev/null
+++ b/tip-distributor/src/bin/merkle-root-generator.rs
@@ -0,0 +1,34 @@
+//! This binary generates a merkle tree for each [TipDistributionAccount]; they are derived
+//! using a user provided [StakeMetaCollection] JSON file.
+
+use {
+    clap::Parser, log::*,
+    solana_tip_distributor::merkle_root_generator_workflow::generate_merkle_root,
+    std::path::PathBuf,
+};
+
+#[derive(Parser, Debug)]
+#[command(author, version, about, long_about = None)]
+struct Args {
+    /// Path to JSON file containing the [StakeMetaCollection] object.
+    #[arg(long, env)]
+    stake_meta_coll_path: PathBuf,
+
+    /// RPC to send transactions through. Used to validate what's being claimed is equal to TDA balance minus rent.
+    #[arg(long, env)]
+    rpc_url: String,
+
+    /// Path to JSON file to get populated with tree node data.
+    #[arg(long, env)]
+    out_path: PathBuf,
+}
+
+fn main() {
+    env_logger::init();
+    info!("Starting merkle-root-generator workflow...");
+
+    let args: Args = Args::parse();
+    generate_merkle_root(&args.stake_meta_coll_path, &args.out_path, &args.rpc_url)
+        .expect("merkle tree produced");
+    info!("saved merkle roots to {:?}", args.stake_meta_coll_path);
+}
diff --git a/tip-distributor/src/bin/merkle-root-uploader.rs b/tip-distributor/src/bin/merkle-root-uploader.rs
new file mode 100644
index 000000000000..9000ce66d01c
--- /dev/null
+++ b/tip-distributor/src/bin/merkle-root-uploader.rs
@@ -0,0 +1,54 @@
+use {
+    clap::Parser, log::info, solana_sdk::pubkey::Pubkey,
+    solana_tip_distributor::merkle_root_upload_workflow::upload_merkle_root, std::path::PathBuf,
+};
+
+#[derive(Parser, Debug)]
+#[command(author, version, about, long_about = None)]
+struct Args {
+    /// Path to JSON file containing the [StakeMetaCollection] object.
+    #[arg(long, env)]
+    merkle_root_path: PathBuf,
+
+    /// The path to the keypair used to sign and pay for the `upload_merkle_root` transactions.
+    #[arg(long, env)]
+    keypair_path: PathBuf,
+
+    /// The RPC to send transactions to.
+    #[arg(long, env)]
+    rpc_url: String,
+
+    /// Tip distribution program ID
+    #[arg(long, env)]
+    tip_distribution_program_id: Pubkey,
+
+    /// Rate-limits the maximum number of requests per RPC connection
+    #[arg(long, env, default_value_t = 100)]
+    max_concurrent_rpc_get_reqs: usize,
+
+    /// Number of transactions to send to RPC at a time.
+    #[arg(long, env, default_value_t = 64)]
+    txn_send_batch_size: usize,
+}
+
+fn main() {
+    env_logger::init();
+
+    let args: Args = Args::parse();
+
+    info!("starting merkle root uploader...");
+    if let Err(e) = upload_merkle_root(
+        &args.merkle_root_path,
+        &args.keypair_path,
+        &args.rpc_url,
+        &args.tip_distribution_program_id,
+        args.max_concurrent_rpc_get_reqs,
+        args.txn_send_batch_size,
+    ) {
+        panic!("failed to upload merkle roots: {:?}", e);
+    }
+    info!(
+        "uploaded merkle roots from file {:?}",
+        args.merkle_root_path
+    );
+}
diff --git a/tip-distributor/src/bin/stake-meta-generator.rs b/tip-distributor/src/bin/stake-meta-generator.rs
new file mode 100644
index 000000000000..be7993be021e
--- /dev/null
+++ b/tip-distributor/src/bin/stake-meta-generator.rs
@@ -0,0 +1,67 @@
+//! This binary is responsible for generating a JSON file that contains meta-data about stake
+//! & delegations given a ledger snapshot directory. The JSON file is structured as an array
+//! of [StakeMeta] objects.
+
+use {
+    clap::Parser,
+    log::*,
+    solana_sdk::{clock::Slot, pubkey::Pubkey},
+    solana_tip_distributor::{self, stake_meta_generator_workflow::generate_stake_meta},
+    std::{
+        fs::{self},
+        path::PathBuf,
+        process::exit,
+    },
+};
+
+#[derive(Parser, Debug)]
+#[command(author, version, about, long_about = None)]
+struct Args {
+    /// Ledger path, where you created the snapshot.
+    #[arg(long, env, value_parser = Args::ledger_path_parser)]
+    ledger_path: PathBuf,
+
+    /// The tip-distribution program id.
+    #[arg(long, env)]
+    tip_distribution_program_id: Pubkey,
+
+    /// The tip-payment program id.
+    #[arg(long, env)]
+    tip_payment_program_id: Pubkey,
+
+    /// Path to JSON file populated with the [StakeMetaCollection] object.
+    #[arg(long, env)]
+    out_path: String,
+
+    /// The expected snapshot slot.
+    #[arg(long, env)]
+    snapshot_slot: Slot,
+}
+
+impl Args {
+    fn ledger_path_parser(ledger_path: &str) -> Result<PathBuf, &'static str> {
+        Ok(fs::canonicalize(ledger_path).unwrap_or_else(|err| {
+            error!("Unable to access ledger path '{}': {}", ledger_path, err);
+            exit(1);
+        }))
+    }
+}
+
+fn main() {
+    env_logger::init();
+    info!("Starting stake-meta-generator...");
+
+    let args: Args = Args::parse();
+
+    if let Err(e) = generate_stake_meta(
+        &args.ledger_path,
+        &args.snapshot_slot,
+        &args.tip_distribution_program_id,
+        &args.out_path,
+        &args.tip_payment_program_id,
+    ) {
+        error!("error producing stake-meta: {:?}", e);
+    } else {
+        info!("produced stake meta");
+    }
+}
diff --git a/tip-distributor/src/claim_mev_workflow.rs b/tip-distributor/src/claim_mev_workflow.rs
new file mode 100644
index 000000000000..62b0b6fb0214
--- /dev/null
+++ b/tip-distributor/src/claim_mev_workflow.rs
@@ -0,0 +1,398 @@
+use {
+    crate::{send_until_blockhash_expires, GeneratedMerkleTreeCollection},
+    anchor_lang::{AccountDeserialize, InstructionData, ToAccountMetas},
+    itertools::Itertools,
+    jito_tip_distribution::state::{ClaimStatus, Config, TipDistributionAccount},
+    log::{error, info, warn},
+    rand::{prelude::SliceRandom, thread_rng},
+    solana_client::nonblocking::rpc_client::RpcClient,
+    solana_metrics::datapoint_info,
+    solana_program::{
+        fee_calculator::DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE, native_token::LAMPORTS_PER_SOL,
+        system_program,
+    },
+    solana_rpc_client_api::config::RpcSimulateTransactionConfig,
+    solana_sdk::{
+        account::Account,
+        commitment_config::CommitmentConfig,
+        compute_budget::ComputeBudgetInstruction,
+        instruction::Instruction,
+        pubkey::Pubkey,
+        signature::{Keypair, Signer},
+        transaction::Transaction,
+    },
+    std::{
+        collections::HashMap,
+        sync::Arc,
+        time::{Duration, Instant},
+    },
+    thiserror::Error,
+};
+
+#[derive(Error, Debug)]
+pub enum ClaimMevError {
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+
+    #[error(transparent)]
+    JsonError(#[from] serde_json::Error),
+
+    #[error(transparent)]
+    AnchorError(anchor_lang::error::Error),
+
+    #[error(transparent)]
+    RpcError(#[from] solana_rpc_client_api::client_error::Error),
+
+    #[error("Expected to have at least {desired_balance} lamports in {payer:?}. Current balance is {start_balance} lamports. Deposit {sol_to_deposit} SOL to continue.")]
+    InsufficientBalance {
+        desired_balance: u64,
+        payer: Pubkey,
+        start_balance: u64,
+        sol_to_deposit: u64,
+    },
+
+    #[error("Not finished with job, transactions left {transactions_left}")]
+    NotFinished { transactions_left: usize },
+
+    #[error("UncaughtError {e:?}")]
+    UncaughtError { e: String },
+}
+
+pub async fn get_claim_transactions_for_valid_unclaimed(
+    rpc_client: &RpcClient,
+    merkle_trees: &GeneratedMerkleTreeCollection,
+    tip_distribution_program_id: Pubkey,
+    micro_lamports: u64,
+    payer_pubkey: Pubkey,
+) -> Result<Vec<Transaction>, ClaimMevError> {
+    let tree_nodes = merkle_trees
+        .generated_merkle_trees
+        .iter()
+        .flat_map(|tree| &tree.tree_nodes)
+        .collect_vec();
+
+    info!(
+        "reading tip distribution related accounts for epoch {}",
+        merkle_trees.epoch
+    );
+
+    let start = Instant::now();
+
+    let tda_pubkeys = merkle_trees
+        .generated_merkle_trees
+        .iter()
+        .map(|tree| tree.tip_distribution_account)
+        .collect_vec();
+    let tdas: HashMap<Pubkey, Account> = crate::get_batched_accounts(rpc_client, &tda_pubkeys)
+        .await?
+        .into_iter()
+        .filter_map(|(pubkey, a)| Some((pubkey, a?)))
+        .collect();
+
+    let claimant_pubkeys = tree_nodes
+        .iter()
+        .map(|tree_node| tree_node.claimant)
+        .collect_vec();
+    let claimants: HashMap<Pubkey, Account> =
+        crate::get_batched_accounts(rpc_client, &claimant_pubkeys)
+            .await?
+            .into_iter()
+            .filter_map(|(pubkey, a)| Some((pubkey, a?)))
+            .collect();
+
+    let claim_status_pubkeys = tree_nodes
+        .iter()
+        .map(|tree_node| tree_node.claim_status_pubkey)
+        .collect_vec();
+    let claim_statuses: HashMap<Pubkey, Account> =
+        crate::get_batched_accounts(rpc_client, &claim_status_pubkeys)
+            .await?
+            .into_iter()
+            .filter_map(|(pubkey, a)| Some((pubkey, a?)))
+            .collect();
+
+    let elapsed_us = start.elapsed().as_micros();
+
+    // can be helpful for determining mismatch in state between requested and read
+    datapoint_info!(
+        "claim_mev-get_claim_transactions_account_data",
+        ("elapsed_us", elapsed_us, i64),
+        ("tdas", tda_pubkeys.len(), i64),
+        ("tdas_onchain", tdas.len(), i64),
+        ("claimants", claimant_pubkeys.len(), i64),
+        ("claimants_onchain", claimants.len(), i64),
+        ("claim_statuses", claim_status_pubkeys.len(), i64),
+        ("claim_statuses_onchain", claim_statuses.len(), i64),
+    );
+
+    let transactions = build_mev_claim_transactions(
+        tip_distribution_program_id,
+        merkle_trees,
+        tdas,
+        claimants,
+        claim_statuses,
+        micro_lamports,
+        payer_pubkey,
+    );
+
+    Ok(transactions)
+}
+
+pub async fn claim_mev_tips(
+    merkle_trees: &GeneratedMerkleTreeCollection,
+    rpc_url: String,
+    tip_distribution_program_id: Pubkey,
+    keypair: Arc<Keypair>,
+    max_loop_duration: Duration,
+    micro_lamports: u64,
+) -> Result<(), ClaimMevError> {
+    let rpc_client = RpcClient::new_with_timeout_and_commitment(
+        rpc_url,
+        Duration::from_secs(300),
+        CommitmentConfig::confirmed(),
+    );
+
+    let start = Instant::now();
+    while start.elapsed() <= max_loop_duration {
+        let mut all_claim_transactions = get_claim_transactions_for_valid_unclaimed(
+            &rpc_client,
+            merkle_trees,
+            tip_distribution_program_id,
+            micro_lamports,
+            keypair.pubkey(),
+        )
+        .await?;
+
+        datapoint_info!(
+            "claim_mev_tips-send_summary",
+            ("claim_transactions_left", all_claim_transactions.len(), i64),
+        );
+
+        if all_claim_transactions.is_empty() {
+            return Ok(());
+        }
+
+        all_claim_transactions.shuffle(&mut thread_rng());
+        let transactions: Vec<_> = all_claim_transactions.into_iter().take(10_000).collect();
+
+        // only check balance for the ones we need to currently send since reclaim rent running in parallel
+        if let Some((start_balance, desired_balance, sol_to_deposit)) =
+            is_sufficient_balance(&keypair.pubkey(), &rpc_client, transactions.len() as u64).await
+        {
+            return Err(ClaimMevError::InsufficientBalance {
+                desired_balance,
+                payer: keypair.pubkey(),
+                start_balance,
+                sol_to_deposit,
+            });
+        }
+
+        let blockhash = rpc_client.get_latest_blockhash().await?;
+        let _ = send_until_blockhash_expires(&rpc_client, transactions, blockhash, &keypair).await;
+    }
+
+    let transactions = get_claim_transactions_for_valid_unclaimed(
+        &rpc_client,
+        merkle_trees,
+        tip_distribution_program_id,
+        micro_lamports,
+        keypair.pubkey(),
+    )
+    .await?;
+    if transactions.is_empty() {
+        return Ok(());
+    }
+
+    // if more transactions left, we'll simulate them all to make sure its not an uncaught error
+    let mut is_error = false;
+    let mut error_str = String::new();
+    for tx in &transactions {
+        match rpc_client
+            .simulate_transaction_with_config(
+                tx,
+                RpcSimulateTransactionConfig {
+                    sig_verify: false,
+                    replace_recent_blockhash: true,
+                    commitment: Some(CommitmentConfig::processed()),
+                    ..RpcSimulateTransactionConfig::default()
+                },
+            )
+            .await
+        {
+            Ok(_) => {}
+            Err(e) => {
+                error_str = e.to_string();
+                is_error = true;
+
+                match e.get_transaction_error() {
+                    None => {
+                        break;
+                    }
+                    Some(e) => {
+                        warn!("transaction error. tx: {:?} error: {:?}", tx, e);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    if is_error {
+        Err(ClaimMevError::UncaughtError { e: error_str })
+    } else {
+        Err(ClaimMevError::NotFinished {
+            transactions_left: transactions.len(),
+        })
+    }
+}
+
+/// Returns a list of claim transactions for valid, unclaimed MEV tips
+/// A valid, unclaimed transaction consists of the following:
+/// - there must be lamports to claim for the tip distribution account.
+/// - there must be a merkle root.
+/// - the claimant (typically a stake account) must exist.
+/// - the claimant (typically a stake account) must have a non-zero amount of tips to claim
+/// - the claimant must have enough lamports post-claim to be rent-exempt.
+///   - note: there aren't any rent exempt accounts on solana mainnet anymore.
+/// - it must not have already been claimed.
+fn build_mev_claim_transactions(
+    tip_distribution_program_id: Pubkey,
+    merkle_trees: &GeneratedMerkleTreeCollection,
+    tdas: HashMap<Pubkey, Account>,
+    claimants: HashMap<Pubkey, Account>,
+    claim_status: HashMap<Pubkey, Account>,
+    micro_lamports: u64,
+    payer_pubkey: Pubkey,
+) -> Vec<Transaction> {
+    let tip_distribution_accounts: HashMap<Pubkey, TipDistributionAccount> = tdas
+        .iter()
+        .filter_map(|(pubkey, account)| {
+            Some((
+                *pubkey,
+                TipDistributionAccount::try_deserialize(&mut account.data.as_slice()).ok()?,
+            ))
+        })
+        .collect();
+
+    let claim_statuses: HashMap<Pubkey, ClaimStatus> = claim_status
+        .iter()
+        .filter_map(|(pubkey, account)| {
+            Some((
+                *pubkey,
+                ClaimStatus::try_deserialize(&mut account.data.as_slice()).ok()?,
+            ))
+        })
+        .collect();
+
+    datapoint_info!(
+        "build_mev_claim_transactions",
+        (
+            "tip_distribution_accounts",
+            tip_distribution_accounts.len(),
+            i64
+        ),
+        ("claim_statuses", claim_statuses.len(), i64),
+    );
+
+    let tip_distribution_config =
+        Pubkey::find_program_address(&[Config::SEED], &tip_distribution_program_id).0;
+
+    let mut instructions = Vec::with_capacity(claimants.len());
+    for tree in &merkle_trees.generated_merkle_trees {
+        if tree.max_total_claim == 0 {
+            continue;
+        }
+
+        // if unwrap panics, there's a bug in the merkle tree code because the merkle tree code relies on the state
+        // of the chain to claim.
+        let tip_distribution_account = tip_distribution_accounts
+            .get(&tree.tip_distribution_account)
+            .unwrap();
+
+        // can continue here, as there might be tip distribution accounts this account doesn't upload for
+        if tip_distribution_account.merkle_root.is_none() {
+            continue;
+        }
+
+        for node in &tree.tree_nodes {
+            // doesn't make sense to claim for claimants that don't exist anymore
+            // can't claim for something already claimed
+            // don't need to claim for claimants that get 0 MEV
+            if !claimants.contains_key(&node.claimant)
+                || claim_statuses.contains_key(&node.claim_status_pubkey)
+                || node.amount == 0
+            {
+                continue;
+            }
+
+            instructions.push(Instruction {
+                program_id: tip_distribution_program_id,
+                data: jito_tip_distribution::instruction::Claim {
+                    proof: node.proof.clone().unwrap(),
+                    amount: node.amount,
+                    bump: node.claim_status_bump,
+                }
+                .data(),
+                accounts: jito_tip_distribution::accounts::Claim {
+                    config: tip_distribution_config,
+                    tip_distribution_account: tree.tip_distribution_account,
+                    claimant: node.claimant,
+                    claim_status: node.claim_status_pubkey,
+                    payer: payer_pubkey,
+                    system_program: system_program::id(),
+                }
+                .to_account_metas(None),
+            });
+        }
+    }
+
+    // TODO (LB): see if we can do >1 claim here
+    let transactions: Vec<Transaction> = instructions
+        .into_iter()
+        .map(|claim_ix| {
+            let priority_fee_ix = ComputeBudgetInstruction::set_compute_unit_price(micro_lamports);
+            Transaction::new_with_payer(&[priority_fee_ix, claim_ix], Some(&payer_pubkey))
+        })
+        .collect();
+
+    transactions
+}
+
+/// heuristic to make sure we have enough funds to cover the rent costs if epoch has many validators
+/// If insufficient funds, returns start balance, desired balance, and amount of sol to deposit
+async fn is_sufficient_balance(
+    payer: &Pubkey,
+    rpc_client: &RpcClient,
+    instruction_count: u64,
+) -> Option<(u64, u64, u64)> {
+    let start_balance = rpc_client
+        .get_balance(payer)
+        .await
+        .expect("Failed to get starting balance");
+    // most amounts are for 0 lamports. had 1736 non-zero claims out of 164742
+    let min_rent_per_claim = rpc_client
+        .get_minimum_balance_for_rent_exemption(ClaimStatus::SIZE)
+        .await
+        .expect("Failed to calculate min rent");
+    let desired_balance = instruction_count
+        .checked_mul(
+            min_rent_per_claim
+                .checked_add(DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE)
+                .unwrap(),
+        )
+        .unwrap();
+    if start_balance < desired_balance {
+        let sol_to_deposit = desired_balance
+            .checked_sub(start_balance)
+            .unwrap()
+            .checked_add(LAMPORTS_PER_SOL)
+            .unwrap()
+            .checked_sub(1)
+            .unwrap()
+            .checked_div(LAMPORTS_PER_SOL)
+            .unwrap(); // rounds up to nearest sol
+        Some((start_balance, desired_balance, sol_to_deposit))
+    } else {
+        None
+    }
+}
diff --git a/tip-distributor/src/lib.rs b/tip-distributor/src/lib.rs
new file mode 100644
index 000000000000..8ee6b50f5d1d
--- /dev/null
+++ b/tip-distributor/src/lib.rs
@@ -0,0 +1,1062 @@
+pub mod claim_mev_workflow;
+pub mod merkle_root_generator_workflow;
+pub mod merkle_root_upload_workflow;
+pub mod reclaim_rent_workflow;
+pub mod stake_meta_generator_workflow;
+
+use {
+    crate::{
+        merkle_root_generator_workflow::MerkleRootGeneratorError,
+        stake_meta_generator_workflow::StakeMetaGeneratorError::CheckedMathError,
+    },
+    anchor_lang::Id,
+    jito_tip_distribution::{
+        program::JitoTipDistribution,
+        state::{ClaimStatus, TipDistributionAccount},
+    },
+    jito_tip_payment::{
+        Config, CONFIG_ACCOUNT_SEED, TIP_ACCOUNT_SEED_0, TIP_ACCOUNT_SEED_1, TIP_ACCOUNT_SEED_2,
+        TIP_ACCOUNT_SEED_3, TIP_ACCOUNT_SEED_4, TIP_ACCOUNT_SEED_5, TIP_ACCOUNT_SEED_6,
+        TIP_ACCOUNT_SEED_7,
+    },
+    log::*,
+    serde::{de::DeserializeOwned, Deserialize, Serialize},
+    solana_client::{
+        nonblocking::rpc_client::RpcClient,
+        rpc_client::{RpcClient as SyncRpcClient, SerializableTransaction},
+    },
+    solana_merkle_tree::MerkleTree,
+    solana_metrics::{datapoint_error, datapoint_warn},
+    solana_program::{
+        instruction::InstructionError,
+        rent::{
+            ACCOUNT_STORAGE_OVERHEAD, DEFAULT_EXEMPTION_THRESHOLD, DEFAULT_LAMPORTS_PER_BYTE_YEAR,
+        },
+    },
+    solana_rpc_client_api::{
+        client_error::{Error, ErrorKind},
+        config::RpcSendTransactionConfig,
+        request::{RpcError, RpcResponseErrorData, MAX_MULTIPLE_ACCOUNTS},
+        response::RpcSimulateTransactionResult,
+    },
+    solana_sdk::{
+        account::{Account, AccountSharedData, ReadableAccount},
+        clock::Slot,
+        commitment_config::{CommitmentConfig, CommitmentLevel},
+        hash::{Hash, Hasher},
+        pubkey::Pubkey,
+        signature::{Keypair, Signature},
+        stake_history::Epoch,
+        transaction::{
+            Transaction,
+            TransactionError::{self},
+        },
+    },
+    solana_transaction_status::TransactionStatus,
+    std::{
+        collections::{HashMap, HashSet},
+        fs::File,
+        io::BufReader,
+        path::PathBuf,
+        sync::Arc,
+        time::{Duration, Instant},
+    },
+    tokio::{sync::Semaphore, time::sleep},
+};
+
+#[derive(Clone, Deserialize, Serialize, Debug)]
+pub struct GeneratedMerkleTreeCollection {
+    pub generated_merkle_trees: Vec<GeneratedMerkleTree>,
+    pub bank_hash: String,
+    pub epoch: Epoch,
+    pub slot: Slot,
+}
+
+#[derive(Clone, Eq, Debug, Hash, PartialEq, Deserialize, Serialize)]
+pub struct GeneratedMerkleTree {
+    #[serde(with = "pubkey_string_conversion")]
+    pub tip_distribution_account: Pubkey,
+    #[serde(with = "pubkey_string_conversion")]
+    pub merkle_root_upload_authority: Pubkey,
+    pub merkle_root: Hash,
+    pub tree_nodes: Vec<TreeNode>,
+    pub max_total_claim: u64,
+    pub max_num_nodes: u64,
+}
+
+pub struct TipPaymentPubkeys {
+    config_pda: Pubkey,
+    tip_pdas: Vec<Pubkey>,
+}
+
+fn emit_inconsistent_tree_node_amount_dp(
+    tree_nodes: &[TreeNode],
+    tip_distribution_account: &Pubkey,
+    rpc_client: &SyncRpcClient,
+) {
+    let actual_claims: u64 = tree_nodes.iter().map(|t| t.amount).sum();
+    let tda = rpc_client.get_account(tip_distribution_account).unwrap();
+    let min_rent = rpc_client
+        .get_minimum_balance_for_rent_exemption(tda.data.len())
+        .unwrap();
+
+    let expected_claims = tda.lamports.checked_sub(min_rent).unwrap();
+    if actual_claims == expected_claims {
+        return;
+    }
+
+    if actual_claims > expected_claims {
+        datapoint_error!(
+            "tip-distributor",
+            (
+                "actual_claims_exceeded",
+                format!("tip_distribution_account={tip_distribution_account},actual_claims={actual_claims}, expected_claims={expected_claims}"),
+                String
+            ),
+        );
+    } else {
+        datapoint_warn!(
+            "tip-distributor",
+            (
+                "actual_claims_below",
+                format!("tip_distribution_account={tip_distribution_account},actual_claims={actual_claims}, expected_claims={expected_claims}"),
+                String
+            ),
+        );
+    }
+}
+
+impl GeneratedMerkleTreeCollection {
+    pub fn new_from_stake_meta_collection(
+        stake_meta_coll: StakeMetaCollection,
+        maybe_rpc_client: Option<SyncRpcClient>,
+    ) -> Result<GeneratedMerkleTreeCollection, MerkleRootGeneratorError> {
+        let generated_merkle_trees = stake_meta_coll
+            .stake_metas
+            .into_iter()
+            .filter(|stake_meta| stake_meta.maybe_tip_distribution_meta.is_some())
+            .filter_map(|stake_meta| {
+                let mut tree_nodes = match TreeNode::vec_from_stake_meta(&stake_meta) {
+                    Err(e) => return Some(Err(e)),
+                    Ok(maybe_tree_nodes) => maybe_tree_nodes,
+                }?;
+
+                if let Some(rpc_client) = &maybe_rpc_client {
+                    if let Some(tda) = stake_meta.maybe_tip_distribution_meta.as_ref() {
+                        emit_inconsistent_tree_node_amount_dp(
+                            &tree_nodes[..],
+                            &tda.tip_distribution_pubkey,
+                            rpc_client,
+                        );
+                    }
+                }
+
+                let hashed_nodes: Vec<[u8; 32]> =
+                    tree_nodes.iter().map(|n| n.hash().to_bytes()).collect();
+
+                let tip_distribution_meta = stake_meta.maybe_tip_distribution_meta.unwrap();
+
+                let merkle_tree = MerkleTree::new(&hashed_nodes[..], true);
+                let max_num_nodes = tree_nodes.len() as u64;
+
+                for (i, tree_node) in tree_nodes.iter_mut().enumerate() {
+                    tree_node.proof = Some(get_proof(&merkle_tree, i));
+                }
+
+                Some(Ok(GeneratedMerkleTree {
+                    max_num_nodes,
+                    tip_distribution_account: tip_distribution_meta.tip_distribution_pubkey,
+                    merkle_root_upload_authority: tip_distribution_meta
+                        .merkle_root_upload_authority,
+                    merkle_root: *merkle_tree.get_root().unwrap(),
+                    tree_nodes,
+                    max_total_claim: tip_distribution_meta.total_tips,
+                }))
+            })
+            .collect::<Result<Vec<GeneratedMerkleTree>, MerkleRootGeneratorError>>()?;
+
+        Ok(GeneratedMerkleTreeCollection {
+            generated_merkle_trees,
+            bank_hash: stake_meta_coll.bank_hash,
+            epoch: stake_meta_coll.epoch,
+            slot: stake_meta_coll.slot,
+        })
+    }
+}
+
+pub fn get_proof(merkle_tree: &MerkleTree, i: usize) -> Vec<[u8; 32]> {
+    let mut proof = Vec::new();
+    let path = merkle_tree.find_path(i).expect("path to index");
+    for branch in path.get_proof_entries() {
+        if let Some(hash) = branch.get_left_sibling() {
+            proof.push(hash.to_bytes());
+        } else if let Some(hash) = branch.get_right_sibling() {
+            proof.push(hash.to_bytes());
+        } else {
+            panic!("expected some hash at each level of the tree");
+        }
+    }
+    proof
+}
+
+fn derive_tip_payment_pubkeys(program_id: &Pubkey) -> TipPaymentPubkeys {
+    let config_pda = Pubkey::find_program_address(&[CONFIG_ACCOUNT_SEED], program_id).0;
+    let tip_pda_0 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_0], program_id).0;
+    let tip_pda_1 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_1], program_id).0;
+    let tip_pda_2 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_2], program_id).0;
+    let tip_pda_3 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_3], program_id).0;
+    let tip_pda_4 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_4], program_id).0;
+    let tip_pda_5 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_5], program_id).0;
+    let tip_pda_6 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_6], program_id).0;
+    let tip_pda_7 = Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_7], program_id).0;
+
+    TipPaymentPubkeys {
+        config_pda,
+        tip_pdas: vec![
+            tip_pda_0, tip_pda_1, tip_pda_2, tip_pda_3, tip_pda_4, tip_pda_5, tip_pda_6, tip_pda_7,
+        ],
+    }
+}
+
+#[derive(Clone, Eq, Debug, Hash, PartialEq, Deserialize, Serialize)]
+pub struct TreeNode {
+    /// The stake account entitled to redeem.
+    #[serde(with = "pubkey_string_conversion")]
+    pub claimant: Pubkey,
+
+    /// Pubkey of the ClaimStatus PDA account, this account should be closed to reclaim rent.
+    #[serde(with = "pubkey_string_conversion")]
+    pub claim_status_pubkey: Pubkey,
+
+    /// Bump of the ClaimStatus PDA account
+    pub claim_status_bump: u8,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub staker_pubkey: Pubkey,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub withdrawer_pubkey: Pubkey,
+
+    /// The amount this account is entitled to.
+    pub amount: u64,
+
+    /// The proof associated with this TreeNode
+    pub proof: Option<Vec<[u8; 32]>>,
+}
+
+impl TreeNode {
+    fn vec_from_stake_meta(
+        stake_meta: &StakeMeta,
+    ) -> Result<Option<Vec<TreeNode>>, MerkleRootGeneratorError> {
+        if let Some(tip_distribution_meta) = stake_meta.maybe_tip_distribution_meta.as_ref() {
+            let validator_amount = (tip_distribution_meta.total_tips as u128)
+                .checked_mul(tip_distribution_meta.validator_fee_bps as u128)
+                .unwrap()
+                .checked_div(10_000)
+                .unwrap() as u64;
+            let (claim_status_pubkey, claim_status_bump) = Pubkey::find_program_address(
+                &[
+                    ClaimStatus::SEED,
+                    &stake_meta.validator_vote_account.to_bytes(),
+                    &tip_distribution_meta.tip_distribution_pubkey.to_bytes(),
+                ],
+                &JitoTipDistribution::id(),
+            );
+            let mut tree_nodes = vec![TreeNode {
+                claimant: stake_meta.validator_vote_account,
+                claim_status_pubkey,
+                claim_status_bump,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: validator_amount,
+                proof: None,
+            }];
+
+            let remaining_total_rewards = tip_distribution_meta
+                .total_tips
+                .checked_sub(validator_amount)
+                .unwrap() as u128;
+
+            let total_delegated = stake_meta.total_delegated as u128;
+            tree_nodes.extend(
+                stake_meta
+                    .delegations
+                    .iter()
+                    .map(|delegation| {
+                        let amount_delegated = delegation.lamports_delegated as u128;
+                        let reward_amount = (amount_delegated.checked_mul(remaining_total_rewards))
+                            .unwrap()
+                            .checked_div(total_delegated)
+                            .unwrap();
+                        let (claim_status_pubkey, claim_status_bump) = Pubkey::find_program_address(
+                            &[
+                                ClaimStatus::SEED,
+                                &delegation.stake_account_pubkey.to_bytes(),
+                                &tip_distribution_meta.tip_distribution_pubkey.to_bytes(),
+                            ],
+                            &JitoTipDistribution::id(),
+                        );
+                        Ok(TreeNode {
+                            claimant: delegation.stake_account_pubkey,
+                            claim_status_pubkey,
+                            claim_status_bump,
+                            staker_pubkey: delegation.staker_pubkey,
+                            withdrawer_pubkey: delegation.withdrawer_pubkey,
+                            amount: reward_amount as u64,
+                            proof: None,
+                        })
+                    })
+                    .collect::<Result<Vec<TreeNode>, MerkleRootGeneratorError>>()?,
+            );
+
+            Ok(Some(tree_nodes))
+        } else {
+            Ok(None)
+        }
+    }
+
+    fn hash(&self) -> Hash {
+        let mut hasher = Hasher::default();
+        hasher.hash(self.claimant.as_ref());
+        hasher.hash(self.amount.to_le_bytes().as_ref());
+        hasher.result()
+    }
+}
+
+#[derive(Clone, Debug, Deserialize, Serialize)]
+pub struct StakeMetaCollection {
+    /// List of [StakeMeta].
+    pub stake_metas: Vec<StakeMeta>,
+
+    /// base58 encoded tip-distribution program id.
+    #[serde(with = "pubkey_string_conversion")]
+    pub tip_distribution_program_id: Pubkey,
+
+    /// Base58 encoded bank hash this object was generated at.
+    pub bank_hash: String,
+
+    /// Epoch for which this object was generated for.
+    pub epoch: Epoch,
+
+    /// Slot at which this object was generated.
+    pub slot: Slot,
+}
+
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
+pub struct StakeMeta {
+    #[serde(with = "pubkey_string_conversion")]
+    pub validator_vote_account: Pubkey,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub validator_node_pubkey: Pubkey,
+
+    /// The validator's tip-distribution meta if it exists.
+    pub maybe_tip_distribution_meta: Option<TipDistributionMeta>,
+
+    /// Delegations to this validator.
+    pub delegations: Vec<Delegation>,
+
+    /// The total amount of delegations to the validator.
+    pub total_delegated: u64,
+
+    /// The validator's delegation commission rate as a percentage between 0-100.
+    pub commission: u8,
+}
+
+impl Ord for StakeMeta {
+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
+        self.validator_vote_account
+            .cmp(&other.validator_vote_account)
+    }
+}
+
+impl PartialOrd<Self> for StakeMeta {
+    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
+pub struct TipDistributionMeta {
+    #[serde(with = "pubkey_string_conversion")]
+    pub merkle_root_upload_authority: Pubkey,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub tip_distribution_pubkey: Pubkey,
+
+    /// The validator's total tips in the [TipDistributionAccount].
+    pub total_tips: u64,
+
+    /// The validator's cut of tips from [TipDistributionAccount], calculated from the on-chain
+    /// commission fee bps.
+    pub validator_fee_bps: u16,
+}
+
+impl TipDistributionMeta {
+    fn from_tda_wrapper(
+        tda_wrapper: TipDistributionAccountWrapper,
+        // The amount that will be left remaining in the tda to maintain rent exemption status.
+        rent_exempt_amount: u64,
+    ) -> Result<Self, stake_meta_generator_workflow::StakeMetaGeneratorError> {
+        Ok(TipDistributionMeta {
+            tip_distribution_pubkey: tda_wrapper.tip_distribution_pubkey,
+            total_tips: tda_wrapper
+                .account_data
+                .lamports()
+                .checked_sub(rent_exempt_amount)
+                .ok_or(CheckedMathError)?,
+            validator_fee_bps: tda_wrapper
+                .tip_distribution_account
+                .validator_commission_bps,
+            merkle_root_upload_authority: tda_wrapper
+                .tip_distribution_account
+                .merkle_root_upload_authority,
+        })
+    }
+}
+
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
+pub struct Delegation {
+    #[serde(with = "pubkey_string_conversion")]
+    pub stake_account_pubkey: Pubkey,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub staker_pubkey: Pubkey,
+
+    #[serde(with = "pubkey_string_conversion")]
+    pub withdrawer_pubkey: Pubkey,
+
+    /// Lamports delegated by the stake account
+    pub lamports_delegated: u64,
+}
+
+impl Ord for Delegation {
+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
+        (
+            self.stake_account_pubkey,
+            self.withdrawer_pubkey,
+            self.staker_pubkey,
+            self.lamports_delegated,
+        )
+            .cmp(&(
+                other.stake_account_pubkey,
+                other.withdrawer_pubkey,
+                other.staker_pubkey,
+                other.lamports_delegated,
+            ))
+    }
+}
+
+impl PartialOrd<Self> for Delegation {
+    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
+/// Convenience wrapper around [TipDistributionAccount]
+pub struct TipDistributionAccountWrapper {
+    pub tip_distribution_account: TipDistributionAccount,
+    pub account_data: AccountSharedData,
+    pub tip_distribution_pubkey: Pubkey,
+}
+
+// TODO: move to program's sdk
+pub fn derive_tip_distribution_account_address(
+    tip_distribution_program_id: &Pubkey,
+    vote_pubkey: &Pubkey,
+    epoch: Epoch,
+) -> (Pubkey, u8) {
+    Pubkey::find_program_address(
+        &[
+            TipDistributionAccount::SEED,
+            vote_pubkey.to_bytes().as_ref(),
+            epoch.to_le_bytes().as_ref(),
+        ],
+        tip_distribution_program_id,
+    )
+}
+
+pub const MAX_RETRIES: usize = 5;
+pub const FAIL_DELAY: Duration = Duration::from_millis(100);
+
+pub async fn sign_and_send_transactions_with_retries(
+    signer: &Keypair,
+    rpc_client: &RpcClient,
+    max_concurrent_rpc_get_reqs: usize,
+    transactions: Vec<Transaction>,
+    txn_send_batch_size: usize,
+    max_loop_duration: Duration,
+) -> (Vec<Transaction>, HashMap<Signature, Error>) {
+    let semaphore = Arc::new(Semaphore::new(max_concurrent_rpc_get_reqs));
+    let mut errors = HashMap::default();
+    let mut blockhash = rpc_client
+        .get_latest_blockhash()
+        .await
+        .expect("fetch latest blockhash");
+    // track unsigned txns
+    let mut transactions_to_process = transactions
+        .into_iter()
+        .map(|txn| (txn.message_data(), txn))
+        .collect::<HashMap<Vec<u8>, Transaction>>();
+
+    let start = Instant::now();
+    while start.elapsed() < max_loop_duration && !transactions_to_process.is_empty() {
+        // ensure we always have a recent blockhash
+        // blockhashes last max 150 blocks
+        // finalized commitment is ~32 slots behind tip
+        // assuming 0% skip rate (every slot has a block), wed have roughly 120 slots
+        // or (120*0.4s) = 48s to land a tx before it expires
+        // if were refreshing every 30s, then any txs sent immediately before the refresh would likely expire
+        if start.elapsed() > Duration::from_secs(1) {
+            blockhash = rpc_client
+                .get_latest_blockhash()
+                .await
+                .expect("fetch latest blockhash");
+        }
+        info!(
+            "Sending {txn_send_batch_size} of {} transactions to claim mev tips",
+            transactions_to_process.len()
+        );
+        let send_futs = transactions_to_process
+            .iter()
+            .take(txn_send_batch_size)
+            .map(|(hash, txn)| {
+                let semaphore = semaphore.clone();
+                async move {
+                    let _permit = semaphore.acquire_owned().await.unwrap(); // wait until our turn
+                    let (txn, res) = signed_send(signer, rpc_client, blockhash, txn.clone()).await;
+                    (hash.clone(), txn, res)
+                }
+            });
+
+        let send_res = futures::future::join_all(send_futs).await;
+        let new_errors = send_res
+            .into_iter()
+            .filter_map(|(hash, txn, result)| match result {
+                Err(e) => Some((txn.signatures[0], e)),
+                Ok(..) => {
+                    let _ = transactions_to_process.remove(&hash);
+                    None
+                }
+            })
+            .collect::<HashMap<_, _>>();
+
+        errors.extend(new_errors);
+    }
+
+    (transactions_to_process.values().cloned().collect(), errors)
+}
+
+pub async fn send_until_blockhash_expires(
+    rpc_client: &RpcClient,
+    transactions: Vec<Transaction>,
+    blockhash: Hash,
+    keypair: &Arc<Keypair>,
+) -> solana_rpc_client_api::client_error::Result<()> {
+    let mut claim_transactions: HashMap<Signature, Transaction> = transactions
+        .into_iter()
+        .map(|mut tx| {
+            tx.sign(&[&keypair], blockhash);
+            (*tx.get_signature(), tx)
+        })
+        .collect();
+
+    let txs_requesting_send = claim_transactions.len();
+
+    while rpc_client
+        .is_blockhash_valid(&blockhash, CommitmentConfig::processed())
+        .await?
+    {
+        let mut check_signatures = HashSet::with_capacity(claim_transactions.len());
+        let mut already_processed = HashSet::with_capacity(claim_transactions.len());
+        let mut is_blockhash_not_found = false;
+
+        for (signature, tx) in &claim_transactions {
+            match rpc_client
+                .send_transaction_with_config(
+                    tx,
+                    RpcSendTransactionConfig {
+                        skip_preflight: false,
+                        preflight_commitment: Some(CommitmentLevel::Confirmed),
+                        max_retries: Some(2),
+                        ..RpcSendTransactionConfig::default()
+                    },
+                )
+                .await
+            {
+                Ok(_) => {
+                    check_signatures.insert(*signature);
+                }
+                Err(e) => match e.get_transaction_error() {
+                    Some(TransactionError::BlockhashNotFound) => {
+                        is_blockhash_not_found = true;
+                        break;
+                    }
+                    Some(TransactionError::AlreadyProcessed) => {
+                        already_processed.insert(*tx.get_signature());
+                    }
+                    Some(e) => {
+                        warn!(
+                            "TransactionError sending signature: {} error: {:?} tx: {:?}",
+                            tx.get_signature(),
+                            e,
+                            tx
+                        );
+                    }
+                    None => {
+                        warn!(
+                            "Unknown error sending transaction signature: {} error: {:?}",
+                            tx.get_signature(),
+                            e
+                        );
+                    }
+                },
+            }
+        }
+
+        sleep(Duration::from_secs(10)).await;
+
+        let signatures: Vec<Signature> = check_signatures.iter().cloned().collect();
+        let statuses = get_batched_signatures_statuses(rpc_client, &signatures).await?;
+
+        for (signature, maybe_status) in &statuses {
+            if let Some(_status) = maybe_status {
+                claim_transactions.remove(signature);
+                check_signatures.remove(signature);
+            }
+        }
+
+        for signature in already_processed {
+            claim_transactions.remove(&signature);
+        }
+
+        if claim_transactions.is_empty() || is_blockhash_not_found {
+            break;
+        }
+    }
+
+    let num_landed = txs_requesting_send
+        .checked_sub(claim_transactions.len())
+        .unwrap();
+    info!("num_landed: {:?}", num_landed);
+
+    Ok(())
+}
+
+pub async fn get_batched_signatures_statuses(
+    rpc_client: &RpcClient,
+    signatures: &[Signature],
+) -> solana_rpc_client_api::client_error::Result<Vec<(Signature, Option<TransactionStatus>)>> {
+    let mut signature_statuses = Vec::new();
+
+    for signatures_batch in signatures.chunks(100) {
+        // was using get_signature_statuses_with_history, but it blocks if the signatures don't exist
+        // bigtable calls to read signatures that don't exist block forever w/o --rpc-bigtable-timeout argument set
+        // get_signature_statuses looks in status_cache, which only has a 150 block history
+        // may have false negative, but for this workflow it doesn't matter
+        let statuses = rpc_client.get_signature_statuses(signatures_batch).await?;
+        signature_statuses.extend(signatures_batch.iter().cloned().zip(statuses.value));
+    }
+    Ok(signature_statuses)
+}
+
+/// Just in time sign and send transaction to RPC
+async fn signed_send(
+    signer: &Keypair,
+    rpc_client: &RpcClient,
+    blockhash: Hash,
+    mut txn: Transaction,
+) -> (Transaction, solana_rpc_client_api::client_error::Result<()>) {
+    txn.sign(&[signer], blockhash); // just in time signing
+    let res = match rpc_client.send_and_confirm_transaction(&txn).await {
+        Ok(_) => Ok(()),
+        Err(e) => {
+            match e.kind {
+                // Already claimed, skip.
+                ErrorKind::TransactionError(TransactionError::AlreadyProcessed)
+                | ErrorKind::TransactionError(TransactionError::InstructionError(
+                    0,
+                    InstructionError::Custom(0),
+                ))
+                | ErrorKind::RpcError(RpcError::RpcResponseError {
+                    data:
+                        RpcResponseErrorData::SendTransactionPreflightFailure(
+                            RpcSimulateTransactionResult {
+                                err:
+                                    Some(TransactionError::InstructionError(
+                                        0,
+                                        InstructionError::Custom(0),
+                                    )),
+                                ..
+                            },
+                        ),
+                    ..
+                }) => Ok(()),
+
+                // transaction got held up too long and blockhash expired. retry txn
+                ErrorKind::TransactionError(TransactionError::BlockhashNotFound) => Err(e),
+
+                // unexpected error, warn and retry
+                _ => {
+                    error!(
+                        "Error sending transaction. Signature: {}, Error: {e:?}",
+                        txn.signatures[0]
+                    );
+                    Err(e)
+                }
+            }
+        }
+    };
+
+    (txn, res)
+}
+
+async fn get_batched_accounts(
+    rpc_client: &RpcClient,
+    pubkeys: &[Pubkey],
+) -> solana_rpc_client_api::client_error::Result<HashMap<Pubkey, Option<Account>>> {
+    let mut batched_accounts = HashMap::new();
+
+    for pubkeys_chunk in pubkeys.chunks(MAX_MULTIPLE_ACCOUNTS) {
+        let accounts = rpc_client.get_multiple_accounts(pubkeys_chunk).await?;
+        batched_accounts.extend(pubkeys_chunk.iter().cloned().zip(accounts));
+    }
+    Ok(batched_accounts)
+}
+
+/// Calculates the minimum balance needed to be rent-exempt
+/// taken from: https://github.com/jito-foundation/jito-solana/blob/d1ba42180d0093dd59480a77132477323a8e3f88/sdk/program/src/rent.rs#L78
+pub fn minimum_balance(data_len: usize) -> u64 {
+    ((((ACCOUNT_STORAGE_OVERHEAD
+        .checked_add(data_len as u64)
+        .unwrap())
+    .checked_mul(DEFAULT_LAMPORTS_PER_BYTE_YEAR))
+    .unwrap() as f64)
+        * DEFAULT_EXEMPTION_THRESHOLD) as u64
+}
+
+mod pubkey_string_conversion {
+    use {
+        serde::{self, Deserialize, Deserializer, Serializer},
+        solana_sdk::pubkey::Pubkey,
+        std::str::FromStr,
+    };
+
+    pub(crate) fn serialize<S>(pubkey: &Pubkey, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.serialize_str(&pubkey.to_string())
+    }
+
+    pub(crate) fn deserialize<'de, D>(deserializer: D) -> Result<Pubkey, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let s = String::deserialize(deserializer)?;
+        Pubkey::from_str(&s).map_err(serde::de::Error::custom)
+    }
+}
+
+pub fn read_json_from_file<T>(path: &PathBuf) -> serde_json::Result<T>
+where
+    T: DeserializeOwned,
+{
+    let file = File::open(path).unwrap();
+    let reader = BufReader::new(file);
+    serde_json::from_reader(reader)
+}
+
+#[cfg(test)]
+mod tests {
+    use {super::*, jito_tip_distribution::merkle_proof};
+
+    #[test]
+    fn test_merkle_tree_verify() {
+        // Create the merkle tree and proofs
+        let tda = Pubkey::new_unique();
+        let (acct_0, acct_1) = (Pubkey::new_unique(), Pubkey::new_unique());
+        let claim_statuses = &[(acct_0, tda), (acct_1, tda)]
+            .iter()
+            .map(|(claimant, tda)| {
+                Pubkey::find_program_address(
+                    &[ClaimStatus::SEED, &claimant.to_bytes(), &tda.to_bytes()],
+                    &JitoTipDistribution::id(),
+                )
+            })
+            .collect::<Vec<(Pubkey, u8)>>();
+        let tree_nodes = vec![
+            TreeNode {
+                claimant: acct_0,
+                claim_status_pubkey: claim_statuses[0].0,
+                claim_status_bump: claim_statuses[0].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 151_507,
+                proof: None,
+            },
+            TreeNode {
+                claimant: acct_1,
+                claim_status_pubkey: claim_statuses[1].0,
+                claim_status_bump: claim_statuses[1].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 176_624,
+                proof: None,
+            },
+        ];
+
+        // First the nodes are hashed and merkle tree constructed
+        let hashed_nodes: Vec<[u8; 32]> = tree_nodes.iter().map(|n| n.hash().to_bytes()).collect();
+        let mk = MerkleTree::new(&hashed_nodes[..], true);
+        let root = mk.get_root().expect("to have valid root").to_bytes();
+
+        // verify first node
+        let node = solana_program::hash::hashv(&[&[0u8], &hashed_nodes[0]]);
+        let proof = get_proof(&mk, 0);
+        assert!(merkle_proof::verify(proof, root, node.to_bytes()));
+
+        // verify second node
+        let node = solana_program::hash::hashv(&[&[0u8], &hashed_nodes[1]]);
+        let proof = get_proof(&mk, 1);
+        assert!(merkle_proof::verify(proof, root, node.to_bytes()));
+    }
+
+    #[test]
+    fn test_new_from_stake_meta_collection_happy_path() {
+        let merkle_root_upload_authority = Pubkey::new_unique();
+
+        let (tda_0, tda_1) = (Pubkey::new_unique(), Pubkey::new_unique());
+
+        let stake_account_0 = Pubkey::new_unique();
+        let stake_account_1 = Pubkey::new_unique();
+        let stake_account_2 = Pubkey::new_unique();
+        let stake_account_3 = Pubkey::new_unique();
+
+        let staker_account_0 = Pubkey::new_unique();
+        let staker_account_1 = Pubkey::new_unique();
+        let staker_account_2 = Pubkey::new_unique();
+        let staker_account_3 = Pubkey::new_unique();
+
+        let validator_vote_account_0 = Pubkey::new_unique();
+        let validator_vote_account_1 = Pubkey::new_unique();
+
+        let validator_id_0 = Pubkey::new_unique();
+        let validator_id_1 = Pubkey::new_unique();
+
+        let stake_meta_collection = StakeMetaCollection {
+            stake_metas: vec![
+                StakeMeta {
+                    validator_vote_account: validator_vote_account_0,
+                    validator_node_pubkey: validator_id_0,
+                    maybe_tip_distribution_meta: Some(TipDistributionMeta {
+                        merkle_root_upload_authority,
+                        tip_distribution_pubkey: tda_0,
+                        total_tips: 1_900_122_111_000,
+                        validator_fee_bps: 100,
+                    }),
+                    delegations: vec![
+                        Delegation {
+                            stake_account_pubkey: stake_account_0,
+                            staker_pubkey: staker_account_0,
+                            withdrawer_pubkey: staker_account_0,
+                            lamports_delegated: 123_999_123_555,
+                        },
+                        Delegation {
+                            stake_account_pubkey: stake_account_1,
+                            staker_pubkey: staker_account_1,
+                            withdrawer_pubkey: staker_account_1,
+                            lamports_delegated: 144_555_444_556,
+                        },
+                    ],
+                    total_delegated: 1_555_123_000_333_454_000,
+                    commission: 100,
+                },
+                StakeMeta {
+                    validator_vote_account: validator_vote_account_1,
+                    validator_node_pubkey: validator_id_1,
+                    maybe_tip_distribution_meta: Some(TipDistributionMeta {
+                        merkle_root_upload_authority,
+                        tip_distribution_pubkey: tda_1,
+                        total_tips: 1_900_122_111_333,
+                        validator_fee_bps: 200,
+                    }),
+                    delegations: vec![
+                        Delegation {
+                            stake_account_pubkey: stake_account_2,
+                            staker_pubkey: staker_account_2,
+                            withdrawer_pubkey: staker_account_2,
+                            lamports_delegated: 224_555_444,
+                        },
+                        Delegation {
+                            stake_account_pubkey: stake_account_3,
+                            staker_pubkey: staker_account_3,
+                            withdrawer_pubkey: staker_account_3,
+                            lamports_delegated: 700_888_944_555,
+                        },
+                    ],
+                    total_delegated: 2_565_318_909_444_123,
+                    commission: 10,
+                },
+            ],
+            tip_distribution_program_id: Pubkey::new_unique(),
+            bank_hash: Hash::new_unique().to_string(),
+            epoch: 100,
+            slot: 2_000_000,
+        };
+
+        let merkle_tree_collection = GeneratedMerkleTreeCollection::new_from_stake_meta_collection(
+            stake_meta_collection.clone(),
+            None,
+        )
+        .unwrap();
+
+        assert_eq!(stake_meta_collection.epoch, merkle_tree_collection.epoch);
+        assert_eq!(
+            stake_meta_collection.bank_hash,
+            merkle_tree_collection.bank_hash
+        );
+        assert_eq!(stake_meta_collection.slot, merkle_tree_collection.slot);
+        assert_eq!(
+            stake_meta_collection.stake_metas.len(),
+            merkle_tree_collection.generated_merkle_trees.len()
+        );
+        let claim_statuses = &[
+            (validator_vote_account_0, tda_0),
+            (stake_account_0, tda_0),
+            (stake_account_1, tda_0),
+            (validator_vote_account_1, tda_1),
+            (stake_account_2, tda_1),
+            (stake_account_3, tda_1),
+        ]
+        .iter()
+        .map(|(claimant, tda)| {
+            Pubkey::find_program_address(
+                &[ClaimStatus::SEED, &claimant.to_bytes(), &tda.to_bytes()],
+                &JitoTipDistribution::id(),
+            )
+        })
+        .collect::<Vec<(Pubkey, u8)>>();
+        let tree_nodes = vec![
+            TreeNode {
+                claimant: validator_vote_account_0,
+                claim_status_pubkey: claim_statuses[0].0,
+                claim_status_bump: claim_statuses[0].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 19_001_221_110,
+                proof: None,
+            },
+            TreeNode {
+                claimant: stake_account_0,
+                claim_status_pubkey: claim_statuses[1].0,
+                claim_status_bump: claim_statuses[1].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 149_992,
+                proof: None,
+            },
+            TreeNode {
+                claimant: stake_account_1,
+                claim_status_pubkey: claim_statuses[2].0,
+                claim_status_bump: claim_statuses[2].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 174_858,
+                proof: None,
+            },
+        ];
+        let hashed_nodes: Vec<[u8; 32]> = tree_nodes.iter().map(|n| n.hash().to_bytes()).collect();
+        let merkle_tree = MerkleTree::new(&hashed_nodes[..], true);
+        let gmt_0 = GeneratedMerkleTree {
+            tip_distribution_account: tda_0,
+            merkle_root_upload_authority,
+            merkle_root: *merkle_tree.get_root().unwrap(),
+            tree_nodes,
+            max_total_claim: stake_meta_collection.stake_metas[0]
+                .clone()
+                .maybe_tip_distribution_meta
+                .unwrap()
+                .total_tips,
+            max_num_nodes: 3,
+        };
+
+        let tree_nodes = vec![
+            TreeNode {
+                claimant: validator_vote_account_1,
+                claim_status_pubkey: claim_statuses[3].0,
+                claim_status_bump: claim_statuses[3].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 38_002_442_226,
+                proof: None,
+            },
+            TreeNode {
+                claimant: stake_account_2,
+                claim_status_pubkey: claim_statuses[4].0,
+                claim_status_bump: claim_statuses[4].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 163_000,
+                proof: None,
+            },
+            TreeNode {
+                claimant: stake_account_3,
+                claim_status_pubkey: claim_statuses[5].0,
+                claim_status_bump: claim_statuses[5].1,
+                staker_pubkey: Pubkey::default(),
+                withdrawer_pubkey: Pubkey::default(),
+                amount: 508_762_900,
+                proof: None,
+            },
+        ];
+        let hashed_nodes: Vec<[u8; 32]> = tree_nodes.iter().map(|n| n.hash().to_bytes()).collect();
+        let merkle_tree = MerkleTree::new(&hashed_nodes[..], true);
+        let gmt_1 = GeneratedMerkleTree {
+            tip_distribution_account: tda_1,
+            merkle_root_upload_authority,
+            merkle_root: *merkle_tree.get_root().unwrap(),
+            tree_nodes,
+            max_total_claim: stake_meta_collection.stake_metas[1]
+                .clone()
+                .maybe_tip_distribution_meta
+                .unwrap()
+                .total_tips,
+            max_num_nodes: 3,
+        };
+
+        let expected_generated_merkle_trees = vec![gmt_0, gmt_1];
+        let actual_generated_merkle_trees = merkle_tree_collection.generated_merkle_trees;
+
+        expected_generated_merkle_trees
+            .iter()
+            .for_each(|expected_gmt| {
+                let actual_gmt = actual_generated_merkle_trees
+                    .iter()
+                    .find(|gmt| {
+                        gmt.tip_distribution_account == expected_gmt.tip_distribution_account
+                    })
+                    .unwrap();
+
+                assert_eq!(expected_gmt.max_num_nodes, actual_gmt.max_num_nodes);
+                assert_eq!(expected_gmt.max_total_claim, actual_gmt.max_total_claim);
+                assert_eq!(
+                    expected_gmt.tip_distribution_account,
+                    actual_gmt.tip_distribution_account
+                );
+                assert_eq!(expected_gmt.tree_nodes.len(), actual_gmt.tree_nodes.len());
+                expected_gmt
+                    .tree_nodes
+                    .iter()
+                    .for_each(|expected_tree_node| {
+                        let actual_tree_node = actual_gmt
+                            .tree_nodes
+                            .iter()
+                            .find(|tree_node| tree_node.claimant == expected_tree_node.claimant)
+                            .unwrap();
+                        assert_eq!(expected_tree_node.amount, actual_tree_node.amount);
+                    });
+                assert_eq!(expected_gmt.merkle_root, actual_gmt.merkle_root);
+            });
+    }
+}
diff --git a/tip-distributor/src/merkle_root_generator_workflow.rs b/tip-distributor/src/merkle_root_generator_workflow.rs
new file mode 100644
index 000000000000..bee3da016b54
--- /dev/null
+++ b/tip-distributor/src/merkle_root_generator_workflow.rs
@@ -0,0 +1,54 @@
+use {
+    crate::{read_json_from_file, GeneratedMerkleTreeCollection, StakeMetaCollection},
+    log::*,
+    solana_client::rpc_client::RpcClient,
+    std::{
+        fmt::Debug,
+        fs::File,
+        io::{BufWriter, Write},
+        path::PathBuf,
+    },
+    thiserror::Error,
+};
+
+#[derive(Error, Debug)]
+pub enum MerkleRootGeneratorError {
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+
+    #[error(transparent)]
+    RpcError(#[from] Box<solana_client::client_error::ClientError>),
+
+    #[error(transparent)]
+    SerdeJsonError(#[from] serde_json::Error),
+}
+
+pub fn generate_merkle_root(
+    stake_meta_coll_path: &PathBuf,
+    out_path: &PathBuf,
+    rpc_url: &str,
+) -> Result<(), MerkleRootGeneratorError> {
+    let stake_meta_coll: StakeMetaCollection = read_json_from_file(stake_meta_coll_path)?;
+
+    let rpc_client = RpcClient::new(rpc_url);
+    let merkle_tree_coll = GeneratedMerkleTreeCollection::new_from_stake_meta_collection(
+        stake_meta_coll,
+        Some(rpc_client),
+    )?;
+
+    write_to_json_file(&merkle_tree_coll, out_path)?;
+    Ok(())
+}
+
+fn write_to_json_file(
+    merkle_tree_coll: &GeneratedMerkleTreeCollection,
+    file_path: &PathBuf,
+) -> Result<(), MerkleRootGeneratorError> {
+    let file = File::create(file_path)?;
+    let mut writer = BufWriter::new(file);
+    let json = serde_json::to_string_pretty(&merkle_tree_coll).unwrap();
+    writer.write_all(json.as_bytes())?;
+    writer.flush()?;
+
+    Ok(())
+}
diff --git a/tip-distributor/src/merkle_root_upload_workflow.rs b/tip-distributor/src/merkle_root_upload_workflow.rs
new file mode 100644
index 000000000000..e40465581f62
--- /dev/null
+++ b/tip-distributor/src/merkle_root_upload_workflow.rs
@@ -0,0 +1,138 @@
+use {
+    crate::{
+        read_json_from_file, sign_and_send_transactions_with_retries, GeneratedMerkleTree,
+        GeneratedMerkleTreeCollection,
+    },
+    anchor_lang::AccountDeserialize,
+    jito_tip_distribution::{
+        sdk::instruction::{upload_merkle_root_ix, UploadMerkleRootAccounts, UploadMerkleRootArgs},
+        state::{Config, TipDistributionAccount},
+    },
+    log::{error, info},
+    solana_client::nonblocking::rpc_client::RpcClient,
+    solana_program::{
+        fee_calculator::DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE, native_token::LAMPORTS_PER_SOL,
+    },
+    solana_sdk::{
+        commitment_config::CommitmentConfig,
+        pubkey::Pubkey,
+        signature::{read_keypair_file, Signer},
+        transaction::Transaction,
+    },
+    std::{path::PathBuf, time::Duration},
+    thiserror::Error,
+    tokio::runtime::Builder,
+};
+
+#[derive(Error, Debug)]
+pub enum MerkleRootUploadError {
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+
+    #[error(transparent)]
+    JsonError(#[from] serde_json::Error),
+}
+
+pub fn upload_merkle_root(
+    merkle_root_path: &PathBuf,
+    keypair_path: &PathBuf,
+    rpc_url: &str,
+    tip_distribution_program_id: &Pubkey,
+    max_concurrent_rpc_get_reqs: usize,
+    txn_send_batch_size: usize,
+) -> Result<(), MerkleRootUploadError> {
+    const MAX_RETRY_DURATION: Duration = Duration::from_secs(600);
+
+    let merkle_tree: GeneratedMerkleTreeCollection =
+        read_json_from_file(merkle_root_path).expect("read GeneratedMerkleTreeCollection");
+    let keypair = read_keypair_file(keypair_path).expect("read keypair file");
+
+    let tip_distribution_config =
+        Pubkey::find_program_address(&[Config::SEED], tip_distribution_program_id).0;
+
+    let runtime = Builder::new_multi_thread()
+        .worker_threads(16)
+        .enable_all()
+        .build()
+        .expect("build runtime");
+
+    runtime.block_on(async move {
+        let rpc_client =
+            RpcClient::new_with_commitment(rpc_url.to_string(), CommitmentConfig::confirmed());
+        let trees: Vec<GeneratedMerkleTree> = merkle_tree
+            .generated_merkle_trees
+            .into_iter()
+            .filter(|tree| tree.merkle_root_upload_authority == keypair.pubkey())
+            .collect();
+
+        info!("num trees to upload: {:?}", trees.len());
+
+        // heuristic to make sure we have enough funds to cover execution, assumes all trees need updating 
+        {
+            let initial_balance = rpc_client.get_balance(&keypair.pubkey()).await.expect("failed to get balance");
+            let desired_balance = (trees.len() as u64).checked_mul(DEFAULT_TARGET_LAMPORTS_PER_SIGNATURE).unwrap();
+            if initial_balance < desired_balance {
+                let sol_to_deposit = desired_balance.checked_sub(initial_balance).unwrap().checked_add(LAMPORTS_PER_SOL).unwrap().checked_sub(1).unwrap().checked_div(LAMPORTS_PER_SOL).unwrap(); // rounds up to nearest sol
+                panic!("Expected to have at least {} lamports in {}, current balance is {} lamports, deposit {} SOL to continue.",
+                       desired_balance, &keypair.pubkey(), initial_balance, sol_to_deposit)
+            }
+        }
+        let mut trees_needing_update: Vec<GeneratedMerkleTree> = vec![];
+        for tree in trees {
+            let account = rpc_client
+                .get_account(&tree.tip_distribution_account)
+                .await
+                .expect("fetch expect");
+
+            let mut data = account.data.as_slice();
+            let fetched_tip_distribution_account =
+                TipDistributionAccount::try_deserialize(&mut data)
+                    .expect("failed to deserialize tip_distribution_account state");
+
+            let needs_upload = match fetched_tip_distribution_account.merkle_root {
+                Some(merkle_root) => {
+                    merkle_root.total_funds_claimed == 0
+                        && merkle_root.root != tree.merkle_root.to_bytes()
+                }
+                None => true,
+            };
+
+            if needs_upload {
+                trees_needing_update.push(tree);
+            }
+        }
+
+        info!("num trees need uploading: {:?}", trees_needing_update.len());
+
+        let transactions: Vec<Transaction> = trees_needing_update
+            .iter()
+            .map(|tree| {
+                let ix = upload_merkle_root_ix(
+                    *tip_distribution_program_id,
+                    UploadMerkleRootArgs {
+                        root: tree.merkle_root.to_bytes(),
+                        max_total_claim: tree.max_total_claim,
+                        max_num_nodes: tree.max_num_nodes,
+                    },
+                    UploadMerkleRootAccounts {
+                        config: tip_distribution_config,
+                        merkle_root_upload_authority: keypair.pubkey(),
+                        tip_distribution_account: tree.tip_distribution_account,
+                    },
+                );
+                Transaction::new_with_payer(
+                    &[ix],
+                    Some(&keypair.pubkey()),
+                )
+            })
+            .collect();
+
+        let (to_process, failed_transactions) = sign_and_send_transactions_with_retries(
+            &keypair, &rpc_client, max_concurrent_rpc_get_reqs, transactions, txn_send_batch_size, MAX_RETRY_DURATION).await;
+        if !to_process.is_empty() {
+            panic!("{} remaining mev claim transactions, {} failed requests.", to_process.len(), failed_transactions.len());
+        }
+    });
+
+    Ok(())
+}
diff --git a/tip-distributor/src/reclaim_rent_workflow.rs b/tip-distributor/src/reclaim_rent_workflow.rs
new file mode 100644
index 000000000000..fc48c89d61bf
--- /dev/null
+++ b/tip-distributor/src/reclaim_rent_workflow.rs
@@ -0,0 +1,310 @@
+use {
+    crate::{
+        claim_mev_workflow::ClaimMevError, get_batched_accounts,
+        reclaim_rent_workflow::ClaimMevError::AnchorError, send_until_blockhash_expires,
+    },
+    anchor_lang::AccountDeserialize,
+    jito_tip_distribution::{
+        sdk::{
+            derive_config_account_address,
+            instruction::{
+                close_claim_status_ix, close_tip_distribution_account_ix, CloseClaimStatusAccounts,
+                CloseClaimStatusArgs, CloseTipDistributionAccountArgs,
+                CloseTipDistributionAccounts,
+            },
+        },
+        state::{ClaimStatus, Config, TipDistributionAccount},
+    },
+    log::{info, warn},
+    rand::{prelude::SliceRandom, thread_rng},
+    solana_client::nonblocking::rpc_client::RpcClient,
+    solana_metrics::datapoint_info,
+    solana_program::{clock::Epoch, pubkey::Pubkey},
+    solana_rpc_client_api::config::RpcSimulateTransactionConfig,
+    solana_sdk::{
+        account::Account,
+        commitment_config::CommitmentConfig,
+        compute_budget::ComputeBudgetInstruction,
+        signature::{Keypair, Signer},
+        transaction::Transaction,
+    },
+    std::{
+        sync::Arc,
+        time::{Duration, Instant},
+    },
+};
+
+/// Clear old ClaimStatus accounts
+pub async fn reclaim_rent(
+    rpc_url: String,
+    tip_distribution_program_id: Pubkey,
+    signer: Arc<Keypair>,
+    max_loop_duration: Duration,
+    // Optionally reclaim TipDistributionAccount rents on behalf of validators.
+    should_reclaim_tdas: bool,
+    micro_lamports: u64,
+) -> Result<(), ClaimMevError> {
+    let rpc_client = RpcClient::new_with_timeout_and_commitment(
+        rpc_url.clone(),
+        Duration::from_secs(300),
+        CommitmentConfig::processed(),
+    );
+
+    let start = Instant::now();
+
+    let accounts = rpc_client
+        .get_program_accounts(&tip_distribution_program_id)
+        .await?;
+
+    let config_pubkey = derive_config_account_address(&tip_distribution_program_id).0;
+    let config_account = rpc_client.get_account(&config_pubkey).await?;
+    let config_account =
+        Config::try_deserialize(&mut config_account.data.as_slice()).map_err(AnchorError)?;
+
+    let epoch = rpc_client.get_epoch_info().await?.epoch;
+    let mut claim_status_pubkeys_to_expire =
+        find_expired_claim_status_accounts(&accounts, epoch, signer.pubkey());
+    let mut tda_pubkeys_to_expire = find_expired_tda_accounts(&accounts, epoch);
+
+    while start.elapsed() <= max_loop_duration {
+        let mut transactions = build_close_claim_status_transactions(
+            &claim_status_pubkeys_to_expire,
+            tip_distribution_program_id,
+            config_pubkey,
+            micro_lamports,
+            signer.pubkey(),
+        );
+        if should_reclaim_tdas {
+            transactions.extend(build_close_tda_transactions(
+                &tda_pubkeys_to_expire,
+                tip_distribution_program_id,
+                config_pubkey,
+                &config_account,
+                signer.pubkey(),
+            ));
+        }
+
+        datapoint_info!(
+            "claim_mev_workflow-prepare_rent_reclaim_transactions",
+            ("transaction_count", transactions.len(), i64),
+        );
+
+        if transactions.is_empty() {
+            info!("Finished reclaim rent!");
+            return Ok(());
+        }
+
+        transactions.shuffle(&mut thread_rng());
+        let transactions: Vec<_> = transactions.into_iter().take(10_000).collect();
+        let blockhash = rpc_client.get_latest_blockhash().await?;
+        send_until_blockhash_expires(&rpc_client, transactions, blockhash, &signer).await?;
+
+        // can just refresh calling get_multiple_accounts since these operations should be subtractive and not additive
+        let claim_status_pubkeys: Vec<_> = claim_status_pubkeys_to_expire
+            .iter()
+            .map(|(pubkey, _)| *pubkey)
+            .collect();
+        claim_status_pubkeys_to_expire = get_batched_accounts(&rpc_client, &claim_status_pubkeys)
+            .await?
+            .into_iter()
+            .filter_map(|(pubkey, account)| Some((pubkey, account?)))
+            .collect();
+
+        let tda_pubkeys: Vec<_> = tda_pubkeys_to_expire
+            .iter()
+            .map(|(pubkey, _)| *pubkey)
+            .collect();
+        tda_pubkeys_to_expire = get_batched_accounts(&rpc_client, &tda_pubkeys)
+            .await?
+            .into_iter()
+            .filter_map(|(pubkey, account)| Some((pubkey, account?)))
+            .collect();
+    }
+
+    // one final refresh before double checking everything
+    let claim_status_pubkeys: Vec<_> = claim_status_pubkeys_to_expire
+        .iter()
+        .map(|(pubkey, _)| *pubkey)
+        .collect();
+    claim_status_pubkeys_to_expire = get_batched_accounts(&rpc_client, &claim_status_pubkeys)
+        .await?
+        .into_iter()
+        .filter_map(|(pubkey, account)| Some((pubkey, account?)))
+        .collect();
+
+    let tda_pubkeys: Vec<_> = tda_pubkeys_to_expire
+        .iter()
+        .map(|(pubkey, _)| *pubkey)
+        .collect();
+    tda_pubkeys_to_expire = get_batched_accounts(&rpc_client, &tda_pubkeys)
+        .await?
+        .into_iter()
+        .filter_map(|(pubkey, account)| Some((pubkey, account?)))
+        .collect();
+
+    let mut transactions = build_close_claim_status_transactions(
+        &claim_status_pubkeys_to_expire,
+        tip_distribution_program_id,
+        config_pubkey,
+        micro_lamports,
+        signer.pubkey(),
+    );
+    if should_reclaim_tdas {
+        transactions.extend(build_close_tda_transactions(
+            &tda_pubkeys_to_expire,
+            tip_distribution_program_id,
+            config_pubkey,
+            &config_account,
+            signer.pubkey(),
+        ));
+    }
+
+    if transactions.is_empty() {
+        return Ok(());
+    }
+
+    // if more transactions left, we'll simulate them all to make sure its not an uncaught error
+    let mut is_error = false;
+    let mut error_str = String::new();
+    for tx in &transactions {
+        match rpc_client
+            .simulate_transaction_with_config(
+                tx,
+                RpcSimulateTransactionConfig {
+                    sig_verify: false,
+                    replace_recent_blockhash: true,
+                    commitment: Some(CommitmentConfig::processed()),
+                    ..RpcSimulateTransactionConfig::default()
+                },
+            )
+            .await
+        {
+            Ok(_) => {}
+            Err(e) => {
+                error_str = e.to_string();
+                is_error = true;
+
+                match e.get_transaction_error() {
+                    None => {
+                        break;
+                    }
+                    Some(e) => {
+                        warn!("transaction error. tx: {:?} error: {:?}", tx, e);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    if is_error {
+        Err(ClaimMevError::UncaughtError { e: error_str })
+    } else {
+        Err(ClaimMevError::NotFinished {
+            transactions_left: transactions.len(),
+        })
+    }
+}
+
+fn find_expired_claim_status_accounts(
+    accounts: &[(Pubkey, Account)],
+    epoch: Epoch,
+    payer: Pubkey,
+) -> Vec<(Pubkey, Account)> {
+    accounts
+        .iter()
+        .filter_map(|(pubkey, account)| {
+            let claim_status = ClaimStatus::try_deserialize(&mut account.data.as_slice()).ok()?;
+            if claim_status.claim_status_payer.eq(&payer) && epoch > claim_status.expires_at {
+                Some((*pubkey, account.clone()))
+            } else {
+                None
+            }
+        })
+        .collect()
+}
+
+fn find_expired_tda_accounts(
+    accounts: &[(Pubkey, Account)],
+    epoch: Epoch,
+) -> Vec<(Pubkey, Account)> {
+    accounts
+        .iter()
+        .filter_map(|(pubkey, account)| {
+            let tda = TipDistributionAccount::try_deserialize(&mut account.data.as_slice()).ok()?;
+            if epoch > tda.expires_at {
+                Some((*pubkey, account.clone()))
+            } else {
+                None
+            }
+        })
+        .collect()
+}
+
+/// Assumes accounts is already pre-filtered with checks to ensure the account can be closed
+fn build_close_claim_status_transactions(
+    accounts: &[(Pubkey, Account)],
+    tip_distribution_program_id: Pubkey,
+    config: Pubkey,
+    microlamports: u64,
+    payer: Pubkey,
+) -> Vec<Transaction> {
+    accounts
+        .iter()
+        .map(|(claim_status_pubkey, account)| {
+            let claim_status = ClaimStatus::try_deserialize(&mut account.data.as_slice()).unwrap();
+            close_claim_status_ix(
+                tip_distribution_program_id,
+                CloseClaimStatusArgs,
+                CloseClaimStatusAccounts {
+                    config,
+                    claim_status: *claim_status_pubkey,
+                    claim_status_payer: claim_status.claim_status_payer,
+                },
+            )
+        })
+        .collect::<Vec<_>>()
+        .chunks(4)
+        .map(|close_claim_status_instructions| {
+            let mut instructions = vec![ComputeBudgetInstruction::set_compute_unit_price(
+                microlamports,
+            )];
+            instructions.extend(close_claim_status_instructions.to_vec());
+            Transaction::new_with_payer(&instructions, Some(&payer))
+        })
+        .collect()
+}
+
+fn build_close_tda_transactions(
+    accounts: &[(Pubkey, Account)],
+    tip_distribution_program_id: Pubkey,
+    config_pubkey: Pubkey,
+    config: &Config,
+    payer: Pubkey,
+) -> Vec<Transaction> {
+    let instructions: Vec<_> = accounts
+        .iter()
+        .map(|(pubkey, account)| {
+            let tda =
+                TipDistributionAccount::try_deserialize(&mut account.data.as_slice()).unwrap();
+            close_tip_distribution_account_ix(
+                tip_distribution_program_id,
+                CloseTipDistributionAccountArgs {
+                    _epoch: tda.epoch_created_at,
+                },
+                CloseTipDistributionAccounts {
+                    config: config_pubkey,
+                    tip_distribution_account: *pubkey,
+                    validator_vote_account: tda.validator_vote_account,
+                    expired_funds_account: config.expired_funds_account,
+                    signer: payer,
+                },
+            )
+        })
+        .collect();
+
+    instructions
+        .chunks(4)
+        .map(|ix_chunk| Transaction::new_with_payer(ix_chunk, Some(&payer)))
+        .collect()
+}
diff --git a/tip-distributor/src/stake_meta_generator_workflow.rs b/tip-distributor/src/stake_meta_generator_workflow.rs
new file mode 100644
index 000000000000..9616154c093c
--- /dev/null
+++ b/tip-distributor/src/stake_meta_generator_workflow.rs
@@ -0,0 +1,973 @@
+use {
+    crate::{
+        derive_tip_distribution_account_address, derive_tip_payment_pubkeys, Config, StakeMeta,
+        StakeMetaCollection, TipDistributionAccount, TipDistributionAccountWrapper,
+        TipDistributionMeta,
+    },
+    anchor_lang::AccountDeserialize,
+    itertools::Itertools,
+    log::*,
+    solana_accounts_db::hardened_unpack::{
+        open_genesis_config, OpenGenesisConfigError, MAX_GENESIS_ARCHIVE_UNPACKED_SIZE,
+    },
+    solana_client::client_error::ClientError,
+    solana_ledger::{
+        bank_forks_utils,
+        bank_forks_utils::BankForksUtilsError,
+        blockstore::{Blockstore, BlockstoreError},
+        blockstore_options::{AccessType, BlockstoreOptions, LedgerColumnOptions},
+        blockstore_processor::{BlockstoreProcessorError, ProcessOptions},
+    },
+    solana_program::{stake_history::StakeHistory, sysvar},
+    solana_runtime::{bank::Bank, snapshot_config::SnapshotConfig, stakes::StakeAccount},
+    solana_sdk::{
+        account::{from_account, ReadableAccount, WritableAccount},
+        clock::Slot,
+        pubkey::Pubkey,
+    },
+    solana_vote::vote_account::VoteAccount,
+    std::{
+        collections::HashMap,
+        fmt::{Debug, Display, Formatter},
+        fs::File,
+        io::{BufWriter, Write},
+        mem::size_of,
+        path::{Path, PathBuf},
+        sync::{atomic::AtomicBool, Arc},
+    },
+    thiserror::Error,
+};
+
+#[derive(Error, Debug)]
+pub enum StakeMetaGeneratorError {
+    #[error(transparent)]
+    AnchorError(#[from] Box<anchor_lang::error::Error>),
+
+    #[error(transparent)]
+    BlockstoreError(#[from] BlockstoreError),
+
+    #[error(transparent)]
+    BlockstoreProcessorError(#[from] BlockstoreProcessorError),
+
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+
+    CheckedMathError,
+
+    #[error(transparent)]
+    RpcError(#[from] ClientError),
+
+    #[error(transparent)]
+    SerdeJsonError(#[from] serde_json::Error),
+
+    SnapshotSlotNotFound,
+
+    BankForksUtilsError(#[from] BankForksUtilsError),
+
+    GenesisConfigError(#[from] OpenGenesisConfigError),
+}
+
+impl Display for StakeMetaGeneratorError {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        Debug::fmt(&self, f)
+    }
+}
+
+/// Runs the entire workflow of creating a bank from a snapshot to writing stake meta-data
+/// to a JSON file.
+pub fn generate_stake_meta(
+    ledger_path: &Path,
+    snapshot_slot: &Slot,
+    tip_distribution_program_id: &Pubkey,
+    out_path: &str,
+    tip_payment_program_id: &Pubkey,
+) -> Result<(), StakeMetaGeneratorError> {
+    info!("Creating bank from ledger path...");
+    let bank = create_bank_from_snapshot(ledger_path, snapshot_slot)?;
+
+    info!("Generating stake_meta_collection object...");
+    let stake_meta_coll =
+        generate_stake_meta_collection(&bank, tip_distribution_program_id, tip_payment_program_id)?;
+
+    info!("Writing stake_meta_collection to JSON {}...", out_path);
+    write_to_json_file(&stake_meta_coll, out_path)?;
+
+    Ok(())
+}
+
+fn create_bank_from_snapshot(
+    ledger_path: &Path,
+    snapshot_slot: &Slot,
+) -> Result<Arc<Bank>, StakeMetaGeneratorError> {
+    let genesis_config = open_genesis_config(ledger_path, MAX_GENESIS_ARCHIVE_UNPACKED_SIZE)?;
+    let snapshot_config = SnapshotConfig {
+        full_snapshot_archive_interval_slots: Slot::MAX,
+        incremental_snapshot_archive_interval_slots: Slot::MAX,
+        full_snapshot_archives_dir: PathBuf::from(ledger_path),
+        incremental_snapshot_archives_dir: PathBuf::from(ledger_path),
+        bank_snapshots_dir: PathBuf::from(ledger_path),
+        ..SnapshotConfig::default()
+    };
+    let blockstore = Blockstore::open_with_options(
+        ledger_path,
+        BlockstoreOptions {
+            access_type: AccessType::PrimaryForMaintenance,
+            recovery_mode: None,
+            enforce_ulimit_nofile: false,
+            column_options: LedgerColumnOptions::default(),
+        },
+    )?;
+    let (bank_forks, _, _) = bank_forks_utils::load_bank_forks(
+        &genesis_config,
+        &blockstore,
+        vec![PathBuf::from(ledger_path).join(Path::new("stake-meta.accounts"))],
+        Some(&snapshot_config),
+        &ProcessOptions::default(),
+        None,
+        None,
+        None,
+        Arc::new(AtomicBool::new(false)),
+        false,
+    )?;
+
+    let working_bank = bank_forks.read().unwrap().working_bank();
+    assert_eq!(
+        working_bank.slot(),
+        *snapshot_slot,
+        "expected working bank slot {}, found {}",
+        snapshot_slot,
+        working_bank.slot()
+    );
+
+    Ok(working_bank)
+}
+
+fn write_to_json_file(
+    stake_meta_coll: &StakeMetaCollection,
+    out_path: &str,
+) -> Result<(), StakeMetaGeneratorError> {
+    let file = File::create(out_path)?;
+    let mut writer = BufWriter::new(file);
+    let json = serde_json::to_string_pretty(&stake_meta_coll).unwrap();
+    writer.write_all(json.as_bytes())?;
+    writer.flush()?;
+
+    Ok(())
+}
+
+/// Creates a collection of [StakeMeta]'s from the given bank.
+pub fn generate_stake_meta_collection(
+    bank: &Arc<Bank>,
+    tip_distribution_program_id: &Pubkey,
+    tip_payment_program_id: &Pubkey,
+) -> Result<StakeMetaCollection, StakeMetaGeneratorError> {
+    assert!(bank.is_frozen());
+
+    let epoch_vote_accounts = bank.epoch_vote_accounts(bank.epoch()).unwrap_or_else(|| {
+        panic!(
+            "No epoch_vote_accounts found for slot {} at epoch {}",
+            bank.slot(),
+            bank.epoch()
+        )
+    });
+
+    let l_stakes = bank.stakes_cache.stakes();
+    let delegations = l_stakes.stake_delegations();
+
+    let voter_pubkey_to_delegations = group_delegations_by_voter_pubkey(delegations, bank);
+
+    // the last leader in an epoch may not crank the tip program before the epoch is over, which
+    // would result in MEV rewards for epoch N not being cranked until epoch N + 1. This means that
+    // the account balance in the snapshot could be incorrect.
+    // We assume that the rewards sitting in the tip program PDAs are cranked out by the time all of
+    // the rewards are claimed.
+    let tip_accounts = derive_tip_payment_pubkeys(tip_payment_program_id);
+    let account = bank
+        .get_account(&tip_accounts.config_pda)
+        .expect("config pda exists");
+
+    let config = Config::try_deserialize(&mut account.data()).expect("deserializes configuration");
+
+    let bb_commission_pct: u64 = config.block_builder_commission_pct;
+    let tip_receiver: Pubkey = config.tip_receiver;
+
+    // includes the block builder fee
+    let excess_tip_balances: u64 = tip_accounts
+        .tip_pdas
+        .iter()
+        .map(|pubkey| {
+            let tip_account = bank.get_account(pubkey).expect("tip account exists");
+            tip_account
+                .lamports()
+                .checked_sub(bank.get_minimum_balance_for_rent_exemption(tip_account.data().len()))
+                .expect("tip balance underflow")
+        })
+        .sum();
+    // matches math in tip payment program
+    let block_builder_tips = excess_tip_balances
+        .checked_mul(bb_commission_pct)
+        .expect("block_builder_tips overflow")
+        .checked_div(100)
+        .expect("block_builder_tips division error");
+    let tip_receiver_fee = excess_tip_balances
+        .checked_sub(block_builder_tips)
+        .expect("tip_receiver_fee doesnt underflow");
+
+    let vote_pk_and_maybe_tdas: Vec<(
+        (Pubkey, &VoteAccount),
+        Option<TipDistributionAccountWrapper>,
+    )> = epoch_vote_accounts
+        .iter()
+        .map(|(vote_pubkey, (_total_stake, vote_account))| {
+            let tip_distribution_pubkey = derive_tip_distribution_account_address(
+                tip_distribution_program_id,
+                vote_pubkey,
+                bank.epoch(),
+            )
+            .0;
+            let tda = if let Some(mut account_data) = bank.get_account(&tip_distribution_pubkey) {
+                // TDAs may be funded with lamports and therefore exist in the bank, but would fail the deserialization step
+                // if the buffer is yet to be allocated thru the init call to the program.
+                if let Ok(tip_distribution_account) =
+                    TipDistributionAccount::try_deserialize(&mut account_data.data())
+                {
+                    // this snapshot might have tips that weren't claimed by the time the epoch is over
+                    // assume that it will eventually be cranked and credit the excess to this account
+                    if tip_distribution_pubkey == tip_receiver {
+                        account_data.set_lamports(
+                            account_data
+                                .lamports()
+                                .checked_add(tip_receiver_fee)
+                                .expect("tip overflow"),
+                        );
+                    }
+                    Some(TipDistributionAccountWrapper {
+                        tip_distribution_account,
+                        account_data,
+                        tip_distribution_pubkey,
+                    })
+                } else {
+                    None
+                }
+            } else {
+                None
+            };
+            Ok(((*vote_pubkey, vote_account), tda))
+        })
+        .collect::<Result<_, StakeMetaGeneratorError>>()?;
+
+    let mut stake_metas = vec![];
+    for ((vote_pubkey, vote_account), maybe_tda) in vote_pk_and_maybe_tdas {
+        if let Some(mut delegations) = voter_pubkey_to_delegations.get(&vote_pubkey).cloned() {
+            let total_delegated = delegations.iter().fold(0u64, |sum, delegation| {
+                sum.checked_add(delegation.lamports_delegated).unwrap()
+            });
+
+            let maybe_tip_distribution_meta = if let Some(tda) = maybe_tda {
+                let actual_len = tda.account_data.data().len();
+                let expected_len = 8_usize.saturating_add(size_of::<TipDistributionAccount>());
+                if actual_len != expected_len {
+                    warn!("len mismatch actual={actual_len}, expected={expected_len}");
+                }
+                let rent_exempt_amount =
+                    bank.get_minimum_balance_for_rent_exemption(tda.account_data.data().len());
+
+                Some(TipDistributionMeta::from_tda_wrapper(
+                    tda,
+                    rent_exempt_amount,
+                )?)
+            } else {
+                None
+            };
+
+            let vote_state = vote_account.vote_state().unwrap();
+            delegations.sort();
+            stake_metas.push(StakeMeta {
+                maybe_tip_distribution_meta,
+                validator_node_pubkey: vote_state.node_pubkey,
+                validator_vote_account: vote_pubkey,
+                delegations,
+                total_delegated,
+                commission: vote_state.commission,
+            });
+        } else {
+            warn!(
+                    "voter_pubkey not found in voter_pubkey_to_delegations map [validator_vote_pubkey={}]",
+                    vote_pubkey
+                );
+        }
+    }
+    stake_metas.sort();
+
+    Ok(StakeMetaCollection {
+        stake_metas,
+        tip_distribution_program_id: *tip_distribution_program_id,
+        bank_hash: bank.hash().to_string(),
+        epoch: bank.epoch(),
+        slot: bank.slot(),
+    })
+}
+
+/// Given an [EpochStakes] object, return delegations grouped by voter_pubkey (validator delegated to).
+fn group_delegations_by_voter_pubkey(
+    delegations: &im::HashMap<Pubkey, StakeAccount>,
+    bank: &Bank,
+) -> HashMap<Pubkey, Vec<crate::Delegation>> {
+    delegations
+        .into_iter()
+        .filter(|(_stake_pubkey, stake_account)| {
+            stake_account.delegation().stake(
+                bank.epoch(),
+                &from_account::<StakeHistory, _>(
+                    &bank.get_account(&sysvar::stake_history::id()).unwrap(),
+                )
+                .unwrap(),
+                bank.new_warmup_cooldown_rate_epoch(),
+            ) > 0
+        })
+        .into_group_map_by(|(_stake_pubkey, stake_account)| stake_account.delegation().voter_pubkey)
+        .into_iter()
+        .map(|(voter_pubkey, group)| {
+            (
+                voter_pubkey,
+                group
+                    .into_iter()
+                    .map(|(stake_pubkey, stake_account)| crate::Delegation {
+                        stake_account_pubkey: *stake_pubkey,
+                        staker_pubkey: stake_account
+                            .stake_state()
+                            .authorized()
+                            .map(|a| a.staker)
+                            .unwrap_or_default(),
+                        withdrawer_pubkey: stake_account
+                            .stake_state()
+                            .authorized()
+                            .map(|a| a.withdrawer)
+                            .unwrap_or_default(),
+                        lamports_delegated: stake_account.delegation().stake,
+                    })
+                    .collect::<Vec<crate::Delegation>>(),
+            )
+        })
+        .collect()
+}
+
+#[cfg(test)]
+mod tests {
+    use {
+        super::*,
+        crate::derive_tip_distribution_account_address,
+        anchor_lang::AccountSerialize,
+        jito_tip_distribution::state::TipDistributionAccount,
+        jito_tip_payment::{
+            InitBumps, TipPaymentAccount, CONFIG_ACCOUNT_SEED, TIP_ACCOUNT_SEED_0,
+            TIP_ACCOUNT_SEED_1, TIP_ACCOUNT_SEED_2, TIP_ACCOUNT_SEED_3, TIP_ACCOUNT_SEED_4,
+            TIP_ACCOUNT_SEED_5, TIP_ACCOUNT_SEED_6, TIP_ACCOUNT_SEED_7,
+        },
+        solana_runtime::genesis_utils::{
+            create_genesis_config_with_vote_accounts, GenesisConfigInfo, ValidatorVoteKeypairs,
+        },
+        solana_sdk::{
+            self,
+            account::{from_account, AccountSharedData},
+            message::Message,
+            signature::{Keypair, Signer},
+            stake::{
+                self,
+                state::{Authorized, Lockup},
+            },
+            stake_history::StakeHistory,
+            sysvar,
+            transaction::Transaction,
+        },
+        solana_stake_program::stake_state,
+    };
+
+    #[test]
+    fn test_generate_stake_meta_collection_happy_path() {
+        /* 1. Create a Bank seeded with some validator stake accounts */
+        let validator_keypairs_0 = ValidatorVoteKeypairs::new_rand();
+        let validator_keypairs_1 = ValidatorVoteKeypairs::new_rand();
+        let validator_keypairs_2 = ValidatorVoteKeypairs::new_rand();
+        let validator_keypairs = vec![
+            &validator_keypairs_0,
+            &validator_keypairs_1,
+            &validator_keypairs_2,
+        ];
+        const INITIAL_VALIDATOR_STAKES: u64 = 10_000;
+        let GenesisConfigInfo { genesis_config, .. } = create_genesis_config_with_vote_accounts(
+            1_000_000_000,
+            &validator_keypairs,
+            vec![INITIAL_VALIDATOR_STAKES; 3],
+        );
+
+        let (mut bank, _bank_forks) = Bank::new_with_bank_forks_for_tests(&genesis_config);
+
+        /* 2. Seed the Bank with [TipDistributionAccount]'s */
+        let merkle_root_upload_authority = Pubkey::new_unique();
+        let tip_distribution_program_id = Pubkey::new_unique();
+        let tip_payment_program_id = Pubkey::new_unique();
+
+        let delegator_0 = Keypair::new();
+        let delegator_1 = Keypair::new();
+        let delegator_2 = Keypair::new();
+        let delegator_3 = Keypair::new();
+        let delegator_4 = Keypair::new();
+
+        let delegator_0_pk = delegator_0.pubkey();
+        let delegator_1_pk = delegator_1.pubkey();
+        let delegator_2_pk = delegator_2.pubkey();
+        let delegator_3_pk = delegator_3.pubkey();
+        let delegator_4_pk = delegator_4.pubkey();
+
+        let d_0_data = AccountSharedData::new(
+            300_000_000_000_000 * 10,
+            0,
+            &solana_sdk::system_program::id(),
+        );
+        let d_1_data = AccountSharedData::new(
+            100_000_203_000_000 * 10,
+            0,
+            &solana_sdk::system_program::id(),
+        );
+        let d_2_data = AccountSharedData::new(
+            100_000_235_899_000 * 10,
+            0,
+            &solana_sdk::system_program::id(),
+        );
+        let d_3_data = AccountSharedData::new(
+            200_000_000_000_000 * 10,
+            0,
+            &solana_sdk::system_program::id(),
+        );
+        let d_4_data = AccountSharedData::new(
+            100_000_000_777_000 * 10,
+            0,
+            &solana_sdk::system_program::id(),
+        );
+
+        bank.store_account(&delegator_0_pk, &d_0_data);
+        bank.store_account(&delegator_1_pk, &d_1_data);
+        bank.store_account(&delegator_2_pk, &d_2_data);
+        bank.store_account(&delegator_3_pk, &d_3_data);
+        bank.store_account(&delegator_4_pk, &d_4_data);
+
+        /* 3. Delegate some stake to the initial set of validators */
+        let mut validator_0_delegations = vec![crate::Delegation {
+            stake_account_pubkey: validator_keypairs_0.stake_keypair.pubkey(),
+            staker_pubkey: validator_keypairs_0.stake_keypair.pubkey(),
+            withdrawer_pubkey: validator_keypairs_0.stake_keypair.pubkey(),
+            lamports_delegated: INITIAL_VALIDATOR_STAKES,
+        }];
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_0,
+            &validator_keypairs_0.vote_keypair.pubkey(),
+            30_000_000_000,
+        );
+        validator_0_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_0.pubkey(),
+            withdrawer_pubkey: delegator_0.pubkey(),
+            lamports_delegated: 30_000_000_000,
+        });
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_1,
+            &validator_keypairs_0.vote_keypair.pubkey(),
+            3_000_000_000,
+        );
+        validator_0_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_1.pubkey(),
+            withdrawer_pubkey: delegator_1.pubkey(),
+            lamports_delegated: 3_000_000_000,
+        });
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_2,
+            &validator_keypairs_0.vote_keypair.pubkey(),
+            33_000_000_000,
+        );
+        validator_0_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_2.pubkey(),
+            withdrawer_pubkey: delegator_2.pubkey(),
+            lamports_delegated: 33_000_000_000,
+        });
+
+        let mut validator_1_delegations = vec![crate::Delegation {
+            stake_account_pubkey: validator_keypairs_1.stake_keypair.pubkey(),
+            staker_pubkey: validator_keypairs_1.stake_keypair.pubkey(),
+            withdrawer_pubkey: validator_keypairs_1.stake_keypair.pubkey(),
+            lamports_delegated: INITIAL_VALIDATOR_STAKES,
+        }];
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_3,
+            &validator_keypairs_1.vote_keypair.pubkey(),
+            4_222_364_000,
+        );
+        validator_1_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_3.pubkey(),
+            withdrawer_pubkey: delegator_3.pubkey(),
+            lamports_delegated: 4_222_364_000,
+        });
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_4,
+            &validator_keypairs_1.vote_keypair.pubkey(),
+            6_000_000_527,
+        );
+        validator_1_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_4.pubkey(),
+            withdrawer_pubkey: delegator_4.pubkey(),
+            lamports_delegated: 6_000_000_527,
+        });
+
+        let mut validator_2_delegations = vec![crate::Delegation {
+            stake_account_pubkey: validator_keypairs_2.stake_keypair.pubkey(),
+            staker_pubkey: validator_keypairs_2.stake_keypair.pubkey(),
+            withdrawer_pubkey: validator_keypairs_2.stake_keypair.pubkey(),
+            lamports_delegated: INITIAL_VALIDATOR_STAKES,
+        }];
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_0,
+            &validator_keypairs_2.vote_keypair.pubkey(),
+            1_300_123_156,
+        );
+        validator_2_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_0.pubkey(),
+            withdrawer_pubkey: delegator_0.pubkey(),
+            lamports_delegated: 1_300_123_156,
+        });
+        let stake_account = delegate_stake_helper(
+            &bank,
+            &delegator_4,
+            &validator_keypairs_2.vote_keypair.pubkey(),
+            1_610_565_420,
+        );
+        validator_2_delegations.push(crate::Delegation {
+            stake_account_pubkey: stake_account,
+            staker_pubkey: delegator_4.pubkey(),
+            withdrawer_pubkey: delegator_4.pubkey(),
+            lamports_delegated: 1_610_565_420,
+        });
+
+        /* 4. Run assertions */
+        fn warmed_up(bank: &Bank, stake_pubkeys: &[Pubkey]) -> bool {
+            for stake_pubkey in stake_pubkeys {
+                let stake =
+                    stake_state::stake_from(&bank.get_account(stake_pubkey).unwrap()).unwrap();
+
+                if stake.delegation.stake
+                    != stake.stake(
+                        bank.epoch(),
+                        &from_account::<StakeHistory, _>(
+                            &bank.get_account(&sysvar::stake_history::id()).unwrap(),
+                        )
+                        .unwrap(),
+                        bank.new_warmup_cooldown_rate_epoch(),
+                    )
+                {
+                    return false;
+                }
+            }
+
+            true
+        }
+        fn next_epoch(bank: &Arc<Bank>) -> Arc<Bank> {
+            bank.squash();
+
+            Arc::new(Bank::new_from_parent(
+                bank.clone(),
+                &Pubkey::default(),
+                bank.get_slots_in_epoch(bank.epoch()) + bank.slot(),
+            ))
+        }
+
+        let mut stake_pubkeys = validator_0_delegations
+            .iter()
+            .map(|v| v.stake_account_pubkey)
+            .collect::<Vec<Pubkey>>();
+        stake_pubkeys.extend(
+            validator_1_delegations
+                .iter()
+                .map(|v| v.stake_account_pubkey),
+        );
+        stake_pubkeys.extend(
+            validator_2_delegations
+                .iter()
+                .map(|v| v.stake_account_pubkey),
+        );
+        loop {
+            if warmed_up(&bank, &stake_pubkeys[..]) {
+                break;
+            }
+
+            // Cycle thru banks until we're fully warmed up
+            bank = next_epoch(&bank);
+        }
+
+        let tip_distribution_account_0 = derive_tip_distribution_account_address(
+            &tip_distribution_program_id,
+            &validator_keypairs_0.vote_keypair.pubkey(),
+            bank.epoch(),
+        );
+        let tip_distribution_account_1 = derive_tip_distribution_account_address(
+            &tip_distribution_program_id,
+            &validator_keypairs_1.vote_keypair.pubkey(),
+            bank.epoch(),
+        );
+        let tip_distribution_account_2 = derive_tip_distribution_account_address(
+            &tip_distribution_program_id,
+            &validator_keypairs_2.vote_keypair.pubkey(),
+            bank.epoch(),
+        );
+
+        let expires_at = bank.epoch() + 3;
+
+        let tda_0 = TipDistributionAccount {
+            validator_vote_account: validator_keypairs_0.vote_keypair.pubkey(),
+            merkle_root_upload_authority,
+            merkle_root: None,
+            epoch_created_at: bank.epoch(),
+            validator_commission_bps: 50,
+            expires_at,
+            bump: tip_distribution_account_0.1,
+        };
+        let tda_1 = TipDistributionAccount {
+            validator_vote_account: validator_keypairs_1.vote_keypair.pubkey(),
+            merkle_root_upload_authority,
+            merkle_root: None,
+            epoch_created_at: bank.epoch(),
+            validator_commission_bps: 500,
+            expires_at: 0,
+            bump: tip_distribution_account_1.1,
+        };
+        let tda_2 = TipDistributionAccount {
+            validator_vote_account: validator_keypairs_2.vote_keypair.pubkey(),
+            merkle_root_upload_authority,
+            merkle_root: None,
+            epoch_created_at: bank.epoch(),
+            validator_commission_bps: 75,
+            expires_at: 0,
+            bump: tip_distribution_account_2.1,
+        };
+
+        let tip_distro_0_tips = 1_000_000 * 10;
+        let tip_distro_1_tips = 69_000_420 * 10;
+        let tip_distro_2_tips = 789_000_111 * 10;
+
+        let tda_0_fields = (tip_distribution_account_0.0, tda_0.validator_commission_bps);
+        let data_0 =
+            tda_to_account_shared_data(&tip_distribution_program_id, tip_distro_0_tips, tda_0);
+        let tda_1_fields = (tip_distribution_account_1.0, tda_1.validator_commission_bps);
+        let data_1 =
+            tda_to_account_shared_data(&tip_distribution_program_id, tip_distro_1_tips, tda_1);
+        let tda_2_fields = (tip_distribution_account_2.0, tda_2.validator_commission_bps);
+        let data_2 =
+            tda_to_account_shared_data(&tip_distribution_program_id, tip_distro_2_tips, tda_2);
+
+        let accounts_data = create_config_account_data(&tip_payment_program_id, &bank);
+        for (pubkey, data) in accounts_data {
+            bank.store_account(&pubkey, &data);
+        }
+
+        bank.store_account(&tip_distribution_account_0.0, &data_0);
+        bank.store_account(&tip_distribution_account_1.0, &data_1);
+        bank.store_account(&tip_distribution_account_2.0, &data_2);
+
+        bank.freeze();
+        let stake_meta_collection = generate_stake_meta_collection(
+            &bank,
+            &tip_distribution_program_id,
+            &tip_payment_program_id,
+        )
+        .unwrap();
+        assert_eq!(
+            stake_meta_collection.tip_distribution_program_id,
+            tip_distribution_program_id
+        );
+        assert_eq!(stake_meta_collection.slot, bank.slot());
+        assert_eq!(stake_meta_collection.epoch, bank.epoch());
+
+        let mut expected_stake_metas = HashMap::new();
+        expected_stake_metas.insert(
+            validator_keypairs_0.vote_keypair.pubkey(),
+            StakeMeta {
+                validator_vote_account: validator_keypairs_0.vote_keypair.pubkey(),
+                delegations: validator_0_delegations.clone(),
+                total_delegated: validator_0_delegations
+                    .iter()
+                    .fold(0u64, |sum, delegation| {
+                        sum.checked_add(delegation.lamports_delegated).unwrap()
+                    }),
+                maybe_tip_distribution_meta: Some(TipDistributionMeta {
+                    merkle_root_upload_authority,
+                    tip_distribution_pubkey: tda_0_fields.0,
+                    total_tips: tip_distro_0_tips
+                        .checked_sub(
+                            bank.get_minimum_balance_for_rent_exemption(
+                                TipDistributionAccount::SIZE,
+                            ),
+                        )
+                        .unwrap(),
+                    validator_fee_bps: tda_0_fields.1,
+                }),
+                commission: 0,
+                validator_node_pubkey: validator_keypairs_0.node_keypair.pubkey(),
+            },
+        );
+        expected_stake_metas.insert(
+            validator_keypairs_1.vote_keypair.pubkey(),
+            StakeMeta {
+                validator_vote_account: validator_keypairs_1.vote_keypair.pubkey(),
+                delegations: validator_1_delegations.clone(),
+                total_delegated: validator_1_delegations
+                    .iter()
+                    .fold(0u64, |sum, delegation| {
+                        sum.checked_add(delegation.lamports_delegated).unwrap()
+                    }),
+                maybe_tip_distribution_meta: Some(TipDistributionMeta {
+                    merkle_root_upload_authority,
+                    tip_distribution_pubkey: tda_1_fields.0,
+                    total_tips: tip_distro_1_tips
+                        .checked_sub(
+                            bank.get_minimum_balance_for_rent_exemption(
+                                TipDistributionAccount::SIZE,
+                            ),
+                        )
+                        .unwrap(),
+                    validator_fee_bps: tda_1_fields.1,
+                }),
+                commission: 0,
+                validator_node_pubkey: validator_keypairs_1.node_keypair.pubkey(),
+            },
+        );
+        expected_stake_metas.insert(
+            validator_keypairs_2.vote_keypair.pubkey(),
+            StakeMeta {
+                validator_vote_account: validator_keypairs_2.vote_keypair.pubkey(),
+                delegations: validator_2_delegations.clone(),
+                total_delegated: validator_2_delegations
+                    .iter()
+                    .fold(0u64, |sum, delegation| {
+                        sum.checked_add(delegation.lamports_delegated).unwrap()
+                    }),
+                maybe_tip_distribution_meta: Some(TipDistributionMeta {
+                    merkle_root_upload_authority,
+                    tip_distribution_pubkey: tda_2_fields.0,
+                    total_tips: tip_distro_2_tips
+                        .checked_sub(
+                            bank.get_minimum_balance_for_rent_exemption(
+                                TipDistributionAccount::SIZE,
+                            ),
+                        )
+                        .unwrap(),
+                    validator_fee_bps: tda_2_fields.1,
+                }),
+                commission: 0,
+                validator_node_pubkey: validator_keypairs_2.node_keypair.pubkey(),
+            },
+        );
+
+        println!(
+            "validator_0 [vote_account={}, stake_account={}]",
+            validator_keypairs_0.vote_keypair.pubkey(),
+            validator_keypairs_0.stake_keypair.pubkey()
+        );
+        println!(
+            "validator_1 [vote_account={}, stake_account={}]",
+            validator_keypairs_1.vote_keypair.pubkey(),
+            validator_keypairs_1.stake_keypair.pubkey()
+        );
+        println!(
+            "validator_2 [vote_account={}, stake_account={}]",
+            validator_keypairs_2.vote_keypair.pubkey(),
+            validator_keypairs_2.stake_keypair.pubkey(),
+        );
+
+        assert_eq!(
+            expected_stake_metas.len(),
+            stake_meta_collection.stake_metas.len()
+        );
+
+        for actual_stake_meta in stake_meta_collection.stake_metas {
+            let expected_stake_meta = expected_stake_metas
+                .get(&actual_stake_meta.validator_vote_account)
+                .unwrap();
+            assert_eq!(
+                expected_stake_meta.maybe_tip_distribution_meta,
+                actual_stake_meta.maybe_tip_distribution_meta
+            );
+            assert_eq!(
+                expected_stake_meta.total_delegated,
+                actual_stake_meta.total_delegated
+            );
+            assert_eq!(expected_stake_meta.commission, actual_stake_meta.commission);
+            assert_eq!(
+                expected_stake_meta.validator_vote_account,
+                actual_stake_meta.validator_vote_account
+            );
+
+            assert_eq!(
+                expected_stake_meta.delegations.len(),
+                actual_stake_meta.delegations.len()
+            );
+
+            for expected_delegation in &expected_stake_meta.delegations {
+                let actual_delegation = actual_stake_meta
+                    .delegations
+                    .iter()
+                    .find(|d| d.stake_account_pubkey == expected_delegation.stake_account_pubkey)
+                    .unwrap();
+
+                assert_eq!(expected_delegation, actual_delegation);
+            }
+        }
+    }
+
+    /// Helper function that sends a delegate stake instruction to the bank.
+    /// Returns the created stake account pubkey.
+    fn delegate_stake_helper(
+        bank: &Bank,
+        from_keypair: &Keypair,
+        vote_account: &Pubkey,
+        delegation_amount: u64,
+    ) -> Pubkey {
+        let minimum_delegation = solana_stake_program::get_minimum_delegation(&bank.feature_set);
+        assert!(
+            delegation_amount >= minimum_delegation,
+            "{}",
+            format!(
+                "received delegation_amount {}, must be at least {}",
+                delegation_amount, minimum_delegation
+            )
+        );
+        if let Some(from_account) = bank.get_account(&from_keypair.pubkey()) {
+            assert_eq!(from_account.owner(), &solana_sdk::system_program::id());
+        } else {
+            panic!("from_account DNE");
+        }
+        assert!(bank.get_account(vote_account).is_some());
+
+        let stake_keypair = Keypair::new();
+        let instructions = stake::instruction::create_account_and_delegate_stake(
+            &from_keypair.pubkey(),
+            &stake_keypair.pubkey(),
+            vote_account,
+            &Authorized::auto(&from_keypair.pubkey()),
+            &Lockup::default(),
+            delegation_amount,
+        );
+
+        let message = Message::new(&instructions[..], Some(&from_keypair.pubkey()));
+        let transaction = Transaction::new(
+            &[from_keypair, &stake_keypair],
+            message,
+            bank.last_blockhash(),
+        );
+
+        bank.process_transaction(&transaction)
+            .map_err(|e| {
+                eprintln!("Error delegating stake [error={}]", e);
+                e
+            })
+            .unwrap();
+
+        stake_keypair.pubkey()
+    }
+
+    fn tda_to_account_shared_data(
+        tip_distribution_program_id: &Pubkey,
+        lamports: u64,
+        tda: TipDistributionAccount,
+    ) -> AccountSharedData {
+        let mut account_data = AccountSharedData::new(
+            lamports,
+            TipDistributionAccount::SIZE,
+            tip_distribution_program_id,
+        );
+
+        let mut data: [u8; TipDistributionAccount::SIZE] = [0u8; TipDistributionAccount::SIZE];
+        let mut cursor = std::io::Cursor::new(&mut data[..]);
+        tda.try_serialize(&mut cursor).unwrap();
+
+        account_data.set_data(data.to_vec());
+        account_data
+    }
+
+    fn create_config_account_data(
+        tip_payment_program_id: &Pubkey,
+        bank: &Bank,
+    ) -> Vec<(Pubkey, AccountSharedData)> {
+        let mut account_datas = vec![];
+
+        let config_pda =
+            Pubkey::find_program_address(&[CONFIG_ACCOUNT_SEED], tip_payment_program_id);
+
+        let tip_accounts = [
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_0], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_1], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_2], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_3], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_4], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_5], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_6], tip_payment_program_id),
+            Pubkey::find_program_address(&[TIP_ACCOUNT_SEED_7], tip_payment_program_id),
+        ];
+
+        let config = Config {
+            tip_receiver: Pubkey::new_unique(),
+            block_builder: Pubkey::new_unique(),
+            block_builder_commission_pct: 10,
+            bumps: InitBumps {
+                config: config_pda.1,
+                tip_payment_account_0: tip_accounts[0].1,
+                tip_payment_account_1: tip_accounts[1].1,
+                tip_payment_account_2: tip_accounts[2].1,
+                tip_payment_account_3: tip_accounts[3].1,
+                tip_payment_account_4: tip_accounts[4].1,
+                tip_payment_account_5: tip_accounts[5].1,
+                tip_payment_account_6: tip_accounts[6].1,
+                tip_payment_account_7: tip_accounts[7].1,
+            },
+        };
+
+        let mut config_account_data = AccountSharedData::new(
+            bank.get_minimum_balance_for_rent_exemption(Config::SIZE),
+            Config::SIZE,
+            tip_payment_program_id,
+        );
+
+        let mut config_data: [u8; Config::SIZE] = [0u8; Config::SIZE];
+        let mut config_cursor = std::io::Cursor::new(&mut config_data[..]);
+        config.try_serialize(&mut config_cursor).unwrap();
+        config_account_data.set_data(config_data.to_vec());
+        account_datas.push((config_pda.0, config_account_data));
+
+        account_datas.extend(tip_accounts.into_iter().map(|(pubkey, _)| {
+            let mut tip_account_data = AccountSharedData::new(
+                bank.get_minimum_balance_for_rent_exemption(TipPaymentAccount::SIZE),
+                TipPaymentAccount::SIZE,
+                tip_payment_program_id,
+            );
+
+            let mut data: [u8; TipPaymentAccount::SIZE] = [0u8; TipPaymentAccount::SIZE];
+            let mut cursor = std::io::Cursor::new(&mut data[..]);
+            TipPaymentAccount::default()
+                .try_serialize(&mut cursor)
+                .unwrap();
+            tip_account_data.set_data(data.to_vec());
+
+            (pubkey, tip_account_data)
+        }));
+
+        account_datas
+    }
+}
diff --git a/transaction-status/src/lib.rs b/transaction-status/src/lib.rs
index 6a5eb5fb8d63..67a8a4ba7656 100644
--- a/transaction-status/src/lib.rs
+++ b/transaction-status/src/lib.rs
@@ -27,7 +27,7 @@ use {
         },
         transaction_context::TransactionReturnData,
     },
-    std::fmt,
+    std::{collections::HashMap, fmt},
     thiserror::Error,
 };
 
@@ -301,6 +301,13 @@ impl From<InnerInstructions> for UiInnerInstructions {
     }
 }
 
+#[derive(Default)]
+pub struct PreBalanceInfo {
+    pub native: Vec<Vec<u64>>,
+    pub token: Vec<Vec<TransactionTokenBalance>>,
+    pub mint_decimals: HashMap<Pubkey, u8>,
+}
+
 #[derive(Clone, Debug, PartialEq)]
 pub struct TransactionTokenBalance {
     pub account_index: u8,
diff --git a/turbine/benches/cluster_info.rs b/turbine/benches/cluster_info.rs
index 1f15137175ac..fffca1126ff0 100644
--- a/turbine/benches/cluster_info.rs
+++ b/turbine/benches/cluster_info.rs
@@ -76,6 +76,7 @@ fn broadcast_shreds_bench(bencher: &mut Bencher) {
             &bank_forks,
             &SocketAddrSpace::Unspecified,
             &quic_endpoint_sender,
+            &None,
         )
         .unwrap();
     });
diff --git a/turbine/benches/retransmit_stage.rs b/turbine/benches/retransmit_stage.rs
index c5490d5670e6..56c672c7c8fe 100644
--- a/turbine/benches/retransmit_stage.rs
+++ b/turbine/benches/retransmit_stage.rs
@@ -33,7 +33,7 @@ use {
         net::{Ipv4Addr, UdpSocket},
         sync::{
             atomic::{AtomicUsize, Ordering},
-            Arc,
+            Arc, RwLock,
         },
         thread::{sleep, Builder},
         time::Duration,
@@ -126,6 +126,7 @@ fn bench_retransmitter(bencher: &mut Bencher) {
         shreds_receiver,
         Arc::default(), // solana_rpc::max_slots::MaxSlots
         None,
+        Arc::new(RwLock::new(None)),
     );
 
     let mut index = 0;
diff --git a/turbine/src/broadcast_stage.rs b/turbine/src/broadcast_stage.rs
index c13d72ee4615..33b78171fdd2 100644
--- a/turbine/src/broadcast_stage.rs
+++ b/turbine/src/broadcast_stage.rs
@@ -116,6 +116,7 @@ impl BroadcastStageType {
         bank_forks: Arc<RwLock<BankForks>>,
         shred_version: u16,
         quic_endpoint_sender: AsyncSender<(SocketAddr, Bytes)>,
+        shred_receiver_address: Arc<RwLock<Option<SocketAddr>>>,
     ) -> BroadcastStage {
         match self {
             BroadcastStageType::Standard => BroadcastStage::new(
@@ -128,6 +129,7 @@ impl BroadcastStageType {
                 bank_forks,
                 quic_endpoint_sender,
                 StandardBroadcastRun::new(shred_version),
+                shred_receiver_address,
             ),
 
             BroadcastStageType::FailEntryVerification => BroadcastStage::new(
@@ -140,6 +142,7 @@ impl BroadcastStageType {
                 bank_forks,
                 quic_endpoint_sender,
                 FailEntryVerificationBroadcastRun::new(shred_version),
+                Arc::new(RwLock::new(None)),
             ),
 
             BroadcastStageType::BroadcastFakeShreds => BroadcastStage::new(
@@ -152,6 +155,7 @@ impl BroadcastStageType {
                 bank_forks,
                 quic_endpoint_sender,
                 BroadcastFakeShredsRun::new(0, shred_version),
+                Arc::new(RwLock::new(None)),
             ),
 
             BroadcastStageType::BroadcastDuplicates(config) => BroadcastStage::new(
@@ -164,6 +168,7 @@ impl BroadcastStageType {
                 bank_forks,
                 quic_endpoint_sender,
                 BroadcastDuplicatesRun::new(shred_version, config.clone()),
+                Arc::new(RwLock::new(None)),
             ),
         }
     }
@@ -185,6 +190,7 @@ trait BroadcastRun {
         sock: &UdpSocket,
         bank_forks: &RwLock<BankForks>,
         quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        shred_receiver_address: &Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<()>;
     fn record(&mut self, receiver: &RecordReceiver, blockstore: &Blockstore) -> Result<()>;
 }
@@ -280,6 +286,7 @@ impl BroadcastStage {
         bank_forks: Arc<RwLock<BankForks>>,
         quic_endpoint_sender: AsyncSender<(SocketAddr, Bytes)>,
         mut broadcast_stage_run: impl BroadcastRun + Send + 'static + Clone,
+        shred_receiver_address: Arc<RwLock<Option<SocketAddr>>>,
     ) -> Self {
         let (socket_sender, socket_receiver) = unbounded();
         let (blockstore_sender, blockstore_receiver) = unbounded();
@@ -311,6 +318,8 @@ impl BroadcastStage {
             let cluster_info = cluster_info.clone();
             let bank_forks = bank_forks.clone();
             let quic_endpoint_sender = quic_endpoint_sender.clone();
+            let shred_receiver_address = shred_receiver_address.clone();
+
             let run_transmit = move || loop {
                 let res = bs_transmit.transmit(
                     &socket_receiver,
@@ -318,6 +327,7 @@ impl BroadcastStage {
                     &sock,
                     &bank_forks,
                     &quic_endpoint_sender,
+                    &shred_receiver_address,
                 );
                 let res = Self::handle_error(res, "solana-broadcaster-transmit");
                 if let Some(res) = res {
@@ -427,6 +437,7 @@ fn update_peer_stats(
 
 /// Broadcasts shreds from the leader (i.e. this node) to the root of the
 /// turbine retransmit tree for each shred.
+#[allow(clippy::too_many_arguments)]
 pub fn broadcast_shreds(
     s: &UdpSocket,
     shreds: &[Shred],
@@ -437,6 +448,7 @@ pub fn broadcast_shreds(
     bank_forks: &RwLock<BankForks>,
     socket_addr_space: &SocketAddrSpace,
     quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+    shred_receiver_address: &Option<SocketAddr>,
 ) -> Result<()> {
     let mut result = Ok(());
     let mut shred_select = Measure::start("shred_select");
@@ -452,15 +464,34 @@ pub fn broadcast_shreds(
             let cluster_nodes =
                 cluster_nodes_cache.get(slot, &root_bank, &working_bank, cluster_info);
             update_peer_stats(&cluster_nodes, last_datapoint_submit);
-            shreds.filter_map(move |shred| {
+            shreds.flat_map(move |shred| {
                 let key = shred.id();
                 let protocol = cluster_nodes::get_broadcast_protocol(&key);
-                cluster_nodes
-                    .get_broadcast_peer(&key)?
-                    .tvu(protocol)
-                    .ok()
-                    .filter(|addr| socket_addr_space.check(addr))
-                    .map(|addr| {
+
+                let mut addrs = Vec::with_capacity(2);
+                if let Some(shred_receiver_address) = shred_receiver_address {
+                    // Assuming always over UDP for shred_receiver_address
+                    addrs.push((Protocol::UDP, *shred_receiver_address));
+                }
+                if let Some(peer) = cluster_nodes.get_broadcast_peer(&key) {
+                    match protocol {
+                        Protocol::QUIC => {
+                            if let Ok(tvu) = peer.tvu(Protocol::QUIC) {
+                                addrs.push((Protocol::QUIC, tvu));
+                            }
+                        }
+                        Protocol::UDP => {
+                            if let Ok(tvu) = peer.tvu(Protocol::UDP) {
+                                addrs.push((Protocol::UDP, tvu));
+                            }
+                        }
+                    }
+                }
+
+                addrs
+                    .into_iter()
+                    .filter(|(_, a)| socket_addr_space.check(a))
+                    .map(move |(protocol, addr)| {
                         (match protocol {
                             Protocol::QUIC => Either::Right,
                             Protocol::UDP => Either::Left,
@@ -695,6 +726,7 @@ pub mod test {
             bank_forks,
             quic_endpoint_sender,
             StandardBroadcastRun::new(0),
+            Arc::new(RwLock::new(None)),
         );
 
         MockBroadcastStage {
@@ -733,7 +765,10 @@ pub mod test {
             let ticks = create_ticks(max_tick_height - start_tick_height, 0, Hash::default());
             for (i, tick) in ticks.into_iter().enumerate() {
                 entry_sender
-                    .send((bank.clone(), (tick, i as u64 + 1)))
+                    .send(WorkingBankEntry {
+                        bank: bank.clone(),
+                        entries_ticks: vec![(tick, i as u64 + 1)],
+                    })
                     .expect("Expect successful send to broadcast service");
             }
         }
diff --git a/turbine/src/broadcast_stage/broadcast_duplicates_run.rs b/turbine/src/broadcast_stage/broadcast_duplicates_run.rs
index 3060fd27c820..64ef9031519c 100644
--- a/turbine/src/broadcast_stage/broadcast_duplicates_run.rs
+++ b/turbine/src/broadcast_stage/broadcast_duplicates_run.rs
@@ -297,6 +297,7 @@ impl BroadcastRun for BroadcastDuplicatesRun {
         sock: &UdpSocket,
         bank_forks: &RwLock<BankForks>,
         _quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        _shred_receiver_addr: &Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<()> {
         let (shreds, _) = receiver.recv()?;
         if shreds.is_empty() {
diff --git a/turbine/src/broadcast_stage/broadcast_fake_shreds_run.rs b/turbine/src/broadcast_stage/broadcast_fake_shreds_run.rs
index b82ca324b618..649e8d03832c 100644
--- a/turbine/src/broadcast_stage/broadcast_fake_shreds_run.rs
+++ b/turbine/src/broadcast_stage/broadcast_fake_shreds_run.rs
@@ -150,6 +150,7 @@ impl BroadcastRun for BroadcastFakeShredsRun {
         sock: &UdpSocket,
         _bank_forks: &RwLock<BankForks>,
         _quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        _shred_receiver_addr: &Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<()> {
         for (data_shreds, batch_info) in receiver {
             let fake = batch_info.is_some();
diff --git a/turbine/src/broadcast_stage/broadcast_utils.rs b/turbine/src/broadcast_stage/broadcast_utils.rs
index 9c4b48bd5ca0..c4795a840d01 100644
--- a/turbine/src/broadcast_stage/broadcast_utils.rs
+++ b/turbine/src/broadcast_stage/broadcast_utils.rs
@@ -31,13 +31,23 @@ pub(super) fn recv_slot_entries(receiver: &Receiver<WorkingBankEntry>) -> Result
         32 * ShredData::capacity(/*merkle_proof_size*/ None).unwrap() as u64;
     let timer = Duration::new(1, 0);
     let recv_start = Instant::now();
-    let (mut bank, (entry, mut last_tick_height)) = receiver.recv_timeout(timer)?;
-    let mut entries = vec![entry];
+
+    let WorkingBankEntry {
+        mut bank,
+        entries_ticks,
+    } = receiver.recv_timeout(timer)?;
+    let mut last_tick_height = entries_ticks.iter().last().unwrap().1;
+    let mut entries: Vec<Entry> = entries_ticks.into_iter().map(|(e, _)| e).collect();
+
     assert!(last_tick_height <= bank.max_tick_height());
 
     // Drain channel
     while last_tick_height != bank.max_tick_height() {
-        let Ok((try_bank, (entry, tick_height))) = receiver.try_recv() else {
+        let Ok(WorkingBankEntry {
+            bank: try_bank,
+            entries_ticks: new_entries_ticks,
+        }) = receiver.try_recv()
+        else {
             break;
         };
         // If the bank changed, that implies the previous slot was interrupted and we do not have to
@@ -47,8 +57,8 @@ pub(super) fn recv_slot_entries(receiver: &Receiver<WorkingBankEntry>) -> Result
             entries.clear();
             bank = try_bank;
         }
-        last_tick_height = tick_height;
-        entries.push(entry);
+        last_tick_height = new_entries_ticks.iter().last().unwrap().1;
+        entries.extend(new_entries_ticks.into_iter().map(|(entry, _)| entry));
         assert!(last_tick_height <= bank.max_tick_height());
     }
 
@@ -59,8 +69,10 @@ pub(super) fn recv_slot_entries(receiver: &Receiver<WorkingBankEntry>) -> Result
     while last_tick_height != bank.max_tick_height()
         && serialized_batch_byte_count < target_serialized_batch_byte_count
     {
-        let Ok((try_bank, (entry, tick_height))) =
-            receiver.recv_deadline(coalesce_start + ENTRY_COALESCE_DURATION)
+        let Ok(WorkingBankEntry {
+            bank: try_bank,
+            entries_ticks: new_entries_ticks,
+        }) = receiver.recv_deadline(coalesce_start + ENTRY_COALESCE_DURATION)
         else {
             break;
         };
@@ -73,10 +85,12 @@ pub(super) fn recv_slot_entries(receiver: &Receiver<WorkingBankEntry>) -> Result
             bank = try_bank;
             coalesce_start = Instant::now();
         }
-        last_tick_height = tick_height;
-        let entry_bytes = serialized_size(&entry)?;
-        serialized_batch_byte_count += entry_bytes;
-        entries.push(entry);
+        last_tick_height = new_entries_ticks.iter().last().unwrap().1;
+
+        for (entry, _) in &new_entries_ticks {
+            serialized_batch_byte_count += serialized_size(entry)?;
+        }
+        entries.extend(new_entries_ticks.into_iter().map(|(entry, _)| entry));
         assert!(last_tick_height <= bank.max_tick_height());
     }
     let time_coalesced = coalesce_start.elapsed();
@@ -161,7 +175,11 @@ mod tests {
             .map(|i| {
                 let entry = Entry::new(&last_hash, 1, vec![tx.clone()]);
                 last_hash = entry.hash;
-                s.send((bank1.clone(), (entry.clone(), i))).unwrap();
+                s.send(WorkingBankEntry {
+                    bank: bank1.clone(),
+                    entries_ticks: vec![(entry.clone(), i)],
+                })
+                .unwrap();
                 entry
             })
             .collect();
@@ -195,11 +213,18 @@ mod tests {
                 last_hash = entry.hash;
                 // Interrupt slot 1 right before the last tick
                 if tick_height == expected_last_height {
-                    s.send((bank2.clone(), (entry.clone(), tick_height)))
-                        .unwrap();
+                    s.send(WorkingBankEntry {
+                        bank: bank2.clone(),
+                        entries_ticks: vec![(entry.clone(), tick_height)],
+                    })
+                    .unwrap();
                     Some(entry)
                 } else {
-                    s.send((bank1.clone(), (entry, tick_height))).unwrap();
+                    s.send(WorkingBankEntry {
+                        bank: bank1.clone(),
+                        entries_ticks: vec![(entry, tick_height)],
+                    })
+                    .unwrap();
                     None
                 }
             })
diff --git a/turbine/src/broadcast_stage/fail_entry_verification_broadcast_run.rs b/turbine/src/broadcast_stage/fail_entry_verification_broadcast_run.rs
index e9ed6a1a6eee..c0fa09ce7d3f 100644
--- a/turbine/src/broadcast_stage/fail_entry_verification_broadcast_run.rs
+++ b/turbine/src/broadcast_stage/fail_entry_verification_broadcast_run.rs
@@ -3,7 +3,7 @@ use {
     crate::cluster_nodes::ClusterNodesCache,
     solana_ledger::shred::{ProcessShredsStats, ReedSolomonCache, Shredder},
     solana_sdk::{hash::Hash, signature::Keypair},
-    std::{thread::sleep, time::Duration},
+    std::{net::SocketAddr, thread::sleep, time::Duration},
     tokio::sync::mpsc::Sender as AsyncSender,
 };
 
@@ -180,6 +180,7 @@ impl BroadcastRun for FailEntryVerificationBroadcastRun {
         sock: &UdpSocket,
         bank_forks: &RwLock<BankForks>,
         quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        shred_receiver_address: &Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<()> {
         let (shreds, _) = receiver.recv()?;
         broadcast_shreds(
@@ -192,6 +193,7 @@ impl BroadcastRun for FailEntryVerificationBroadcastRun {
             bank_forks,
             cluster_info.socket_addr_space(),
             quic_endpoint_sender,
+            &shred_receiver_address.read().unwrap(),
         )
     }
     fn record(&mut self, receiver: &RecordReceiver, blockstore: &Blockstore) -> Result<()> {
diff --git a/turbine/src/broadcast_stage/standard_broadcast_run.rs b/turbine/src/broadcast_stage/standard_broadcast_run.rs
index 1d34ccb31cc1..a65119df043a 100644
--- a/turbine/src/broadcast_stage/standard_broadcast_run.rs
+++ b/turbine/src/broadcast_stage/standard_broadcast_run.rs
@@ -17,7 +17,7 @@ use {
         signature::Keypair,
         timing::{duration_as_us, AtomicInterval},
     },
-    std::{sync::RwLock, time::Duration},
+    std::{net::SocketAddr, sync::RwLock, time::Duration},
     tokio::sync::mpsc::Sender as AsyncSender,
 };
 
@@ -179,10 +179,24 @@ impl StandardBroadcastRun {
         let (ssend, srecv) = unbounded();
         self.process_receive_results(keypair, blockstore, &ssend, &bsend, receive_results)?;
         //data
-        let _ = self.transmit(&srecv, cluster_info, sock, bank_forks, quic_endpoint_sender);
+        let _ = self.transmit(
+            &srecv,
+            cluster_info,
+            sock,
+            bank_forks,
+            quic_endpoint_sender,
+            &Arc::new(RwLock::new(None)),
+        );
         let _ = self.record(&brecv, blockstore);
         //coding
-        let _ = self.transmit(&srecv, cluster_info, sock, bank_forks, quic_endpoint_sender);
+        let _ = self.transmit(
+            &srecv,
+            cluster_info,
+            sock,
+            bank_forks,
+            quic_endpoint_sender,
+            &Arc::new(RwLock::new(None)),
+        );
         let _ = self.record(&brecv, blockstore);
         Ok(())
     }
@@ -405,6 +419,7 @@ impl StandardBroadcastRun {
         broadcast_shred_batch_info: Option<BroadcastShredBatchInfo>,
         bank_forks: &RwLock<BankForks>,
         quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        shred_receiver_addr: &Option<SocketAddr>,
     ) -> Result<()> {
         trace!("Broadcasting {:?} shreds", shreds.len());
         let mut transmit_stats = TransmitShredsStats::default();
@@ -421,6 +436,7 @@ impl StandardBroadcastRun {
             bank_forks,
             cluster_info.socket_addr_space(),
             quic_endpoint_sender,
+            shred_receiver_addr,
         )?;
         transmit_time.stop();
 
@@ -488,6 +504,7 @@ impl BroadcastRun for StandardBroadcastRun {
         sock: &UdpSocket,
         bank_forks: &RwLock<BankForks>,
         quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
+        shred_receiver_address: &Arc<RwLock<Option<SocketAddr>>>,
     ) -> Result<()> {
         let (shreds, batch_info) = receiver.recv()?;
         self.broadcast(
@@ -497,6 +514,7 @@ impl BroadcastRun for StandardBroadcastRun {
             batch_info,
             bank_forks,
             quic_endpoint_sender,
+            &shred_receiver_address.read().unwrap(),
         )
     }
     fn record(&mut self, receiver: &RecordReceiver, blockstore: &Blockstore) -> Result<()> {
diff --git a/turbine/src/retransmit_stage.rs b/turbine/src/retransmit_stage.rs
index c4c7a751ab24..78c5a9ce86a5 100644
--- a/turbine/src/retransmit_stage.rs
+++ b/turbine/src/retransmit_stage.rs
@@ -179,6 +179,7 @@ fn retransmit(
     shred_deduper: &mut ShredDeduper<2>,
     max_slots: &MaxSlots,
     rpc_subscriptions: Option<&RpcSubscriptions>,
+    shred_receiver_address: &Arc<RwLock<Option<SocketAddr>>>,
 ) -> Result<(), RecvTimeoutError> {
     const RECV_TIMEOUT: Duration = Duration::from_secs(1);
     let mut shreds = shreds_receiver.recv_timeout(RECV_TIMEOUT)?;
@@ -259,6 +260,7 @@ fn retransmit(
                     &sockets[index % sockets.len()],
                     quic_endpoint_sender,
                     stats,
+                    &shred_receiver_address.read().unwrap(),
                 )
                 .map_err(|err| {
                     stats.record_error(&err);
@@ -284,6 +286,7 @@ fn retransmit(
                         &sockets[index % sockets.len()],
                         quic_endpoint_sender,
                         stats,
+                        &shred_receiver_address.read().unwrap(),
                     )
                     .map_err(|err| {
                         stats.record_error(&err);
@@ -303,6 +306,7 @@ fn retransmit(
     Ok(())
 }
 
+#[allow(clippy::too_many_arguments)]
 fn retransmit_shred(
     key: &ShredId,
     shred: &[u8],
@@ -313,15 +317,20 @@ fn retransmit_shred(
     socket: &UdpSocket,
     quic_endpoint_sender: &AsyncSender<(SocketAddr, Bytes)>,
     stats: &RetransmitStats,
+    shred_receiver_addr: &Option<SocketAddr>,
 ) -> Result<(/*root_distance:*/ usize, /*num_nodes:*/ usize), Error> {
     let mut compute_turbine_peers = Measure::start("turbine_start");
     let data_plane_fanout = cluster_nodes::get_data_plane_fanout(key.slot(), root_bank);
     let (root_distance, addrs) =
         cluster_nodes.get_retransmit_addrs(slot_leader, key, data_plane_fanout)?;
-    let addrs: Vec<_> = addrs
+    let mut addrs: Vec<_> = addrs
         .into_iter()
         .filter(|addr| socket_addr_space.check(addr))
         .collect();
+    if let Some(addr) = shred_receiver_addr {
+        addrs.push(*addr);
+    }
+
     compute_turbine_peers.stop();
     stats
         .compute_turbine_peers_total
@@ -378,6 +387,7 @@ pub fn retransmitter(
     shreds_receiver: Receiver<Vec</*shred:*/ Vec<u8>>>,
     max_slots: Arc<MaxSlots>,
     rpc_subscriptions: Option<Arc<RpcSubscriptions>>,
+    shred_receiver_addr: Arc<RwLock<Option<SocketAddr>>>,
 ) -> JoinHandle<()> {
     let cluster_nodes_cache = ClusterNodesCache::<RetransmitStage>::new(
         CLUSTER_NODES_CACHE_NUM_EPOCH_CAP,
@@ -409,6 +419,7 @@ pub fn retransmitter(
                 &mut shred_deduper,
                 &max_slots,
                 rpc_subscriptions.as_deref(),
+                &shred_receiver_addr,
             ) {
                 Ok(()) => (),
                 Err(RecvTimeoutError::Timeout) => (),
@@ -432,6 +443,7 @@ impl RetransmitStage {
         retransmit_receiver: Receiver<Vec</*shred:*/ Vec<u8>>>,
         max_slots: Arc<MaxSlots>,
         rpc_subscriptions: Option<Arc<RpcSubscriptions>>,
+        shred_receiver_addr: Arc<RwLock<Option<SocketAddr>>>,
     ) -> Self {
         let retransmit_thread_handle = retransmitter(
             retransmit_sockets,
@@ -442,6 +454,7 @@ impl RetransmitStage {
             retransmit_receiver,
             max_slots,
             rpc_subscriptions,
+            shred_receiver_addr,
         );
 
         Self {
diff --git a/validator/Cargo.toml b/validator/Cargo.toml
index 6222435906a3..739d61159a11 100644
--- a/validator/Cargo.toml
+++ b/validator/Cargo.toml
@@ -55,6 +55,7 @@ solana-rpc = { workspace = true }
 solana-rpc-client = { workspace = true }
 solana-rpc-client-api = { workspace = true }
 solana-runtime = { workspace = true }
+solana-runtime-plugin = { workspace = true }
 solana-sdk = { workspace = true }
 solana-send-transaction-service = { workspace = true }
 solana-storage-bigtable = { workspace = true }
@@ -67,6 +68,7 @@ solana-vote-program = { workspace = true }
 symlink = { workspace = true }
 thiserror = { workspace = true }
 tokio = { workspace = true }
+tonic = { workspace = true, features = ["tls", "tls-roots", "tls-webpki-roots"] }
 
 [dev-dependencies]
 solana-account-decoder = { workspace = true }
diff --git a/validator/src/admin_rpc_service.rs b/validator/src/admin_rpc_service.rs
index 99ef4b53a0b9..4cd7b44c93a7 100644
--- a/validator/src/admin_rpc_service.rs
+++ b/validator/src/admin_rpc_service.rs
@@ -12,6 +12,10 @@ use {
     solana_core::{
         admin_rpc_post_init::AdminRpcRequestMetadataPostInit,
         consensus::{tower_storage::TowerStorage, Tower},
+        proxy::{
+            block_engine_stage::{BlockEngineConfig, BlockEngineStage},
+            relayer_stage::{RelayerConfig, RelayerStage},
+        },
         repair::repair_service,
         validator::ValidatorStartProgress,
     },
@@ -30,6 +34,7 @@ use {
         fmt::{self, Display},
         net::SocketAddr,
         path::{Path, PathBuf},
+        str::FromStr,
         sync::{Arc, RwLock},
         thread::{self, Builder},
         time::{Duration, SystemTime},
@@ -243,6 +248,27 @@ pub trait AdminRpc {
         meta: Self::Metadata,
         public_tpu_forwards_addr: SocketAddr,
     ) -> Result<()>;
+
+    #[rpc(meta, name = "setBlockEngineConfig")]
+    fn set_block_engine_config(
+        &self,
+        meta: Self::Metadata,
+        block_engine_url: String,
+        trust_packets: bool,
+    ) -> Result<()>;
+
+    #[rpc(meta, name = "setRelayerConfig")]
+    fn set_relayer_config(
+        &self,
+        meta: Self::Metadata,
+        relayer_url: String,
+        trust_packets: bool,
+        expected_heartbeat_interval_ms: u64,
+        max_failed_heartbeats: u64,
+    ) -> Result<()>;
+
+    #[rpc(meta, name = "setShredReceiverAddress")]
+    fn set_shred_receiver_address(&self, meta: Self::Metadata, addr: String) -> Result<()>;
 }
 
 pub struct AdminRpcImpl;
@@ -441,6 +467,30 @@ impl AdminRpc for AdminRpcImpl {
         Ok(())
     }
 
+    fn set_block_engine_config(
+        &self,
+        meta: Self::Metadata,
+        block_engine_url: String,
+        trust_packets: bool,
+    ) -> Result<()> {
+        debug!("set_block_engine_config request received");
+        let config = BlockEngineConfig {
+            block_engine_url,
+            trust_packets,
+        };
+        // Detailed log messages are printed inside validate function
+        if BlockEngineStage::is_valid_block_engine_config(&config) {
+            meta.with_post_init(|post_init| {
+                *post_init.block_engine_config.lock().unwrap() = config;
+                Ok(())
+            })
+        } else {
+            Err(jsonrpc_core::error::Error::invalid_params(
+                "failed to set block engine config. see logs for details.",
+            ))
+        }
+    }
+
     fn set_identity(
         &self,
         meta: Self::Metadata,
@@ -475,6 +525,55 @@ impl AdminRpc for AdminRpcImpl {
         AdminRpcImpl::set_identity_keypair(meta, identity_keypair, require_tower)
     }
 
+    fn set_relayer_config(
+        &self,
+        meta: Self::Metadata,
+        relayer_url: String,
+        trust_packets: bool,
+        expected_heartbeat_interval_ms: u64,
+        max_failed_heartbeats: u64,
+    ) -> Result<()> {
+        debug!("set_relayer_config request received");
+        let expected_heartbeat_interval = Duration::from_millis(expected_heartbeat_interval_ms);
+        let oldest_allowed_heartbeat =
+            Duration::from_millis(max_failed_heartbeats * expected_heartbeat_interval_ms);
+        let config = RelayerConfig {
+            relayer_url,
+            expected_heartbeat_interval,
+            oldest_allowed_heartbeat,
+            trust_packets,
+        };
+        // Detailed log messages are printed inside validate function
+        if RelayerStage::is_valid_relayer_config(&config) {
+            meta.with_post_init(|post_init| {
+                *post_init.relayer_config.lock().unwrap() = config;
+                Ok(())
+            })
+        } else {
+            Err(jsonrpc_core::error::Error::invalid_params(
+                "failed to set relayer config. see logs for details.",
+            ))
+        }
+    }
+
+    fn set_shred_receiver_address(&self, meta: Self::Metadata, addr: String) -> Result<()> {
+        let shred_receiver_address = if addr.is_empty() {
+            None
+        } else {
+            Some(SocketAddr::from_str(&addr).map_err(|_| {
+                jsonrpc_core::error::Error::invalid_params(format!(
+                    "invalid shred receiver address: {}",
+                    addr
+                ))
+            })?)
+        };
+
+        meta.with_post_init(|post_init| {
+            *post_init.shred_receiver_address.write().unwrap() = shred_receiver_address;
+            Ok(())
+        })
+    }
+
     fn set_staked_nodes_overrides(&self, meta: Self::Metadata, path: String) -> Result<()> {
         let loaded_config = load_staked_nodes_overrides(&path)
             .map_err(|err| {
@@ -880,7 +979,10 @@ mod tests {
             solana_program::{program_option::COption, program_pack::Pack},
             state::{Account as TokenAccount, AccountState as TokenAccountState, Mint},
         },
-        std::{collections::HashSet, sync::atomic::AtomicBool},
+        std::{
+            collections::HashSet,
+            sync::{atomic::AtomicBool, Mutex},
+        },
     };
 
     #[derive(Default)]
@@ -918,6 +1020,9 @@ mod tests {
             let vote_account = vote_keypair.pubkey();
             let start_progress = Arc::new(RwLock::new(ValidatorStartProgress::default()));
             let repair_whitelist = Arc::new(RwLock::new(HashSet::new()));
+            let block_engine_config = Arc::new(Mutex::new(BlockEngineConfig::default()));
+            let relayer_config = Arc::new(Mutex::new(RelayerConfig::default()));
+            let shred_receiver_address = Arc::new(RwLock::new(None));
             let meta = AdminRpcRequestMetadata {
                 rpc_addr: None,
                 start_time: SystemTime::now(),
@@ -938,6 +1043,9 @@ mod tests {
                     cluster_slots: Arc::new(
                         solana_core::cluster_slots_service::cluster_slots::ClusterSlots::default(),
                     ),
+                    block_engine_config,
+                    relayer_config,
+                    shred_receiver_address,
                 }))),
                 staked_nodes_overrides: Arc::new(RwLock::new(HashMap::new())),
                 rpc_to_plugin_manager_sender: None,
diff --git a/validator/src/bootstrap.rs b/validator/src/bootstrap.rs
index 63084741f03a..a0e4bf45e103 100644
--- a/validator/src/bootstrap.rs
+++ b/validator/src/bootstrap.rs
@@ -816,12 +816,13 @@ fn get_highest_local_snapshot_hash(
     incremental_snapshot_archives_dir: impl AsRef<Path>,
     incremental_snapshot_fetch: bool,
 ) -> Option<(Slot, Hash)> {
-    snapshot_utils::get_highest_full_snapshot_archive_info(full_snapshot_archives_dir)
+    snapshot_utils::get_highest_full_snapshot_archive_info(full_snapshot_archives_dir, None)
         .and_then(|full_snapshot_info| {
             if incremental_snapshot_fetch {
                 snapshot_utils::get_highest_incremental_snapshot_archive_info(
                     incremental_snapshot_archives_dir,
                     full_snapshot_info.slot(),
+                    None,
                 )
                 .map(|incremental_snapshot_info| {
                     (
diff --git a/validator/src/cli.rs b/validator/src/cli.rs
index d2b70583d205..8d8c4767a68d 100644
--- a/validator/src/cli.rs
+++ b/validator/src/cli.rs
@@ -68,6 +68,10 @@ const MAX_SNAPSHOT_DOWNLOAD_ABORT: u32 = 5;
 // with less than 2 ticks per slot.
 const MINIMUM_TICKS_PER_SLOT: u64 = 2;
 
+const DEFAULT_PREALLOCATED_BUNDLE_COST: &str = "3000000";
+const DEFAULT_RELAYER_EXPECTED_HEARTBEAT_INTERVAL_MS: &str = "500";
+const DEFAULT_RELAYER_MAX_FAILED_HEARTBEATS: &str = "3";
+
 pub fn app<'a>(version: &'a str, default_args: &'a DefaultArgs) -> App<'a, 'a> {
     return App::new(crate_name!())
         .about(crate_description!())
@@ -81,6 +85,87 @@ pub fn app<'a>(version: &'a str, default_args: &'a DefaultArgs) -> App<'a, 'a> {
                 .long(SKIP_SEED_PHRASE_VALIDATION_ARG.long)
                 .help(SKIP_SEED_PHRASE_VALIDATION_ARG.help),
         )
+        .arg(
+            Arg::with_name("block_engine_url")
+                .long("block-engine-url")
+                .help("Block engine url.  Set to empty string to disable block engine connection.")
+                .takes_value(true)
+        )
+        .arg(
+            Arg::with_name("relayer_url")
+                .long("relayer-url")
+                .help("Relayer url. Set to empty string to disable relayer connection.")
+                .takes_value(true)
+        )
+        .arg(
+            Arg::with_name("trust_relayer_packets")
+                .long("trust-relayer-packets")
+                .takes_value(false)
+                .help("Skip signature verification on relayer packets. Not recommended unless the relayer is trusted.")
+        )
+        .arg(
+            Arg::with_name("relayer_expected_heartbeat_interval_ms")
+                .long("relayer-expected-heartbeat-interval-ms")
+                .takes_value(true)
+                .help("Interval at which the Relayer is expected to send heartbeat messages.")
+                .default_value(DEFAULT_RELAYER_EXPECTED_HEARTBEAT_INTERVAL_MS)
+        )
+        .arg(
+            Arg::with_name("relayer_max_failed_heartbeats")
+                .long("relayer-max-failed-heartbeats")
+                .takes_value(true)
+                .help("Maximum number of heartbeats the Relayer can miss before falling back to the normal TPU pipeline.")
+                .default_value(DEFAULT_RELAYER_MAX_FAILED_HEARTBEATS)
+        )
+        .arg(
+            Arg::with_name("trust_block_engine_packets")
+                .long("trust-block-engine-packets")
+                .takes_value(false)
+                .help("Skip signature verification on block engine packets. Not recommended unless the block engine is trusted.")
+        )
+        .arg(
+            Arg::with_name("tip_payment_program_pubkey")
+                .long("tip-payment-program-pubkey")
+                .value_name("TIP_PAYMENT_PROGRAM_PUBKEY")
+                .takes_value(true)
+                .help("The public key of the tip-payment program")
+        )
+        .arg(
+            Arg::with_name("tip_distribution_program_pubkey")
+                .long("tip-distribution-program-pubkey")
+                .value_name("TIP_DISTRIBUTION_PROGRAM_PUBKEY")
+                .takes_value(true)
+                .help("The public key of the tip-distribution program.")
+        )
+        .arg(
+            Arg::with_name("merkle_root_upload_authority")
+                .long("merkle-root-upload-authority")
+                .value_name("MERKLE_ROOT_UPLOAD_AUTHORITY")
+                .takes_value(true)
+                .help("The public key of the authorized merkle-root uploader.")
+        )
+        .arg(
+            Arg::with_name("commission_bps")
+                .long("commission-bps")
+                .value_name("COMMISSION_BPS")
+                .takes_value(true)
+                .help("The commission validator takes from tips expressed in basis points.")
+        )
+        .arg(
+            Arg::with_name("preallocated_bundle_cost")
+                .long("preallocated-bundle-cost")
+                .value_name("PREALLOCATED_BUNDLE_COST")
+                .takes_value(true)
+                .default_value(DEFAULT_PREALLOCATED_BUNDLE_COST)
+                .help("Number of CUs to allocate for bundles at beginning of slot.")
+        )
+        .arg(
+            Arg::with_name("shred_receiver_address")
+                .long("shred-receiver-address")
+                .value_name("SHRED_RECEIVER_ADDRESS")
+                .takes_value(true)
+                .help("Validator will forward all shreds to this address in addition to normal turbine operation. Set to empty string to disable.")
+        )
         .arg(
             Arg::with_name("identity")
                 .short("i")
@@ -1182,6 +1267,14 @@ pub fn app<'a>(version: &'a str, default_args: &'a DefaultArgs) -> App<'a, 'a> {
                 .multiple(true)
                 .help("Specify the configuration file for the Geyser plugin."),
         )
+.arg(
+            Arg::with_name("runtime_plugin_config")
+                .long("runtime-plugin-config")
+                .value_name("FILE")
+                .takes_value(true)
+                .multiple(true)
+                .help("Specify the configuration file for a Runtime plugin.")
+        )
         .arg(
             Arg::with_name("snapshot_archive_format")
                 .long("snapshot-archive-format")
@@ -1573,6 +1666,68 @@ pub fn app<'a>(version: &'a str, default_args: &'a DefaultArgs) -> App<'a, 'a> {
         .args(&thread_args(&default_args.thread_args))
         .args(&get_deprecated_arguments())
         .after_help("The default subcommand is run")
+        .subcommand(
+            SubCommand::with_name("set-block-engine-config")
+                .about("Set configuration for connection to a block engine")
+                .arg(
+                    Arg::with_name("block_engine_url")
+                        .long("block-engine-url")
+                        .help("Block engine url.  Set to empty string to disable block engine connection.")
+                        .takes_value(true)
+                        .required(true)
+                )
+                .arg(
+                    Arg::with_name("trust_block_engine_packets")
+                        .long("trust-block-engine-packets")
+                        .takes_value(false)
+                        .help("Skip signature verification on block engine packets. Not recommended unless the block engine is trusted.")
+                )
+        )
+        .subcommand(
+            SubCommand::with_name("set-relayer-config")
+                .about("Set configuration for connection to a relayer")
+                .arg(
+                    Arg::with_name("relayer_url")
+                        .long("relayer-url")
+                        .help("Relayer url. Set to empty string to disable relayer connection.")
+                        .takes_value(true)
+                        .required(true)
+                )
+                .arg(
+                    Arg::with_name("trust_relayer_packets")
+                        .long("trust-relayer-packets")
+                        .takes_value(false)
+                        .help("Skip signature verification on relayer packets. Not recommended unless the relayer is trusted.")
+                )
+                .arg(
+                    Arg::with_name("relayer_expected_heartbeat_interval_ms")
+                        .long("relayer-expected-heartbeat-interval-ms")
+                        .takes_value(true)
+                        .help("Interval at which the Relayer is expected to send heartbeat messages.")
+                        .required(false)
+                        .default_value(DEFAULT_RELAYER_EXPECTED_HEARTBEAT_INTERVAL_MS)
+                )
+                .arg(
+                    Arg::with_name("relayer_max_failed_heartbeats")
+                        .long("relayer-max-failed-heartbeats")
+                        .takes_value(true)
+                        .help("Maximum number of heartbeats the Relayer can miss before falling back to the normal TPU pipeline.")
+                        .required(false)
+                        .default_value(DEFAULT_RELAYER_MAX_FAILED_HEARTBEATS)
+                )
+        )
+        .subcommand(
+            SubCommand::with_name("set-shred-receiver-address")
+                .about("Changes shred receiver address")
+                .arg(
+                    Arg::with_name("shred_receiver_address")
+                        .long("shred-receiver-address")
+                        .value_name("SHRED_RECEIVER_ADDRESS")
+                        .takes_value(true)
+                        .help("Validator will forward all shreds to this address in addition to normal turbine operation. Set to empty string to disable.")
+                        .required(true)
+                )
+        )
         .subcommand(
             SubCommand::with_name("exit")
                 .about("Send an exit request to the validator")
@@ -1749,6 +1904,48 @@ pub fn app<'a>(version: &'a str, default_args: &'a DefaultArgs) -> App<'a, 'a> {
         )
         .subcommand(SubCommand::with_name("monitor").about("Monitor the validator"))
         .subcommand(SubCommand::with_name("run").about("Run the validator"))
+        .subcommand(
+            SubCommand::with_name("runtime-plugin")
+                .about("Manage and view runtime plugins")
+                .setting(AppSettings::SubcommandRequiredElseHelp)
+                .setting(AppSettings::InferSubcommands)
+                .subcommand(
+                    SubCommand::with_name("list")
+                        .about("List all current running runtime plugins")
+                )
+                .subcommand(
+                    SubCommand::with_name("unload")
+                        .about("Unload a particular runtime plugin. You must specify the runtime plugin name")
+                        .arg(
+                            Arg::with_name("name")
+                                .required(true)
+                                .takes_value(true)
+                        )
+                )
+                .subcommand(
+                    SubCommand::with_name("reload")
+                        .about("Reload a particular runtime plugin. You must specify the runtime plugin name and the new config path")
+                        .arg(
+                            Arg::with_name("name")
+                                .required(true)
+                                .takes_value(true)
+                        )
+                        .arg(
+                            Arg::with_name("config")
+                                .required(true)
+                                .takes_value(true)
+                        )
+                )
+                .subcommand(
+                    SubCommand::with_name("load")
+                        .about("Load a new gesyer plugin. You must specify the config path. Fails if overwriting (use reload)")
+                        .arg(
+                            Arg::with_name("config")
+                                .required(true)
+                                .takes_value(true)
+                        )
+                )
+        )
         .subcommand(
             SubCommand::with_name("plugin")
                 .about("Manage and view geyser plugins")
@@ -2746,6 +2943,14 @@ pub fn test_app<'a>(version: &'a str, default_args: &'a DefaultTestArgs) -> App<
                 .multiple(true)
                 .help("Specify the configuration file for the Geyser plugin."),
         )
+        .arg(
+            Arg::with_name("runtime_plugin_config")
+                .long("runtime-plugin-config")
+                .value_name("FILE")
+                .takes_value(true)
+                .multiple(true)
+                .help("Specify the configuration file for a Runtime plugin."),
+        )
         .arg(
             Arg::with_name("deactivate_feature")
                 .long("deactivate-feature")
diff --git a/validator/src/main.rs b/validator/src/main.rs
index 8467bcaa9d25..9ce6a23b791b 100644
--- a/validator/src/main.rs
+++ b/validator/src/main.rs
@@ -1,4 +1,5 @@
 #![allow(clippy::arithmetic_side_effects)]
+
 #[cfg(not(target_env = "msvc"))]
 use jemallocator::Jemalloc;
 use {
@@ -30,7 +31,9 @@ use {
     solana_core::{
         banking_trace::DISABLED_BAKING_TRACE_DIR,
         consensus::tower_storage,
+        proxy::{block_engine_stage::BlockEngineConfig, relayer_stage::RelayerConfig},
         system_monitor_service::SystemMonitorService,
+        tip_manager::{TipDistributionAccountConfig, TipManagerConfig},
         tpu::DEFAULT_TPU_COALESCE,
         validator::{
             is_snapshot_config_valid, BlockProductionMethod, BlockVerificationMethod, Validator,
@@ -63,6 +66,10 @@ use {
         snapshot_config::{SnapshotConfig, SnapshotUsage},
         snapshot_utils::{self, ArchiveFormat, SnapshotVersion},
     },
+    solana_runtime_plugin::{
+        runtime_plugin_admin_rpc_service,
+        runtime_plugin_admin_rpc_service::RuntimePluginAdminRpcRequestMetadata,
+    },
     solana_sdk::{
         clock::{Slot, DEFAULT_S_PER_SLOT},
         commitment_config::CommitmentConfig,
@@ -82,9 +89,10 @@ use {
         path::{Path, PathBuf},
         process::exit,
         str::FromStr,
-        sync::{Arc, RwLock},
+        sync::{atomic::AtomicBool, Arc, Mutex, RwLock},
         time::{Duration, SystemTime},
     },
+    tokio::runtime::Runtime,
 };
 
 #[cfg(not(target_env = "msvc"))]
@@ -474,6 +482,60 @@ pub fn main() {
 
     let operation = match matches.subcommand() {
         ("", _) | ("run", _) => Operation::Run,
+        ("set-block-engine-config", Some(subcommand_matches)) => {
+            let block_engine_url = value_t_or_exit!(subcommand_matches, "block_engine_url", String);
+            let trust_packets = subcommand_matches.is_present("trust_block_engine_packets");
+            let admin_client = admin_rpc_service::connect(&ledger_path);
+            admin_rpc_service::runtime()
+                .block_on(async move {
+                    admin_client
+                        .await?
+                        .set_block_engine_config(block_engine_url, trust_packets)
+                        .await
+                })
+                .unwrap_or_else(|err| {
+                    println!("set block engine config failed: {}", err);
+                    exit(1);
+                });
+            return;
+        }
+        ("set-relayer-config", Some(subcommand_matches)) => {
+            let relayer_url = value_t_or_exit!(subcommand_matches, "relayer_url", String);
+            let trust_packets = subcommand_matches.is_present("trust_relayer_packets");
+            let expected_heartbeat_interval_ms: u64 =
+                value_of(subcommand_matches, "relayer_expected_heartbeat_interval_ms").unwrap();
+            let max_failed_heartbeats: u64 =
+                value_of(subcommand_matches, "relayer_max_failed_heartbeats").unwrap();
+            let admin_client = admin_rpc_service::connect(&ledger_path);
+            admin_rpc_service::runtime()
+                .block_on(async move {
+                    admin_client
+                        .await?
+                        .set_relayer_config(
+                            relayer_url,
+                            trust_packets,
+                            expected_heartbeat_interval_ms,
+                            max_failed_heartbeats,
+                        )
+                        .await
+                })
+                .unwrap_or_else(|err| {
+                    println!("set relayer config failed: {}", err);
+                    exit(1);
+                });
+            return;
+        }
+        ("set-shred-receiver-address", Some(subcommand_matches)) => {
+            let addr = value_t_or_exit!(subcommand_matches, "shred_receiver_address", String);
+            let admin_client = admin_rpc_service::connect(&ledger_path);
+            admin_rpc_service::runtime()
+                .block_on(async move { admin_client.await?.set_shred_receiver_address(addr).await })
+                .unwrap_or_else(|err| {
+                    println!("set shred receiver address failed: {}", err);
+                    exit(1);
+                });
+            return;
+        }
         ("authorized-voter", Some(authorized_voter_subcommand_matches)) => {
             match authorized_voter_subcommand_matches.subcommand() {
                 ("add", Some(subcommand_matches)) => {
@@ -625,6 +687,92 @@ pub fn main() {
                 _ => unreachable!(),
             }
         }
+        ("runtime-plugin", Some(plugin_subcommand_matches)) => {
+            let runtime_plugin_rpc_client = runtime_plugin_admin_rpc_service::connect(&ledger_path);
+            let runtime = Runtime::new().unwrap();
+            match plugin_subcommand_matches.subcommand() {
+                ("list", _) => {
+                    let plugins = runtime
+                        .block_on(
+                            async move { runtime_plugin_rpc_client.await?.list_plugins().await },
+                        )
+                        .unwrap_or_else(|err| {
+                            println!("Failed to list plugins: {err}");
+                            exit(1);
+                        });
+                    if !plugins.is_empty() {
+                        println!("Currently the following plugins are loaded:");
+                        for (plugin, i) in plugins.into_iter().zip(1..) {
+                            println!("  {i}) {plugin}");
+                        }
+                    } else {
+                        println!("There are currently no plugins loaded");
+                    }
+                    return;
+                }
+                ("unload", Some(subcommand_matches)) => {
+                    if let Ok(name) = value_t!(subcommand_matches, "name", String) {
+                        runtime
+                            .block_on(async {
+                                runtime_plugin_rpc_client
+                                    .await?
+                                    .unload_plugin(name.clone())
+                                    .await
+                            })
+                            .unwrap_or_else(|err| {
+                                println!("Failed to unload plugin {name}: {err:?}");
+                                exit(1);
+                            });
+                        println!("Successfully unloaded plugin: {name}");
+                    }
+                    return;
+                }
+                ("load", Some(subcommand_matches)) => {
+                    if let Ok(config) = value_t!(subcommand_matches, "config", String) {
+                        let name = runtime
+                            .block_on(async {
+                                runtime_plugin_rpc_client
+                                    .await?
+                                    .load_plugin(config.clone())
+                                    .await
+                            })
+                            .unwrap_or_else(|err| {
+                                println!("Failed to load plugin {config}: {err:?}");
+                                exit(1);
+                            });
+                        println!("Successfully loaded plugin: {name}");
+                    }
+                    return;
+                }
+                ("reload", Some(subcommand_matches)) => {
+                    if let Ok(name) = value_t!(subcommand_matches, "name", String) {
+                        if let Ok(config) = value_t!(subcommand_matches, "config", String) {
+                            println!(
+                                "This command does not work as intended on some systems.\
+                                To correctly reload an existing plugin make sure to:\
+                                    1. Rename the new plugin binary file.\
+                                    2. Unload the previous version.\
+                                    3. Load the new, renamed binary using the 'Load' command."
+                            );
+                            runtime
+                                .block_on(async {
+                                    runtime_plugin_rpc_client
+                                        .await?
+                                        .reload_plugin(name.clone(), config.clone())
+                                        .await
+                                })
+                                .unwrap_or_else(|err| {
+                                    println!("Failed to reload plugin {name}: {err:?}");
+                                    exit(1);
+                                });
+                            println!("Successfully reloaded plugin: {name}");
+                        }
+                    }
+                    return;
+                }
+                _ => unreachable!(),
+            }
+        }
         ("contact-info", Some(subcommand_matches)) => {
             let output_mode = subcommand_matches.value_of("output");
             let admin_client = admin_rpc_service::connect(&ledger_path);
@@ -1381,6 +1529,44 @@ pub fn main() {
         tvu_receive_threads,
     } = cli::thread_args::parse_num_threads_args(&matches);
 
+    let voting_disabled = matches.is_present("no_voting") || restricted_repair_only_mode;
+    let tip_manager_config = tip_manager_config_from_matches(&matches, voting_disabled);
+
+    let block_engine_config = BlockEngineConfig {
+        block_engine_url: if matches.is_present("block_engine_url") {
+            value_of(&matches, "block_engine_url").expect("couldn't parse block_engine_url")
+        } else {
+            "".to_string()
+        },
+        trust_packets: matches.is_present("trust_block_engine_packets"),
+    };
+
+    // Defaults are set in cli definition, safe to use unwrap() here
+    let expected_heartbeat_interval_ms: u64 =
+        value_of(&matches, "relayer_expected_heartbeat_interval_ms").unwrap();
+    assert!(
+        expected_heartbeat_interval_ms > 0,
+        "relayer-max-failed-heartbeats must be greater than zero"
+    );
+    let max_failed_heartbeats: u64 = value_of(&matches, "relayer_max_failed_heartbeats").unwrap();
+    assert!(
+        max_failed_heartbeats > 0,
+        "relayer-max-failed-heartbeats must be greater than zero"
+    );
+
+    let relayer_config = RelayerConfig {
+        relayer_url: if matches.is_present("relayer_url") {
+            value_of(&matches, "relayer_url").expect("couldn't parse relayer_url")
+        } else {
+            "".to_string()
+        },
+        expected_heartbeat_interval: Duration::from_millis(expected_heartbeat_interval_ms),
+        oldest_allowed_heartbeat: Duration::from_millis(
+            max_failed_heartbeats * expected_heartbeat_interval_ms,
+        ),
+        trust_packets: matches.is_present("trust_relayer_packets"),
+    };
+
     let mut validator_config = ValidatorConfig {
         require_tower: matches.is_present("require_tower"),
         tower_storage,
@@ -1512,6 +1698,14 @@ pub fn main() {
             log_messages_bytes_limit: value_of(&matches, "log_messages_bytes_limit"),
             ..RuntimeConfig::default()
         },
+        relayer_config: Arc::new(Mutex::new(relayer_config)),
+        block_engine_config: Arc::new(Mutex::new(block_engine_config)),
+        tip_manager_config,
+        shred_receiver_address: Arc::new(RwLock::new(
+            matches
+                .value_of("shred_receiver_address")
+                .map(|addr| SocketAddr::from_str(addr).expect("shred_receiver_address invalid")),
+        )),
         staked_nodes_overrides: staked_nodes_overrides.clone(),
         use_snapshot_archives_at_startup: value_t_or_exit!(
             matches,
@@ -1523,6 +1717,8 @@ pub fn main() {
         replay_transactions_threads,
         delay_leader_block_for_pending_fork: matches
             .is_present("delay_leader_block_for_pending_fork"),
+        preallocated_bundle_cost: value_of(&matches, "preallocated_bundle_cost")
+            .expect("preallocated_bundle_cost set as default"),
         ..ValidatorConfig::default()
     };
 
@@ -1861,6 +2057,31 @@ pub fn main() {
         },
     );
 
+    let runtime_plugin_config_and_rpc_rx = {
+        let plugin_exit = Arc::new(AtomicBool::new(false));
+        let (rpc_request_sender, rpc_request_receiver) = unbounded();
+        solana_runtime_plugin::runtime_plugin_admin_rpc_service::run(
+            &ledger_path,
+            RuntimePluginAdminRpcRequestMetadata {
+                rpc_request_sender,
+                validator_exit: validator_config.validator_exit.clone(),
+            },
+            plugin_exit,
+        );
+
+        if matches.is_present("runtime_plugin_config") {
+            (
+                values_t_or_exit!(matches, "runtime_plugin_config", String)
+                    .into_iter()
+                    .map(PathBuf::from)
+                    .collect(),
+                rpc_request_receiver,
+            )
+        } else {
+            (vec![], rpc_request_receiver)
+        }
+    };
+
     let gossip_host: IpAddr = matches
         .value_of("gossip_host")
         .map(|gossip_host| {
@@ -2043,6 +2264,7 @@ pub fn main() {
         tpu_enable_udp,
         tpu_max_connections_per_ipaddr_per_minute,
         admin_service_post_init,
+        Some(runtime_plugin_config_and_rpc_rx),
     )
     .unwrap_or_else(|e| {
         error!("Failed to start validator: {:?}", e);
@@ -2108,3 +2330,47 @@ fn process_account_indexes(matches: &ArgMatches) -> AccountSecondaryIndexes {
         indexes: account_indexes,
     }
 }
+
+fn tip_manager_config_from_matches(
+    matches: &ArgMatches,
+    voting_disabled: bool,
+) -> TipManagerConfig {
+    TipManagerConfig {
+        tip_payment_program_id: pubkey_of(matches, "tip_payment_program_pubkey").unwrap_or_else(
+            || {
+                if !voting_disabled {
+                    panic!("--tip-payment-program-pubkey argument required when validator is voting");
+                }
+                Pubkey::new_unique()
+            },
+        ),
+        tip_distribution_program_id: pubkey_of(matches, "tip_distribution_program_pubkey")
+            .unwrap_or_else(|| {
+                if !voting_disabled {
+                    panic!("--tip-distribution-program-pubkey argument required when validator is voting");
+                }
+                Pubkey::new_unique()
+            }),
+        tip_distribution_account_config: TipDistributionAccountConfig {
+            merkle_root_upload_authority: pubkey_of(matches, "merkle_root_upload_authority")
+                .unwrap_or_else(|| {
+                    if !voting_disabled {
+                        panic!("--merkle-root-upload-authority argument required when validator is voting");
+                    }
+                    Pubkey::new_unique()
+                }),
+            vote_account: pubkey_of(matches, "vote_account").unwrap_or_else(|| {
+                if !voting_disabled {
+                    panic!("--vote-account argument required when validator is voting");
+                }
+                Pubkey::new_unique()
+            }),
+            commission_bps: value_t!(matches, "commission_bps", u16).unwrap_or_else(|_| {
+                if !voting_disabled {
+                    panic!("--commission-bps argument required when validator is voting");
+                }
+                0
+            }),
+        },
+    }
+}
diff --git a/version/src/lib.rs b/version/src/lib.rs
index f570188f1d12..31c553bcfdc9 100644
--- a/version/src/lib.rs
+++ b/version/src/lib.rs
@@ -79,7 +79,7 @@ impl Default for Version {
             commit: compute_commit(option_env!("CI_COMMIT")).unwrap_or_default(),
             feature_set,
             // Other client implementations need to modify this line.
-            client: u16::try_from(ClientId::Agave).unwrap(),
+            client: u16::try_from(ClientId::JitoLabs).unwrap(),
         }
     }
 }
diff --git a/wen-restart/src/wen_restart.rs b/wen-restart/src/wen_restart.rs
index 71b8ea027b80..37bacdb7844b 100644
--- a/wen-restart/src/wen_restart.rs
+++ b/wen-restart/src/wen_restart.rs
@@ -448,7 +448,7 @@ pub(crate) fn generate_snapshot(
     // snapshot to use as base, so the logic is more complicated. For now we always generate
     // an incremental snapshot.
     let mut directory = &snapshot_config.full_snapshot_archives_dir;
-    let Some(full_snapshot_slot) = get_highest_full_snapshot_archive_slot(directory) else {
+    let Some(full_snapshot_slot) = get_highest_full_snapshot_archive_slot(directory, None) else {
         return Err(WenRestartError::MissingFullSnapshot(
             snapshot_config
                 .full_snapshot_archives_dir
@@ -468,7 +468,7 @@ pub(crate) fn generate_snapshot(
     check_slot_smaller_than_intended_snapshot_slot(full_snapshot_slot, new_root_slot, directory)?;
     directory = &snapshot_config.incremental_snapshot_archives_dir;
     if let Some(incremental_snapshot_slot) =
-        get_highest_incremental_snapshot_archive_slot(directory, full_snapshot_slot)
+        get_highest_incremental_snapshot_archive_slot(directory, full_snapshot_slot, None)
     {
         check_slot_smaller_than_intended_snapshot_slot(
             incremental_snapshot_slot,
-- 
2.46.0

